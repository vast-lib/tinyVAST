---
title: "Spatial modeling"
author: "James T. Thorson"
output: rmarkdown::html_vignette
#output: rmarkdown::pdf_document
vignette: >
  %\VignetteIndexEntry{Spatial modeling}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  %\VignetteDepends{pdp}
---

```{r, include = FALSE}
has_lattice = requireNamespace("lattice", quietly = TRUE)
has_pdp = requireNamespace("pdp", quietly = TRUE)
EVAL <- has_lattice && has_pdp
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = EVAL,
  purl = EVAL
)
# Install locally
#  devtools::install_local( R'(C:\Users\James.Thorson\Desktop\Git\tinyVAST)', force=TRUE )
# Build
#  setwd(R'(C:\Users\James.Thorson\Desktop\Git\tinyVAST)'); devtools::build_rmd("vignettes/spatial.Rmd"); rmarkdown::render( "vignettes/spatial.Rmd", rmarkdown::pdf_document())
```

```{r setup, echo=TRUE, warning=FALSE, message=FALSE}
library(tinyVAST)
library(mgcv)
library(fmesher)
set.seed(101)
options("tinyVAST.verbose" = FALSE)
```

`tinyVAST` is an R package for fitting vector autoregressive spatio-temporal (VAST) models using a minimal and user-friendly interface.
We here show how it can fit spatial autoregressive model

```{r, eval=TRUE, echo=TRUE, message=FALSE, fig.width=6, fig.height=6}
# Simulate a 2D AR1 spatial process with a cyclic confounder w
n_x = n_y = 25
n_w = 10
R_xx = exp(-0.4 * abs(outer(1:n_x, 1:n_x, FUN="-")) )
R_yy = exp(-0.4 * abs(outer(1:n_y, 1:n_y, FUN="-")) )
z = mvtnorm::rmvnorm(1, sigma=kronecker(R_xx,R_yy) )

# Simulate nuissance parameter z from oscillatory (day-night) process
w = sample(1:n_w, replace=TRUE, size=length(z))
Data = data.frame( expand.grid(x=1:n_x, y=1:n_y), w=w, z=as.vector(z) + cos(w/n_w*2*pi))
Data$n = Data$z + rnorm(nrow(Data), sd=1)

# Add columns for multivariate and temporal dimensions
Data$var = "n"
Data$time = 2020

# make mesh
mesh = fm_mesh_2d( Data[,c('x','y')], n=100 )

# fit model
out = tinyVAST( data = Data,
           formula = n ~ s(w),
           spatial_graph = mesh,
           control = tinyVASTcontrol(gmrf="proj"),
           sem = "" )
```

We can then calculate the area-weighted total abundance:
```{r, eval=TRUE, echo=TRUE, message=FALSE, fig.width=6, fig.height=6}
# Predicted sample-weighted total
integrate_output(out, newdata = out$data)
# integrate_output(out, apply.epsilon=TRUE )
# predict(out)

# True (latent) sample-weighted total
sum( Data$z )
```


# Percent deviance explained

We can compute deviance residuals and percent-deviance explained:

```{r, eval=TRUE, echo=TRUE, message=FALSE, fig.width=6, fig.height=6}
R1 = sum( residuals(out, type="deviance")^2 )

# tinyVAST null model with just a single intercept
null = tinyVAST( data = Data,
                 formula = n ~ 1 )
R0 = sum( residuals(null, type="deviance")^2 )

# Percent deviance explained
1 - R1/R0
```

We can then compare this with the PDE reported by `mgcv`
```{r, eval=TRUE, echo=TRUE, message=FALSE, fig.width=6, fig.height=6}
mygam = gam( n ~ s(w) + s(x,y), data=Data ) #
summary(mygam)$dev.expl
```

where this comparison shows that using the SPDE method in tinyVAST results in higher percent-deviance-explained.  This reduced performance for splines relative to the SPDE method presumably arises due to the reduced rank of the spline basis expansion, and the better match for the Matern function (in the SPDE method) relative to the true (simulated) exponential semivariogram.

It is then easy to confirm that mgcv and tinyVAST give (essentially) identical PDE when excluding the spatial term from each.

```{r, eval=TRUE, echo=TRUE, message=FALSE, fig.width=6, fig.height=6}
out_reduced = tinyVAST( data = Data,
                        formula = n ~ s(w) )
R1_reduced = sum( residuals(out_reduced, type="deviance")^2 )
1 - R1_reduced/R0

#
mygam_reduced = gam( n ~ s(w), data=Data ) #
summary(mygam_reduced)$dev.expl
```

# Visualize spatial response

`tinyVAST` then has a standard `predict` function:
```{r, eval=TRUE, echo=TRUE, message=FALSE, fig.width=6, fig.height=6}
predict(out, newdata=data.frame(x=1, y=1, time=1, w=1, var="n") )
```

and this is used to compute the spatial response
```{r, eval=TRUE, echo=TRUE, message=FALSE, fig.width=6, fig.height=6}
# Prediction grid
pred = outer( seq(1,n_x,len=51),
              seq(1,n_y,len=51),
              FUN=\(x,y) predict(out,newdata=data.frame(x=x,y=y,w=1,time=1,var="n")) )
image( x=seq(1,n_x,len=51), y=seq(1,n_y,len=51), z=pred, main="Predicted response" )

# True value
image( x=1:n_x, y=1:n_y, z=matrix(Data$z,ncol=n_y), main="True response" )
```

We can also compute the marginal effect of the cyclic confounder
```{r, eval=TRUE, echo=TRUE, message=FALSE, fig.width=6, fig.height=6}
library(pdp)  # approx = TRUE gives effects for average of other covariates
library(lattice)
#library(visreg)

# compute partial dependence plot
Partial = partial( object = out,
                   pred.var = "w",
                   pred.fun = \(object,newdata) predict(object,newdata),
                   train = Data,
                   approx = TRUE )

# Lattice plots as default option
plotPartial( Partial )
```
