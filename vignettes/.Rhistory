library(tinyVAST)
library(mgcv)
library(fmesher)
library(pdp)  # approx = TRUE gives effects for average of other covariates
library(lattice)
library(ggplot2)
set.seed(101)
options("tinyVAST.verbose" = FALSE)
has_lattice = requireNamespace("lattice", quietly = TRUE)
has_pdp = requireNamespace("pdp", quietly = TRUE)
EVAL <- has_lattice && has_pdp
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>",
eval = EVAL,
purl = EVAL
)
# Install locally
#  devtools::install_local( R'(C:\Users\James.Thorson\Desktop\Git\tinyVAST)', force=TRUE )
# Build
#  setwd(R'(C:\Users\James.Thorson\Desktop\Git\tinyVAST)'); devtools::build_rmd("vignettes/spatial.Rmd"); rmarkdown::render( "vignettes/spatial.Rmd", rmarkdown::pdf_document())
# Simulate a 2D AR1 spatial process with a cyclic confounder w
n_x = n_y = 25
n_w = 10
R_xx = exp(-0.4 * abs(outer(1:n_x, 1:n_x, FUN="-")) )
R_yy = exp(-0.4 * abs(outer(1:n_y, 1:n_y, FUN="-")) )
z = mvtnorm::rmvnorm(1, sigma=kronecker(R_xx,R_yy) )
# Simulate nuissance parameter z from oscillatory (day-night) process
w = sample(1:n_w, replace=TRUE, size=length(z))
Data = data.frame( expand.grid(x=1:n_x, y=1:n_y), w=w, z=as.vector(z) + cos(w/n_w*2*pi))
Data$n = Data$z + rnorm(nrow(Data), sd=1)
# Add columns for multivariate and temporal dimensions
Data$var = "density"
Data$time = 2020
# make mesh
mesh = fm_mesh_2d( Data[,c('x','y')], cutoff = 2 )
# Plot it
plot(mesh)
# Define sem, with just one variance for the single variable
sem = "
density <-> density, spatial_sd
"
# fit model
out = tinyVAST( data = Data,
formula = n ~ s(w),
spatial_domain = mesh,
control = tinyVASTcontrol(getsd=FALSE),
space_term = sem)
# Predicted sample-weighted total
integrate_output(out, newdata = out$data)
# integrate_output(out, apply.epsilon=TRUE )
# predict(out)
# True (latent) sample-weighted total
sum( Data$z )
# Percent deviance explained
out$deviance_explained
start_time = Sys.time()
mygam = gam( n ~ s(w) + s(x,y), data=Data ) #
Sys.time() - start_time
summary(mygam)$dev.expl
out_reduced = tinyVAST( data = Data,
formula = n ~ s(w) + s(x,y) )
# Extract PDE for GAM-style spatial smoother in tinyVAST
out_reduced$deviance_explained
predict(out, newdata=data.frame(x=1, y=1, time=1, w=1, var="density") )
# Prediction grid
pred = outer( seq(1,n_x,len=51),
seq(1,n_y,len=51),
FUN=\(x,y) predict(out,newdata=data.frame(x=x,y=y,w=1,time=1,var="density")) )
image( x=seq(1,n_x,len=51), y=seq(1,n_y,len=51), z=pred, main="Predicted response" )
# True value
image( x=1:n_x, y=1:n_y, z=matrix(Data$z,ncol=n_y), main="True response" )
zpred
pred
out_reduced
predict(out, newdata=data.frame(x=1, y=1, time=1, w=1, var="density") )
pred = outer( seq(1,n_x,len=51),
seq(1,n_y,len=51),
FUN=\(x,y) predict(out,newdata=data.frame(x=x,y=y,w=1,time=1,var="density")) )
pred
predict(out, newdata=data.frame(x=1, y=11, time=1, w=1, var="density") )
predict(out, newdata=data.frame(x=11, y=11, time=1, w=1, var="density") )
predict(out, newdata=data.frame(x=11, y=1, time=1, w=1, var="density") )
# create new data frame
newdata <- data.frame(w = seq(min(Data$w), max(Data$w), length.out = 100))
newdata = cbind( newdata, 'x'=13, 'y'=13, 'var'='n' )
# make predictions
p <- predict( out, newdata=newdata, se.fit=TRUE, what="p_g" )
# Format as data frame and plot
p = data.frame( newdata, as.data.frame(p) )
ggplot(p, aes(x=w, y=fit,
ymin = fit - 1.96 * se.fit, ymax = fit + 1.96 * se.fit)) +
geom_line() + geom_ribbon(alpha = 0.4)
p
newdata
names(p)
newdata
object = out
object
remove_origdata = FALSE
what = "p_g"
se.fit = TRUE
# extract original X and Z
if(missing(newdata)){
newdata = object$data
}
assertDataFrame(newdata)
library(checkmate)
# extract original X and Z
if(missing(newdata)){
newdata = object$data
}
assertDataFrame(newdata)
if(inherits(newdata,"tbl")) stop("`data` must be a data.frame and cannot be a tibble")
what = match.arg(what)
what
# Build new
tmb_data2 = add_predictions( object = object,
newdata = newdata,
remove_origdata = remove_origdata )
tmb_data2$c_g
newdata
names(tmb_data2)
tmb_data2$e_g
tmb_data2$c_g
tmb_data2$t_g
tmb_data2$A_gs
tmb_data = object$tmb_inputs$tmb_data
origdata = object$data
names(origdata)
names(newdata)
length(object$internal$times)
tmb_data$t_i
names(tmb_data)
integer(0)
tmb_data2$e_g
tmb_data2$c_g
tmb_data2$c_i
integer(0)
tmb_data$c_i
tmb_data$t_i
tmb_data$g_i
tmb_data$c_i
tmb_data$c_g
object
newdata
tmb_data2 = add_predictions( object = object,
newdata = newdata,
remove_origdata = remove_origdata )
tmb_data2$c_g
length(object$internal$variables)
integer(0) - 1
integer(0) - int(1)
as.integer(integer(0) - int(1))
as.integer(integer(0) - 1
as.integer(integer(0) - 1)
tmb_data$Aepsilon_zz
as.integertmb_data$Aepsilon_zz)
as.integer(tmb_data$Aepsilon_zz)
class(tmb_data$Aepsilon_zz
