---
title: "VAST"
author: "James T. Thorson"
output: rmarkdown::html_vignette
#output: rmarkdown::pdf_document
vignette: >
  %\VignetteIndexEntry{VAST}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  %\VignetteDepends{pdp}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
# Install locally
#  devtools::install_local( R'(C:\Users\James.Thorson\Desktop\Git\tinyVAST)', force=TRUE )
# Build
#  setwd(R'(C:\Users\James.Thorson\Desktop\Git\tinyVAST)'); devtools::build_rmd("vignettes/VAST.Rmd")
# PDF
#  library(rmarkdown); render( "vignettes/VAST.Rmd", pdf_document())
```

```{r setup, echo=TRUE, warning=FALSE, message=FALSE}
library(tinyVAST)
library(fmesher)
set.seed(101)
```

`tinyVAST` is an R package for fitting vector autoregressive spatio-temporal (VAST) models.
We here explore the capacity to specify the vector-autoregressive spatio-temporal component.

# Spatio-temporal autoregressive model
We first explore the ability to specify a first-order autoregressive spatio-temporal process:

```{r, eval=TRUE, echo=TRUE, message=FALSE, fig.width=6, fig.height=6}
# Simulate settings
theta_xy = 0.4
n_x = n_y = 10
n_t = 10
rho = 0.8
spatial_sd = 0.5

# Simulate GMRFs
R = exp(-theta_xy * abs(outer(1:n_x, 1:n_y, FUN="-")) )
d = mvtnorm::rmvnorm(n_t, sigma=spatial_sd^2*kronecker(R,R) )

# Project through time and add mean
for( t in seq_len(n_t) ){
  if(t>1) d[t,] = rho*d[t-1,] + d[t,]
}
d = d + 2

# Shape into longform data-frame and add error
Data = data.frame( expand.grid(time=1:n_t, x=1:n_x, y=1:n_y), "var"="logn", z=as.vector(d))
Data$n = Data$z + rnorm(nrow(Data), sd=0.2)

# make mesh
mesh = fm_mesh_2d( Data[,c('x','y')] )

# fit model
out = fit( sem = "logn -> logn, -1, rho",
           data = Data,
           formula = n ~ 0 + factor(time),
           spatial_graph = mesh,
           quiet = TRUE )
out
```
The estimated values for `beta_z` then correspond to the simulated value for `rho` and `spatial_sd`.

We can compare the true densities:

```{r, eval=TRUE, echo=TRUE, message=FALSE, fig.width=6, fig.height=6}
library(sf)
data_wide = reshape( Data[,c('x','y','time','z')],
                     direction = "wide", idvar = c('x','y'), timevar = "time")
sf_data = st_as_sf( data_wide, coords=c("x","y"))
sf_grid = sf::st_make_grid( sf_data )
sf_plot = st_sf(sf_grid, st_drop_geometry(sf_data) )
plot(sf_plot, max.plot=n_t )
```

with the estimated densities:
```{r, eval=TRUE, echo=TRUE, message=FALSE, fig.width=6, fig.height=6}
Data$z_hat = predict(out)
data_wide = reshape( Data[,c('x','y','time','z_hat')],
                     direction = "wide", idvar = c('x','y'), timevar = "time")
sf_data = st_as_sf( data_wide, coords=c("x","y"))
sf_plot = st_sf(sf_grid, st_drop_geometry(sf_data) )
plot(sf_plot, max.plot=n_t )
```

where a scatterplot shows that they are highly correlated:
```{r, eval=TRUE, echo=TRUE, message=FALSE, fig.width=6, fig.height=6}
plot( x=Data$z, y=Data$z_hat )
```

Next, we compare this against the current version of VAST
```{r, eval=requireNamespace(c("INLA","VAST")), echo=TRUE, message=FALSE, fig.width=6, fig.height=6}
library(INLA)
library(VAST)
settings = make_settings( purpose="index3",
                          n_x = n_x*n_y,
                          Region = "Other",
                          bias.correct = FALSE,
                          use_anisotropy = FALSE )
settings$FieldConfig['Epsilon','Component_2'] = 0
settings$FieldConfig['Omega',] = 0
settings$RhoConfig['Epsilon1'] = 4

myVAST = fit_model( settings=settings,
                 Lat_i = Data[,'y'],
                 Lon_i = Data[,'x'],
                 t_i = Data[,'time'],
                 b_i = exp(Data[,'n']),
                 a_i = rep(1,nrow(Data)),
                 observations_LL = cbind(Lat=Data[,'y'],Lon=Data[,'x']),
                 grid_dim_km = c(100,100),
                 ObsModel = c(1,4),
                 newtonsteps = 0,
                 loopnum = 0,
                 control = list(eval.max=100, iter.max=100, trace=0) )
myVAST
```

Or with sdmTMB

```{r, eval=requireNamespace(c("INLA","sdmTMB")), echo=TRUE, message=FALSE, fig.width=6, fig.height=6}
library(INLA)
library(sdmTMB)
mesh = make_mesh(Data, c("x","y"), n_knots=n_x*n_y )

start_time = Sys.time()
mysdmTMB = sdmTMB(
  formula = n ~ factor(time),
  data = Data,
  mesh = mesh,
  spatial = "off",
  spatiotemporal = "ar1",
  time = "time"
)
Sys.time() - start_time
```

# Bivariate spatio-temporal autoregressive model

We next highlight how to specify a bivariate spatio-temporal model with a cross-laggged (vector autoregressive) interaction.

```{r, eval=TRUE, echo=TRUE, message=FALSE, fig.width=6, fig.height=6}
# Simulate settings
theta_xy = 0.2
n_x = n_y = 10
n_t = 20
B = rbind( c( 0.5, -0.25),
           c(-0.1,  0.50) )

# Simulate GMRFs
R = exp(-theta_xy * abs(outer(1:n_x, 1:n_y, FUN="-")) )
d1 = mvtnorm::rmvnorm(n_t, sigma=0.2*kronecker(R,R) )
d2 = mvtnorm::rmvnorm(n_t, sigma=0.2*kronecker(R,R) )
d = abind::abind( d1, d2, along=3 )

# Project through time and add mean
for( t in seq_len(n_t) ){
  if(t>1) d[t,,] = t(B%*%t(d[t-1,,])) + d[t,,]
}
d[,,1] = d[,,1] + 2
d[,,2] = d[,,2] + 3

# Shape into longform data-frame and add error
Data = data.frame( expand.grid(time=1:n_t, x=1:n_x, y=1:n_y, "var"=c("d1","d2")), z=as.vector(d))
Data$n = Data$z + rnorm(nrow(Data), sd=0.2)

# make mesh
mesh = fm_mesh_2d( Data[,c('x','y')] )

# Define sem
sem = "
  d1 -> d1, -1, b11
  d2 -> d2, -1, b22
  d2 -> d1, -1, b21
  d1 -> d2, -1, b12
  d1 <-> d1, 0, var1
  d2 <-> d2, 0, var1
"

# fit model
out = fit( sem = sem,
           data = Data,
           formula = n ~ 0 + var,
           spatial_graph = mesh,
           quiet = TRUE )
out
```

The values for `beta_z` again correspond to the specified value for interaction-matrix `B`