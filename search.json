[{"path":"https://vast-lib.github.io/tinyVAST/articles/model-description.html","id":"bivariate-generalized-linear-mixed-model-structure","dir":"Articles","previous_headings":"","what":"Bivariate generalized linear mixed model structure","title":"tinyVAST model description","text":"tinyVAST (J. T. Thorson et al. 2025) bivariate extension generalized linear mixed model (see Tables 1 2 notation), includes two linear predictors include four additive components: Spatial interactions among variables: user can specify interactions among variables given site (spatially correlated latent variables) using arrow notation derived path analysis, based interface R package sem; Temporal interaction among variables: user can specify simultaneous lagged interactions among variables time using expanded arrow--lag notation derived R package dsem, interactions annual intercept given variable therefore apply uniformly locations. Spatio-temporal interactions among variables: user can specify simultaneous lagged interactions among variables time, interactions occur site--site basis. Generalized additive model: user specifies formula generalized additive model (GAM) interpreted R package mgcv. model components missing, tinyVAST estimates parameters similar mgcv, small differences resulting different methods parameter estimation; four components assembled two linear predictors: p1,=ð—1,ð›‚1+ð™1,ð›„1âŸformula+ð€ð›€1,c[]âŸspace_term+ðƒ1,c[],t[]âŸtime_term+ð€ð„1,c[],t[]âŸspacetime_term+ð–1,(ð€ðšµ1)TâŸspatially_varyingp2,=ð—2,ð›‚2+ð™2,ð›„2âŸformula+ð€ð›€2,c[]âŸspace_term+ðƒ2,c[],t[]âŸtime_term+ð€ð„2,c[],t[]âŸspacetime_term+ð–2,(ð€ðšµ2)TâŸspatially_varying \\begin{aligned} p_{\\mathrm 1,} &= \\underbrace{\\mathbf X_{\\mathrm 1,} \\mathbf\\alpha_{\\mathrm 1} + \\mathbf Z_{\\mathrm 1,} \\mathbf\\gamma_{\\mathrm 1}}_\\text{formula} + \\underbrace{\\mathbf A_{} \\mathbf\\Omega_{\\mathrm 1,c[]}}_\\text{space_term} + \\underbrace{\\mathbf D_{\\mathrm 1,c[],t[]}}_\\text{time_term} + \\underbrace{\\mathbf A_i \\mathbf E_{\\mathrm 1,c[],t[]}}_\\text{spacetime_term} + \\underbrace{\\mathbf W_{\\mathrm 1,} (\\mathbf A_{} \\mathbf\\Xi_{\\mathrm 1})^{\\mathrm T} }_\\text{spatially_varying}  \\\\ p_{\\mathrm 2,} &= \\underbrace{\\mathbf X_{\\mathrm 2,} \\mathbf\\alpha_{\\mathrm 2} + \\mathbf Z_{\\mathrm 2,} \\mathbf\\gamma_{\\mathrm 2}}_\\text{formula} + \\underbrace{\\mathbf A_{} \\mathbf\\Omega_{\\mathrm 2,c[]}}_\\text{space_term} + \\underbrace{\\mathbf D_{\\mathrm 2,c[],t[]}}_\\text{time_term} + \\underbrace{\\mathbf A_i \\mathbf E_{\\mathrm 2,c[],t[]}}_\\text{spacetime_term} + \\underbrace{\\mathbf W_{\\mathrm 2,} (\\mathbf A_{} \\mathbf\\Xi_{\\mathrm 2})^{\\mathrm T} }_\\text{spatially_varying} \\end{aligned} p1,ip_{\\mathrm 1,} first linear predictor; ð—1,ð›‚1+ð™1,ð›„1\\mathbf X_{\\mathrm 1,} \\mathbf\\alpha_{\\mathrm 1} + \\mathbf Z_{\\mathrm 1,} \\mathbf\\gamma_{\\mathrm 1} contribution GAM component specified using formula parsed package mgcv; ð›‚1\\mathbf\\alpha_{\\mathrm 1} GAM fixed effects associated design matrix ð—1\\mathbf X_{\\mathrm 1}, ð—1,\\mathbf X_{\\mathrm 1,} row design matrix sample ii; ð›„1\\mathbf\\gamma_{\\mathrm 1} GAM random effects associated design matrix ð™\\mathbf Z, ð™1,\\mathbf Z_{\\mathrm 1,} row design matrix; ð€ð›€1,c[]\\mathbf A_{} \\mathbf\\Omega_{\\mathrm 1,c[]} contribution space-veriable interaction ð›€\\mathbf\\Omega projected sample ii, ð€\\mathbf interpolation matrix dimension Ã—SI \\times S row ð€\\mathbf A_{} interpolates spatial vector ð›€1,c[]\\mathbf\\Omega_{\\mathrm 1,c[]} sample ii variable c[]c[]; ðƒ1,c[],t[]\\mathbf D_{\\mathrm 1,c[],t[]} contribution time-variable interaction ðƒ\\mathbf D sample ii; ð€ð„1,c[],t[]\\mathbf A_i \\mathbf E_{\\mathrm 1,c[],t[]} contribution space-variable-time interaction ð„\\mathbf E projected sample ii; ð–1,ð€ðšµ1,c[]\\mathbf W_{\\mathrm 1,} \\mathbf A_{} \\mathbf\\Xi_{\\mathrm 1,c[]} contribution spatially varying coefficients, .e., zero-centered spatially varying slope Îž1,c[]\\Xi_{\\mathrm 1,c[]} projected location samples, local slopes multiplied user-supplied covariates design matrix W1,iW_{\\mathrm 1,} terms defined similarly second linear predictor p2,ip_{\\mathrm 2,} except using subscript-2. linear predictors passed bivariate inverse-link function specify distribution errors: yiâˆ¼fe[](ge[]âˆ’1(p1,,p2,),Î¸e[]) y_i \\sim f_{e[]}( g_{e[]}^{-1} (p_{\\mathrm 1,}, p_{\\mathrm 2,}), \\theta_{e[]} ) fe[]f_{e[]} probability density mass function sample ii; ge[]âˆ’1(p1,,p2,)g_{e[]}^{-1} (p_{\\mathrm 1,}, p_{\\mathrm 2,}) bivariate inverse-link function transforms linear predictors central tendancy parameters distribution; Î¸e[]\\theta_{e[]} dispersion parameters distribution e[]e[] sample ii; simple case, distribution requires single linear predictor ð©2=ðŸŽ\\mathbf p_{\\mathrm 2} = \\mathbf 0 construction drops model. case, model collapses generalized linear mixed model. example might log-link Poisson distribution, collapses log-linked Poisson GLMM, yiâˆ¼Poisson(ep1,)y_i \\sim \\mathrm{Poisson}(e^{p_{\\mathrm 1,}}). However, tinyVAST can also handle delta-model using either logit-log Poisson-linked link functions: ge[]âˆ’1(p1,,p2,)=(Î¼1,,Î¼2,) g_{e[]}^{-1} (p_{\\mathrm 1,}, p_{\\mathrm 2,}) = ( \\mu_{\\mathrm 1,}, \\mu_{\\mathrm 2,}  ) Î¼1,\\mu_{\\mathrm 1,} Î¼2,\\mu_{\\mathrm 2,} two linear predictors, ð”¼[yi]=Î¼1,iÎ¼2,\\mathbb{E}[y_i] = \\mu_{\\mathrm 1,} \\mu_{\\mathrm 2,}; conventional logit-log bivariate link function use logit-link encounter probabilities log-link positive catch rates: Î¼1,=ep1,i1+ep1,iÎ¼2,=ep2,\\begin{aligned} \\mu_{\\mathrm 1,} &= \\frac{e^{p_{\\mathrm 1,}}}{1+e^{p_{\\mathrm 1,}}}  \\\\ \\mu_{\\mathrm 2,} &= e^{p_{\\mathrm 2,}} \\end{aligned} Poisson-linked link function (J. T. Thorson 2018) specify complemetary log-log link encounter probabilities define second link function Î¼1,iÎ¼2,=ep1,iep2,\\mu_{\\mathrm 1,} \\mu_{\\mathrm 2,} = e^{p_{\\mathrm 1,}} e^{p_{\\mathrm 2,}}: Î¼1,=1âˆ’eâˆ’ep1,iÎ¼2,=ep1,iÎ¼1,iep2,\\begin{aligned} \\mu_{\\mathrm 1,} &= 1 - e^{-e^{p_{\\mathrm 1,}}} \\\\ \\mu_{\\mathrm 2,} &= \\frac{e^{p_{\\mathrm 1,}}}{\\mu_{\\mathrm 1,}} e^{p_{\\mathrm 2,}} \\end{aligned}  ep1,ie^{p_{\\mathrm 1,}} density underlying point process, ep2,ie^{p_{\\mathrm 2,}} biomass per point (.e., animal group). either conventional Poisson-linked delta model, Î¼1,=Pr(Y>0)\\mu_{\\mathrm 1,} = \\mathrm{Pr}(Y>0) encounter probability (fitted Bernoulli distribution), Î¼2,\\mu_{\\mathrm 2,} central tendancy positive values, .e., Î¼2,=ð”¼(Y|Y>0)\\mu_{\\mathrm 2,} = \\mathbb{E}(Y | Y>0). Usefully, interface allows analysts specify different distribution eie_i different partitions data. allows model jointly analyze different data types (GrÃ¼ss Thorson 2019), data different magnitudes sampling error.","code":""},{"path":"https://vast-lib.github.io/tinyVAST/articles/model-description.html","id":"spatial-domains","dir":"Articles","previous_headings":"","what":"Spatial domains","title":"tinyVAST model description","text":"Linear predictors include spatially autocorrelated latent variables. variables treated Gaussian Markov random fields (GMRFs), evaluating probability density GMRFs involves calculating precision matrix ðdomain=ðšºâˆ’1\\mathbf Q_{\\mathrm{domain}} = \\mathbf\\Sigma^{-1} inverse spatial covariance matrix (J. Thorson Kristensen 2024). tinyVAST involves three options specifying spatial precision:","code":""},{"path":"https://vast-lib.github.io/tinyVAST/articles/model-description.html","id":"stochastic-partial-differentiaul-equation-spde","dir":"Articles","previous_headings":"Spatial domains","what":"Stochastic partial differentiaul equation (SPDE)","title":"tinyVAST model description","text":"analyst can approximate spatial variation continuous two-dimensional surface constructing finite element mesh (FEM), treating value vertices GMRF, using bilinear interpolation (.e., piecewise linear approximation) interpolate vertices spatial domain. method developed (F. Lindgren, Rue, LindstrÃ¶m 2011), popularized software R-INLA (Lindgren 2012), first implemented TMB (J. T. Thorson et al. 2014), using elements constructed R-package fmesher (F. Lindgren 2023). case, precision constructed : ðdomain=Ï„2(Îº4ðŒ0+2Îº2ðŒ1+ðŒ2) \\mathbf Q_{\\mathrm{domain}} = \\tau^2 ( \\kappa^4 \\mathbf M_{\\mathrm 0} + 2\\kappa^2 \\mathbf M_{\\mathrm 1} + \\mathbf M_{\\mathrm 2} )  every row ð€\\mathbf A_i interpolation matrix ð€\\mathbf nonzero three vertices triangle contains sample ii","code":""},{"path":"https://vast-lib.github.io/tinyVAST/articles/model-description.html","id":"simultaneous-autoregressive-sar","dir":"Articles","previous_headings":"Spatial domains","what":"Simultaneous autoregressive (SAR):","title":"tinyVAST model description","text":"Alternatively, analyst can apply simultaneous autoregressive process (Ver Hoef, Hanks, Hooten 2018), specifying areal model represents value within spatial strata: ðdomain=Ï„2(ðˆâˆ’Îºð€*)2 \\mathbf Q_{\\mathrm{domain}} = \\tau^2 (\\mathbf - \\kappa \\mathbf ^*)^2   ð€*\\mathbf ^* adjacency matrix graph specified analyst, Îº\\kappa estimated partial correlation adjacent areas, row ð€\\mathbf A_i interpolation matrix ð€\\mathbf nonzero single spatial stratum containing sample ii (noting adjacency matrix ð€*\\mathbf ^* different interpolation matrix ð€\\mathbf , use notation due collision notational standards).","code":""},{"path":"https://vast-lib.github.io/tinyVAST/articles/model-description.html","id":"stream-networks-using-a-tail-down-exponential-correlation-function","dir":"Articles","previous_headings":"Spatial domains","what":"Stream networks using a tail-down exponential correlation function","title":"tinyVAST model description","text":"Finally, analyst can specify sites partially correlated adjacent along stream network (ignoring flow direction). results Onstein-Uhlenbeck process along stream network (Charsley et al. 2023), exponential tail-model: ðdomain=(ðˆ+ðƒâˆ’ð)Tðˆ+ðƒâˆ’1(ðˆ+ðƒâˆ’ð) \\mathbf{Q}_{\\mathrm{domain}} = \\mathbf{(+D-P)}^T \\mathbf{+D}^{-1} \\mathbf{(+D-P)}  ðƒ\\mathbf D sparse diagonal matrix diagonal elements di,j=exp(âˆ’2Î¸|ð¬,ð¬j|)/(1âˆ’exp(âˆ’2Î¸|ð¬,ð¬j|)) d_{,j} =\\mathrm{exp}(-2 \\theta |\\mathbf s_i, \\mathbf s_j|) / (1 - \\mathrm{exp}(-2 \\theta |\\mathbf s_i, \\mathbf s_j|))  |ð¬,ð¬j||\\mathbf s_i, \\mathbf s_j| distance downstream (parent) node jj upstream (child) node ii, Î¸\\theta O-U parameter governing decorrelation rate. Similarly, ð\\mathbf P sparse matrix containing values Ïi,j\\rho_{,j}, : Ïi,j=exp(âˆ’Î¸|ð¬,ð¬j|)/(1âˆ’exp(âˆ’2Î¸|ð¬,ð¬j|)) \\rho_{,j} = \\mathrm{exp}(-\\theta |\\mathbf s_i, \\mathbf s_j|) / (1 - \\mathrm{exp}(-2 \\theta |\\mathbf s_i, \\mathbf s_j|))  Ïi,j\\rho_{,j} regression slope predicting upstream node ii downstream node jj. spatial interpolation matrix ð€\\mathbf row ð€\\mathbf A_i sampling predictive location, ð€\\mathbf A_i nonzero two nodes immediately downstream given location, values given location predicted weighted average based upon distance two nodes. SPDE SAR spatial domains, term Ï„\\tau defined precision ðdomain\\mathbf Q_{\\mathrm{domain}} unit variance. done spatial domain always arises combination parameters, used define variance associated spatial variable.","code":""},{"path":"https://vast-lib.github.io/tinyVAST/articles/model-description.html","id":"structural-equation-models","dir":"Articles","previous_headings":"","what":"Structural equation models","title":"tinyVAST model description","text":"tinyVAST also involves specifying structural equation model (SEM). SEM viewed either: Weak interpretation: expressive interface parameterize correlation among variables, using many parameters might appropriate; Strong interpretation: structural causal model, allowing predictions consequence counterfactual changes system. specify SEM, user uses arrow notation derived package sem (Fox 2006), described TMB (J. Thorson Kristensen 2024). example, specify linear model involves: estimates single slope parameter (represented one-headed arrow), well variance W1W_1 W2W_2 (specified two-headed arrows). complicated case, W1W_1 might cause W2W_2, turn causes W3W_3. represented : SEM interactions can complicated simple desired, can include: Latent variables loops (.e., restricted directed acyclic graphs); Values fixed priori, parameter_name provided NA starting value follows fixed value; Values mirrored among path coefficients, parameter_name provided multiple rows text file. preceding example, path coefficients one-headed arrows define path matrix ð\\mathbf P: ð=(000b12000b230) \\mathbf P =  \\begin{pmatrix}   0 & 0 & 0 \\\\   b_{12} & 0 & 0 \\\\   0 & b_{23} & 0  \\end{pmatrix} coefficents two-headed arrows define Cholesky ð†\\mathbf G exnogenous covariance matrix ð†Tð†\\mathbf G^T \\mathbf G: ð†=(s1000s2000s3) \\mathbf G =  \\begin{pmatrix}   s_{1} & 0 & 0 \\\\   0 & s_{2} & 0 \\\\   0 & 0 & s_{3}  \\end{pmatrix} matrices define simultaneous equation model: $$ \\mathbf{ w = P w + \\epsilon} \\\\ \\mathbf\\epsilon \\sim \\mathrm{MVN}( \\mathbf 0, \\mathbf G^T \\mathbf G ) $$ variance Var(ð°)=(ðˆâˆ’ð)âˆ’1ð†2(ðˆâˆ’ðT)âˆ’1\\mathrm{Var}(\\mathbf w) = (\\mathbf{- P})^{-1} \\mathbf G^2 (\\mathbf{- P}^T)^{-1}. results sparse precision matrix: ð=(ðˆâˆ’ðT)ð†âˆ’1ð†âˆ’T(ðˆâˆ’ð) \\mathbf Q = (\\mathbf{- P}^T) \\mathbf G^{-1} \\mathbf G^{-T} (\\mathbf{- P}) precision matrix ð\\mathbf Q used modular component larger tinyVAST model.","code":"w1 -> w2, b_12 w1 <-> w1, sd_1 w2 <-> w2, sd_2 # Path, parameter_name, start value w1 -> w2, b_12, 0 w2 -> w3, b_23, 0 w1 <-> w1, s_1, 1 w2 <-> w2, s_2, 1 w3 <-> w3, s_3, 1"},{"path":"https://vast-lib.github.io/tinyVAST/articles/model-description.html","id":"dynamic-structural-equation-models","dir":"Articles","previous_headings":"","what":"Dynamic structural equation models","title":"tinyVAST model description","text":"Similarly, tinyVAST involves specifying dynamic structural equation models (DSEM) (J. T. Thorson et al. 2024). specify DSEM, user uses arrow--lag notation. example, specify univariate first-order autoregressive process: four time-intervals (T=4T=4) result path matrix: ð=(0000Ï0000Ï0000Ï0) \\mathbf P =  \\begin{pmatrix}   0 & 0 & 0 & 0 \\\\   \\rho & 0 & 0 & 0 \\\\   0 & \\rho & 0 & 0 \\\\   0 & 0 & \\rho & 0  \\end{pmatrix} DSEM involves multiple times variables, sparse precision formed summing across Kronecker product time-lag interaction matrices. DSEM defines GMRF nonseparable interaction time variables, represented matrix ðtime_term\\mathbf Q_{\\mathrm{time\\_term}} dimension CTÃ—CTCT \\times CT. user can specify separate arrow--lag notation define precision matrix time-variable interaction ðtime_term\\mathbf Q_{\\mathrm{time\\_term}} space-time-variable interaction ðspacetime_term\\mathbf Q_{\\mathrm{spacetime\\_term}}. precision matrix ðtime_term\\mathbf Q_{\\mathrm{time\\_term}} time term ðƒ\\mathbf D used define time-varying intercept variable: vec(ðƒ)âˆ¼MVN(ðŸŽ,ðtime_term) \\mathrm{vec}(\\mathbf D) \\sim \\mathrm{MVN}(\\mathbf 0, \\mathbf Q_{\\mathrm{time\\_term}})  Meanwhile, space-time term ðspacetime_term\\mathbf Q_{\\mathrm{spacetime\\_term}} combined spatial precision ðspace_term\\mathbf Q_{\\mathrm{space\\_term}} explain next.","code":"w1 -> w1, 1, rho, 0.8"},{"path":"https://vast-lib.github.io/tinyVAST/articles/model-description.html","id":"spatial-interactions-for-sem-and-dsem","dir":"Articles","previous_headings":"","what":"Spatial interactions for SEM and DSEM","title":"tinyVAST model description","text":"tinyVAST uses SEM DSEM notation construct joint precision space-variable interaction ð›€\\mathbf\\Omega dimension SÃ—CS \\times C, space-time-variable interaction ð„\\mathbf E dimension SÃ—CÃ—TS \\times C \\times T. , constructs separable precision process: vec(ð„)âˆ¼MVN(ðŸŽ,ðspacetime_termâŠ—ðdomain) \\mathrm{vec}(\\mathbf E) \\sim \\mathrm{MVN}(\\mathbf 0, \\mathbf Q_{\\mathrm{spacetime\\_term}} \\otimes \\mathbf Q_{\\mathrm{domain}}) precision matrix ðspacetime_termâŠ—ðdomain\\mathbf Q_{\\mathrm{spacetime\\_term}} \\otimes \\mathbf Q_{\\mathrm{domain}} dimension STCÃ—STCSTC \\times STC match length vec(ð„)\\mathrm{vec}(\\mathbf E), vec(ð›€)âˆ¼MVN(ðŸŽ,ðspace_termâŠ—ðdomain) \\mathrm{vec}(\\mathbf\\Omega) \\sim \\mathrm{MVN}(\\mathbf 0, \\mathbf Q_{\\mathrm{space\\_term}} \\otimes \\mathbf Q_{\\mathrm{domain}}) precision matrix ðspace_termâŠ—ðdomain\\mathbf Q_{\\mathrm{space\\_term}} \\otimes \\mathbf Q_{\\mathrm{domain}} dimension SCÃ—SCSC \\times SC, match length vec(ð›€)\\mathrm{vec}(\\mathbf\\Omega). specification generalizes spatial factor analysis (Thorson et al. 2015) spatial dynamic factor analysis (J. T. Thorson et al. 2016).","code":""},{"path":"https://vast-lib.github.io/tinyVAST/articles/model-description.html","id":"generalized-additive-model","dir":"Articles","previous_headings":"","what":"Generalized additive model","title":"tinyVAST model description","text":"analyst can specify generalized additive model using syntax package mgcv (Wood 2006), parsed TMB using interface developed sdmTMB (Anderson et al. n.d.). example might involve: year species factors depth log_area continuous, specify fixed effect level year, spline smoother depth, using log_area offset, estimating random intercept level species. formula parsed internally assemble fixed effects design matrix ð—\\mathbf X basis functions spline smoothers random effects design matrix ð™\\mathbf Z. coefficients ð›„\\mathbf\\gamma associated smoothers random effects specified follow GMRF: ð›„âˆ¼GMRF(ðŸŽ,ðgam) \\mathbf\\gamma \\sim \\mathrm{GMRF}( \\mathbf 0, \\mathbf Q_{\\mathrm{gam}})  ðgam\\mathbf Q_{\\mathrm{gam}} blockwise diagonal matrix, assembled estimated variance parameters matrices constructed mgcv.","code":"count ~ year + offset(log_area) + s(depth) + s(species, bs=\"re\")"},{"path":"https://vast-lib.github.io/tinyVAST/articles/model-description.html","id":"spatially-varying-coefficients","dir":"Articles","previous_headings":"","what":"Spatially varying coefficients","title":"tinyVAST model description","text":"Finally, analyst can account spatial variation relationship specified covariate estimated response. done specifying spatially varying coefficient (SVC) (J. T. Thorson et al. 2023), can used e.g.Â account spatially varying differences catchability/detectability (GrÃ¼ss et al. 2023) account nonlocal impacts regional oceanographic indices (J. T. Thorson 2019). involves estimating SVC lâˆˆ{1,2,...,L}l \\\\{1,2,...,L\\} zero-centered Gaussian Markov random field estimating corresponding variance ÏƒÎ¾,l2\\sigma_{\\mathrm{\\xi},l}^2: Îž1,lâˆ¼GMRF(ðŸŽ,ÏƒÎ¾,lâˆ’2ðdomain) \\Xi_{\\mathrm 1,l} \\sim \\mathrm{GMRF}( \\mathbf 0, \\sigma_{\\mathrm{\\xi},l}^{-2} \\mathbf Q_{\\mathrm{domain}} ) covariate specified SVC also typically specified formula estimate non-zero mean SVC. estimated variance SVC approaches zero, suggests covariate slope vary spatially.","code":""},{"path":"https://vast-lib.github.io/tinyVAST/articles/model-description.html","id":"notation-summary","dir":"Articles","previous_headings":"","what":"Notation summary","title":"tinyVAST model description","text":"Table 1: Subscript notation Table 2: Symbol notation, code representation (model output model template code), descriptions.","code":""},{"path":[]},{"path":"https://vast-lib.github.io/tinyVAST/articles/spatial.html","id":"percent-deviance-explained","dir":"Articles","previous_headings":"","what":"Percent deviance explained","title":"Spatial modeling","text":"can compute deviance residuals percent-deviance explained: can compare PDE reported mgcv comparison shows using SPDE method tinyVAST results higher percent-deviance-explained. reduced performance splines relative SPDE method presumably arises due reduced rank spline basis expansion, better match Matern function (SPDE method) relative true (simulated) exponential semivariogram. easy confirm mgcv tinyVAST give (essentially) identical PDE switching tinyVAST use bivariate spline space.","code":"# Percent deviance explained out$deviance_explained #> [1] 0.5051624 start_time = Sys.time() mygam = gam( n ~ s(w) + s(x,y), data=Data ) # Sys.time() - start_time #> Time difference of 0.02696896 secs summary(mygam)$dev.expl #> [1] 0.3517756 out_reduced = tinyVAST( data = Data,                         formula = n ~ s(w) + s(x,y) )  # Extract PDE for GAM-style spatial smoother in tinyVAST out_reduced$deviance_explained #> [1] 0.3497174"},{"path":"https://vast-lib.github.io/tinyVAST/articles/spatial.html","id":"visualize-spatial-response","dir":"Articles","previous_headings":"","what":"Visualize spatial response","title":"Spatial modeling","text":"tinyVAST standard predict function: used compute spatial response   can also compute marginal effect cyclic confounder  Alternatively, can use predict function plot confidence intervals marginal effects, although disabled CRAN vignettes:  Runtime vignette: 1.77 secs","code":"predict(out, newdata=data.frame(x=1, y=1, time=1, w=1, var=\"density\") ) #> [1] 0.3649899 # Prediction grid pred = outer( seq(1,n_x,len=51),               seq(1,n_y,len=51),               FUN=\\(x,y) predict(out,newdata=data.frame(x=x,y=y,w=1,time=1,var=\"density\")) ) image( x=seq(1,n_x,len=51), y=seq(1,n_y,len=51), z=pred, main=\"Predicted response\" ) # True value image( x=1:n_x, y=1:n_y, z=matrix(Data$z,ncol=n_y), main=\"True response\" ) # compute partial dependence plot Partial = partial( object = out,                    pred.var = \"w\",                    pred.fun = \\(object,newdata) predict(object,newdata),                    train = Data,                    approx = TRUE )  # Lattice plots as default option plotPartial( Partial ) # create new data frame newdata <- data.frame(w = seq(min(Data$w), max(Data$w), length.out = 100)) newdata = cbind( newdata, 'x'=13, 'y'=13, 'var'='density', 'time'=2020 )  # make predictions p <- predict( out, newdata=newdata, se.fit=TRUE, what=\"p_g\" )  # Format as data frame and plot p = data.frame( newdata, as.data.frame(p) ) ggplot(p, aes(x=w, y=fit,   ymin = fit - 1.96 * se.fit, ymax = fit + 1.96 * se.fit)) +   geom_line() + geom_ribbon(alpha = 0.4)"},{"path":"https://vast-lib.github.io/tinyVAST/articles/spatial_factor_analysis.html","id":"spatial-factor-analysis","dir":"Articles","previous_headings":"","what":"Spatial factor analysis","title":"Spatial factor analysis","text":"first explore ability specify two latent variables five manifest variables. start simulate two spatial latent variables, project via simulated loadings matrix, simulate Tweedie response manifest variable: can inspect simulated loadings matrix True loadings specify model expected tinyVAST: can compare true loadings (rotated optimize comparison): Rotated true loadings estimated loadings can compared estimated true loadings matrices: Rotated estimated loadings can specify model ensuring residual spatial variation also captured: can compared estimated true loadings matrices: Rotated estimated loadings full rank Runtime vignette: 6.95 secs","code":"# Simulate settings theta_xy = 0.4 n_x = n_y = 10 n_c = 5 rho = 0.8 resid_sd = 0.5  # Simulate GMRFs R_s = exp(-theta_xy * abs(outer(1:n_x, 1:n_y, FUN=\"-\")) ) R_ss = kronecker(X=R_s, Y=R_s) delta_fs = mvtnorm::rmvnorm(n_c, sigma=R_ss )  # L_cf = matrix( rnorm(n_c^2), nrow=n_c ) L_cf[,3:5] = 0 L_cf = L_cf + resid_sd * diag(n_c)  # d_cs = L_cf %*% delta_fs dimnames(L_cf) = list( paste0(\"Var \", 1:nrow(L_cf)),                        paste0(\"Factor \", 1:ncol(L_cf)) ) knitr::kable( L_cf,               digits=2, caption=\"True loadings\") # Shape into longform data-frame and add error Data = data.frame( expand.grid(species=1:n_c, x=1:n_x, y=1:n_y),                    \"var\"=\"logn\", \"z\"=exp(as.vector(d_cs)) ) Data$n = tweedie::rtweedie( n=nrow(Data), mu=Data$z, phi=0.5, power=1.5 ) mean(Data$n==0) #> [1] 0.03  # make mesh mesh = fm_mesh_2d( Data[,c('x','y')] )  # sem = \"   f1 -> 1, l1   f1 -> 2, l2   f1 -> 3, l3   f1 -> 4, l4   f1 -> 5, l5   f2 -> 2, l6   f2 -> 3, l7   f2 -> 4, l8   f2 -> 5, l9   f1 <-> f1, NA, 1   f2 <-> f2, NA, 1   1 <-> 1, NA, 0   2 <-> 2, NA, 0   3 <-> 3, NA, 0   4 <-> 4, NA, 0   5 <-> 5, NA, 0 \"  # fit model out = tinyVAST( space_term = sem,            data = Data,            formula = n ~ 0 + factor(species),            spatial_domain = mesh,            family = tweedie(),            variables = c( \"f1\", \"f2\", 1:n_c ),            space_columns = c(\"x\",\"y\"),            variable_column = \"species\",            time_column = \"time\",            distribution_column = \"dist\",            control = tinyVASTcontrol(gmrf=\"proj\") ) out #> Call:  #> tinyVAST(formula = n ~ 0 + factor(species), data = Data, space_term = sem,  #>     family = tweedie(), spatial_domain = mesh, control = tinyVASTcontrol(gmrf = \"proj\"),  #>     space_columns = c(\"x\", \"y\"), time_column = \"time\", variable_column = \"species\",  #>     variables = c(\"f1\", \"f2\", 1:n_c), distribution_column = \"dist\") #>  #> Run time:  #> Time difference of 1.336845 secs #>  #> Family:  #> $obs #>  #> Family: tweedie  #> Link function: log  #>  #>  #>  #>  #> sdreport(.) result #>              Estimate Std. Error #> alpha_j    0.07570783 0.31850774 #> alpha_j   -0.02014888 0.39763412 #> alpha_j    0.22318277 0.21847161 #> alpha_j    0.14728087 0.27057852 #> alpha_j   -0.26514652 0.14638317 #> theta_z    0.68016356 0.11510781 #> theta_z    0.68285927 0.15773444 #> theta_z    0.31701846 0.10358197 #> theta_z    0.52123769 0.10914344 #> theta_z    0.14819781 0.09200614 #> theta_z    0.51873790 0.13709521 #> theta_z   -0.31998633 0.10049164 #> theta_z    0.23601680 0.10640963 #> theta_z   -0.21613586 0.09652980 #> log_sigma -0.52205331 0.06761637 #> log_sigma  0.21851154 0.13313019 #> log_kappa -0.26761196 0.21030826 #> Maximum gradient component: 0.002233943  #>  #> Proportion conditional deviance explained:  #> [1] 0.551999 #>  #> space_term:  #>    heads to from parameter start   Estimate  Std_Error   z_value      p_value #> 1      1  1   f1         1  <NA>  0.6801636 0.11510781  5.908926 3.443444e-09 #> 2      1  2   f1         2  <NA>  0.6828593 0.15773444  4.329170 1.496721e-05 #> 3      1  3   f1         3  <NA>  0.3170185 0.10358197  3.060556 2.209261e-03 #> 4      1  4   f1         4  <NA>  0.5212377 0.10914344  4.775713 1.790719e-06 #> 5      1  5   f1         5  <NA>  0.1481978 0.09200614  1.610738 1.072368e-01 #> 6      1  2   f2         6  <NA>  0.5187379 0.13709521  3.783778 1.544653e-04 #> 7      1  3   f2         7  <NA> -0.3199863 0.10049164 -3.184209 1.451504e-03 #> 8      1  4   f2         8  <NA>  0.2360168 0.10640963  2.218002 2.655468e-02 #> 9      1  5   f2         9  <NA> -0.2161359 0.09652980 -2.239058 2.515211e-02 #> 10     2 f1   f1         0     1  1.0000000         NA        NA           NA #> 11     2 f2   f2         0     1  1.0000000         NA        NA           NA #> 12     2  1    1         0     0  0.0000000         NA        NA           NA #> 13     2  2    2         0     0  0.0000000         NA        NA           NA #> 14     2  3    3         0     0  0.0000000         NA        NA           NA #> 15     2  4    4         0     0  0.0000000         NA        NA           NA #> 16     2  5    5         0     0  0.0000000         NA        NA           NA #>  #> Fixed terms:  #>                     Estimate Std_Error     z_value    p_value #> factor(species)1  0.07570783 0.3185077  0.23769543 0.81211733 #> factor(species)2 -0.02014888 0.3976341 -0.05067191 0.95958696 #> factor(species)3  0.22318277 0.2184716  1.02156419 0.30698721 #> factor(species)4  0.14728087 0.2705785  0.54431841 0.58622238 #> factor(species)5 -0.26514652 0.1463832 -1.81131833 0.07009159 Lrot_cf = rotate_pca( L_cf )$L_tf dimnames(Lrot_cf) = list( paste0(\"Var \", 1:nrow(Lrot_cf)),                        paste0(\"Factor \", 1:ncol(Lrot_cf)) ) knitr::kable( Lrot_cf,               digits=2, caption=\"Rotated true loadings\") # Extract and rotate estimated loadings Lhat_cf = matrix( 0, nrow=n_c, ncol=2 ) Lhat_cf[lower.tri(Lhat_cf,diag=TRUE)] = as.list(out$sdrep, what=\"Estimate\")$theta_z Lhat_cf = rotate_pca( L_tf=Lhat_cf, order=\"decreasing\" )$L_tf #> Warning in sqrt(Eigen$values): NaNs produced dimnames(Lhat_cf) = list( paste0(\"Var \", 1:nrow(Lhat_cf)),                        paste0(\"Factor \", 1:ncol(Lhat_cf)) ) knitr::kable( Lhat_cf,               digits=2, caption=\"Rotated estimated loadings\" ) # sem = \"   f1 -> 1, l1   f1 -> 2, l2   f1 -> 3, l3   f1 -> 4, l4   f1 -> 5, l5   f2 -> 2, l6   f2 -> 3, l7   f2 -> 4, l8   f2 -> 5, l9   f1 <-> f1, NA, 1   f2 <-> f2, NA, 1   1 <-> 1, sd_resid   2 <-> 2, sd_resid   3 <-> 3, sd_resid   4 <-> 4, sd_resid   5 <-> 5, sd_resid \"  # fit model out = tinyVAST( space_term = sem,            data = Data,            formula = n ~ 0 + factor(species),            spatial_domain = mesh,            family = list( \"obs\"=tweedie() ),            variables = c( \"f1\", \"f2\", 1:n_c ),            space_columns = c(\"x\",\"y\"),            variable_column = \"species\",            time_column = \"time\",            distribution_column = \"dist\",            control = tinyVASTcontrol(gmrf=\"proj\") )  # Extract and rotate estimated loadings Lhat_cf = matrix( 0, nrow=n_c, ncol=2 ) Lhat_cf[lower.tri(Lhat_cf,diag=TRUE)] = as.list(out$sdrep, what=\"Estimate\")$theta_z #> Warning in Lhat_cf[lower.tri(Lhat_cf, diag = TRUE)] = as.list(out$sdrep, : #> number of items to replace is not a multiple of replacement length Lhat_cf = rotate_pca( L_tf=Lhat_cf, order=\"decreasing\" )$L_tf #> Warning in sqrt(Eigen$values): NaNs produced dimnames(Lhat_cf) = list( paste0(\"Var \", 1:nrow(Lhat_cf)),                        paste0(\"Factor \", 1:ncol(Lhat_cf)) ) knitr::kable( Lhat_cf,               digits=2, caption=\"Rotated estimated loadings with full rank\" )"},{"path":"https://vast-lib.github.io/tinyVAST/articles/web_only/age_composition_expansion.html","id":"expanding-age-composition-data","dir":"Articles > Web_only","previous_headings":"","what":"Expanding age-composition data","title":"Age composition expansion","text":"start, load sampling data undergone first-stage expansion. arises primary sampling unit includes secondary subsampling ages, subsampled proportion--age primary unit expanded total abundance primary sample:","code":"data( bering_sea_pollock_ages )  # subset to Years 2017-2023 (to speed up the example) Data = subset( bering_sea_pollock_ages, Year >= 2017 )  # Add Year-_Age interaction Data$Age = factor( paste0(\"Age_\",Data$Age) ) Data$Year_Age = interaction( Data$Year, Data$Age )  # Project data to UTM Data = st_as_sf(    Data,    coords = c('Lon','Lat'),   crs = st_crs(4326)  ) Data = st_transform(    Data,    crs = st_crs(\"+proj=utm +zone=2 +units=km\")  )  # Add UTM coordinates as columns X & Y Data = cbind( st_drop_geometry(Data), st_coordinates(Data) )  # Make spatial domain mesh = fm_mesh_2d(    loc = Data[,c(\"X\",\"Y\")],   cutoff = 50  )"},{"path":"https://vast-lib.github.io/tinyVAST/articles/web_only/age_composition_expansion.html","id":"model-specification","dir":"Articles > Web_only","previous_headings":"Expanding age-composition data","what":"Model specification","title":"Age composition expansion","text":"Next, construct various inputs tinyVAST. specify separate variance spatial variation age, separate variance spatio-temporal variation age, shared magnitude AR1 correlations time. examples, analyst might want specify spatial spatio-temporal variance terms value shared among ages, ensure variances estimable:","code":"# adds different variances for each age sem = \"\"  # Constant AR1 spatio-temporal term across ages # and adds different variances for each age dsem = \"   Age_1 -> Age_1, 1, lag1   Age_2 -> Age_2, 1, lag1   Age_3 -> Age_3, 1, lag1   Age_4 -> Age_4, 1, lag1   Age_5 -> Age_5, 1, lag1   Age_6 -> Age_6, 1, lag1   Age_7 -> Age_7, 1, lag1   Age_8 -> Age_8, 1, lag1   Age_9 -> Age_9, 1, lag1   Age_10 -> Age_10, 1, lag1   Age_11 -> Age_11, 1, lag1   Age_12 -> Age_12, 1, lag1   Age_13 -> Age_13, 1, lag1   Age_14 -> Age_14, 1, lag1   Age_15 -> Age_15, 1, lag1 \"  # Separate intercept for each Year-Age combination Formula = Abundance_per_hectare ~ 0 + Year_Age  #  control = tinyVASTcontrol( getsd = FALSE,                            profile = c(\"alpha_j\"),                              trace = 0 )"},{"path":"https://vast-lib.github.io/tinyVAST/articles/web_only/age_composition_expansion.html","id":"fitting-the-model","dir":"Articles > Web_only","previous_headings":"Expanding age-composition data","what":"Fitting the model","title":"Age composition expansion","text":"fit model log-linked Tweedie distribution single linear predictor:","code":"# Define separate tweedie family for each age Family = list(   Age_1 = tweedie(),   Age_2 = tweedie(),   Age_3 = tweedie(),   Age_4 = tweedie(),   Age_5 = tweedie(),    Age_6 = tweedie(),   Age_7 = tweedie(),   Age_8 = tweedie(),   Age_9 = tweedie(),   Age_10 = tweedie(),   Age_11 = tweedie(),   Age_12 = tweedie(),   Age_13 = tweedie(),   Age_14 = tweedie(),   Age_15 = tweedie()      )  # Fit model myfit = tinyVAST(   data = Data,   formula = Formula,   space_term = sem,   spacetime_term = dsem,   family = Family,   space_column = c(\"X\", \"Y\"),    variable_column = \"Age\",   time_column = \"Year\",   distribution_column = \"Age\",   spatial_domain = mesh,   control = control )"},{"path":"https://vast-lib.github.io/tinyVAST/articles/web_only/age_composition_expansion.html","id":"area-expansion-and-proportions","dir":"Articles > Web_only","previous_headings":"Expanding age-composition data","what":"Area expansion and proportions","title":"Age composition expansion","text":"model fitted, apply area-expansion predict abundance--age, convert proportion. , forgo epsilon bias-correction (Thorson Kristensen 2016), strongly recommend real-world applications avoid proportion estimates biased low ages fewer samples (therefore higher standard errors):","code":"# Get shapefile for survey extent data( bering_sea )  # Make extrapolation grid based on shapefile bering_sea = st_transform( bering_sea,                             st_crs(\"+proj=utm +zone=2 +units=km\") ) grid = st_make_grid( bering_sea, n=c(50,50) ) grid = st_intersection( grid, bering_sea ) grid = st_make_valid( grid ) loc_gz = st_coordinates(st_centroid( grid ))  # Get area for extrapolation grid library(units) areas = set_units(st_area(grid), \"hectares\") #  / 100^2 # Hectares  # Get abundance N_jz = expand.grid( Age=myfit$internal$variables, Year=sort(unique(Data$Year)) ) N_jz = cbind( N_jz, \"Biomass\"=NA, \"SE\"=NA ) for( j in seq_len(nrow(N_jz)) ){   if( N_jz[j,'Age']==1 ){     message( \"Integrating \", N_jz[j,'Year'], \" \", N_jz[j,'Age'], \": \", Sys.time() )   }   if( is.na(N_jz[j,'Biomass']) ){     newdata = data.frame( loc_gz, Year=N_jz[j,'Year'], Age=N_jz[j,'Age'])       newdata$Year_Age = paste( newdata$Year, newdata$Age, sep=\".\" )     # Area-expansion     index1 = integrate_output( myfit,                     area = areas,                     newdata = newdata,                     apply.epsilon = FALSE,                     bias.correct = FALSE,                     intern = FALSE,                     getsd = FALSE )     #N_jz[j,'Biomass'] = index1[3] / 1e9     N_jz[j,'Biomass'] = index1[1] / 1e9   } } N_ct = array( N_jz$Biomass, dim=c(length(myfit$internal$variables),length(unique(Data$Year))),               dimnames=list(myfit$internal$variables,sort(unique(Data$Year))) ) N_ct = N_ct / outer( rep(1,nrow(N_ct)), colSums(N_ct) )"},{"path":"https://vast-lib.github.io/tinyVAST/articles/web_only/age_composition_expansion.html","id":"comparison-with-vast","dir":"Articles > Web_only","previous_headings":"Expanding age-composition data","what":"Comparison with VAST","title":"Age composition expansion","text":"Finally, can compare estimates package VAST (Thorson Barnett 2017). Estimates differ somewhat VAST used delta-gamma distribution spatio-temporal variation two linear predictors, used different mesh, also skipped epsilon bias-correction tinyVAST faster-running vignette.  Runtime vignette: 21.34 mins","code":"# Load VAST results for same data data(bering_sea_pollock_vast) myvast = bering_sea_pollock_vast rownames(myvast) = 1:15  # Reformat tinyVAST output with same dimnames mytiny = N_ct rownames(mytiny) = 1:15  # Combine in long-form data frame (expected by ggplot) longvast = cbind(    expand.grid(dimnames(myvast)),    p = as.numeric(myvast),    method = \"VAST\" ) longtiny = cbind(    expand.grid(dimnames(mytiny)),    p = as.numeric(mytiny),    method = \"tinyVAST\" ) long = rbind( longvast, longtiny )  # Plot with facet by age library(ggplot2) ggplot( data=long, aes(x=Var2, y=p, col=method) ) +   facet_grid( rows=vars(Var1), scales=\"free\" ) +   geom_point( ) +   scale_y_log10()"},{"path":[]},{"path":"https://vast-lib.github.io/tinyVAST/articles/web_only/condition.html","id":"data-format","dir":"Articles > Web_only","previous_headings":"","what":"Data format","title":"Condition and density","text":"first load combine two data sets: construct SPDE mesh Next, specify spatial spatio-temporal variance condition density. Finally, define distribution data set using family argument: Finally, fit model using tinyVAST can look structural parameters using summary functions:","code":"data( condition_and_density )  # Combine both parts combo_data = plyr::rbind.fill( condition_and_density$condition,                                condition_and_density$density )  # Reformat data in expected format formed_data = cbind( combo_data[,c(\"Year\",\"Lat\",\"Lon\")],   \"Type\" = factor(ifelse( is.na(combo_data[,'Individual_length_cm']),                     \"Biomass\", \"Condition\" )),   \"Response\" = ifelse( is.na(combo_data[,'Individual_length_cm']),                          combo_data[,'Sample_biomass_KGperHectare'],                          log(combo_data[,'Individual_weight_Grams']) ),   \"log_length\" = ifelse( is.na(combo_data[,'Individual_length_cm']),                          rep(0,nrow(combo_data)),                          log(combo_data[,'Individual_length_cm'] / 10) ))  # #formed_data$Year_Type = paste0( formed_data$Year, \"_\", formed_data$Type ) # make mesh mesh = fm_mesh_2d( formed_data[,c('Lon','Lat')], cutoff=1 ) # sem = \"   Biomass <-> Biomass, sdB   Condition <-> Condition, sdC   Biomass -> Condition, dens_dep \"  # dsem = \"   Biomass <-> Biomass, 0, sdB   Condition <-> Condition, 0, sdC   Biomass -> Condition, 0, dens_dep \" # Family = list(   Biomass = tweedie(),   Condition = gaussian() ) # fit model fit = tinyVAST( data = formed_data,            formula = Response ~ interaction(Year,Type) + log_length,            spatial_domain = mesh,            control = tinyVASTcontrol( trace=0, verbose=TRUE, profile=\"alpha_j\" ),            space_term = sem,            spacetime_term = dsem,            family = Family,            variables = c(\"Biomass\",\"Condition\"),            variable_column = \"Type\",            space_columns = c(\"Lon\", \"Lat\"),            time_column = \"Year\",            distribution_column = \"Type\",            times = 1982:2016 ) # spatial terms summary(fit, \"space_term\") #>   heads        to      from parameter start      Estimate   Std_Error #> 1     2   Biomass   Biomass         1  <NA>  1.423876e+00 0.133046671 #> 2     2 Condition Condition         2  <NA> -3.316262e-02 0.004167543 #> 3     1 Condition   Biomass         3  <NA>  9.299743e-05 0.004855080 #>       z_value      p_value #> 1 10.70208236 9.951629e-27 #> 2 -7.95735440 1.757567e-15 #> 3  0.01915466 9.847177e-01  # spatio-temporal terms summary(fit, \"spacetime_term\") #>   heads        to      from parameter start lag     Estimate   Std_Error #> 1     2   Biomass   Biomass         1  <NA>   0  0.966427330 0.024274882 #> 2     2 Condition Condition         2  <NA>   0 -0.040541844 0.002723399 #> 3     1 Condition   Biomass         3  <NA>   0  0.008201954 0.003339312 #>      z_value      p_value #> 1  39.811824 0.000000e+00 #> 2 -14.886490 4.034007e-50 #> 3   2.456181 1.404224e-02"},{"path":"https://vast-lib.github.io/tinyVAST/articles/web_only/condition.html","id":"abundance-weighted-expansion","dir":"Articles > Web_only","previous_headings":"","what":"Abundance-weighted expansion","title":"Condition and density","text":"explore output, can plot output using survey extent:","code":"# Extract shapefile region = condition_and_density$eastern_bering_sea  # make extrapolation-grid sf_grid = st_make_grid( region, cellsize=c(0.2,0.2) ) sf_grid = st_intersection( sf_grid, region ) sf_grid = st_make_valid( sf_grid ) n_g = length(sf_grid)  # grid_coords = st_coordinates( st_centroid(sf_grid) ) areas_km2 = st_area( sf_grid ) / 1e6  # Condition in  newdata = data.frame( \"Lat\" = grid_coords[,'Y'],                        \"Lon\" = grid_coords[,'X'],                       \"Year\" = 1982,                       \"Type\" = \"Condition\",                       #\"Year_Type\" = \"1982_Condition\",                       \"log_length\" = 0 )  # Average log-length across years cond_1982 = predict(fit, newdata=newdata, what=\"p_g\")  # Repeat for density newdata2 = newdata newdata2$Type = \"Biomass\" #newdata2$Year_Type = \"1982_Biomass\" dens_1982 = predict(fit, newdata=newdata2, what=\"p_g\")  # Plot on map plot_grid = st_sf( sf_grid,                      \"Condition.1982\" = cond_1982,                     \"Density.1982\" = dens_1982 )  plot( plot_grid, border=NA )"},{"path":"https://vast-lib.github.io/tinyVAST/articles/web_only/condition.html","id":"density-weighted-condition","dir":"Articles > Web_only","previous_headings":"","what":"Density-weighted condition","title":"Condition and density","text":"Finally, can calculate density-weighted condition, using local numerical density weighting term averaging across model domain. Condition units mass per allometric-length model estimating allometric weight-length relationship jointly condition. Therefore, condition units directly comparable either weight density.  Runtime vignette: 5.91 mins","code":"#  expand_data = rbind( newdata2, newdata )  # cond_tz = data.frame( \"Year\"=1998:2016, \"Est\"=NA, \"SE\"=NA ) for( yearI in seq_len(nrow(cond_tz)) ){   expand_data[,'Year'] = cond_tz[yearI,\"Year\"]   out = integrate_output( fit,                            newdata = expand_data,                           area = c(as.numeric(areas_km2),rep(0,n_g)),                           type = rep(c(0,3),each=n_g),                           weighting_index = c( rep(0,n_g), seq_along(areas_km2)-1 ),                           bias.correct = TRUE )    cond_tz[yearI,c(\"Est\",\"SE\")] = out[c(\"Estimate\",\"Std. Error\")] }  # plot time-series ggplot( cond_tz ) +   geom_line( aes(x=Year, y=Est) ) +   geom_ribbon( aes(x=Year, ymin=Est-SE, ymax=Est+SE), alpha=0.2 )"},{"path":[]},{"path":"https://vast-lib.github.io/tinyVAST/articles/web_only/empirical_orthogonal_functions.html","id":"empirical-orthogonal-function-eof-analysis","dir":"Articles > Web_only","previous_headings":"","what":"Empirical Orthogonal Function (EOF) analysis","title":"Empirical orthogonal functions","text":"start, reformat data September Sea ice concentrations: Next, construct various inputs tinyVAST Finally, can extract, rotate, plot dominant modes variability associated spatial responses:  Runtime vignette: 3.78 mins","code":"data( sea_ice ) library(sf) library(rnaturalearth)  # project data sf_ice = st_as_sf( sea_ice, coords = c(\"lon\",\"lat\") ) st_crs(sf_ice) = \"+proj=longlat +datum=WGS84\" sf_ice = st_transform( sf_ice,                       crs=st_crs(\"+proj=laea +lat_0=90 +lon_0=-30 +units=km\") )  # sf_pole = st_point( c(0,90) ) sf_pole = st_sfc( sf_pole, crs=\"+proj=longlat +datum=WGS84\" ) sf_pole = st_transform( sf_pole, crs=st_crs(sf_ice) ) sf_pole = st_buffer( sf_pole, dist=3000 ) sf_ice = st_intersection( sf_ice, sf_pole )  Data = data.frame( st_drop_geometry(sf_ice),               st_coordinates(sf_ice),               var = \"Ice\" ) n_eof = 2 dsem = make_eof_ram( variables = \"Ice\",                      times = sort(unique(Data[,'year'])),                      n_eof = 2,                      standard_deviations = 0 ) mesh = fm_mesh_2d( Data[,c('X','Y')], cutoff=1.5 )  # fit model out = tinyVAST( spacetime_term = dsem,            space_term = \"\",            data = as.data.frame(Data),            formula = ice_concentration ~ 1,            spatial_domain = mesh,            space_column = c(\"X\",\"Y\"),            variable_column = \"var\",            time_column = \"year\",            distribution_column = \"dist\",            times = c(paste0(\"EOF_\",seq_len(n_eof)), sort(unique(Data[,'year']))),            control = tinyVASTcontrol( profile=\"alpha_j\",                                       gmrf_parameterization=\"projection\") ) #> Warning in tinyVAST(spacetime_term = dsem, space_term = \"\", data = #> as.data.frame(Data), : `spatial_domain` has over 1000 components, so the model #> may be extremely slow # Country shapefiles for plotting sf_maps = ne_countries( return=\"sf\", scale=\"medium\", continent=c(\"north america\",\"europe\",\"asia\") ) sf_maps = st_transform( sf_maps, crs=st_crs(sf_ice) ) sf_maps = st_union( sf_maps )  # Shapefile for water sf_water = st_difference( st_as_sfc(st_bbox(sf_maps)), sf_maps )  # Create extrapolation grid cellsize = 50 sf_grid = st_make_grid( sf_pole, cellsize=cellsize ) # Restrict to water grid_i = st_intersects( sf_water, sf_grid ) sf_grid = sf_grid[ unique(unlist(grid_i)) ] # Restrict to 3000 km from North Pole grid_i = st_intersects( sf_pole, sf_grid ) sf_grid = sf_grid[ unique(unlist(grid_i)) ]  # newdata = data.frame( st_coordinates(st_centroid(sf_grid)),                       var = \"Ice\" )  # Extract loadings L_tf = matrix( 0, nrow=length(unique(Data$year)), ncol=2,                dimnames=list(unique(Data$year),c(\"EOF_1\",\"EOF_2\")) ) L_tf[lower.tri(L_tf,diag=TRUE)] = out$opt$par[names(out$opt$par)==\"beta_z\"]  # Extract factor-responses EOF1_g = predict( out, cbind(newdata, year=\"EOF_1\"), what=\"pepsilon1_g\" ) EOF2_g = predict( out, cbind(newdata, year=\"EOF_2\"), what=\"pepsilon1_g\" ) omega_g = predict( out, cbind(newdata, year=\"EOF_2\"), what=\"pomega1_g\" )  # Rotate responses and loadings rotated_results = rotate_pca( L_tf=L_tf, x_sf=cbind(EOF1_g,EOF2_g), order=\"decreasing\" ) #> Warning in sqrt(Eigen$values): NaNs produced EOF1_g = rotated_results$x_sf[,1] EOF2_g = rotated_results$x_sf[,2] L_tf = rotated_results$L_tf  # Plot on map sf_plot = st_sf( sf_grid, \"EOF1_g\"=EOF1_g, \"EOF2_g\"=EOF2_g, \"omega_g\"=omega_g ) par(mfrow=c(2,2), oma=c(2,2,0,0) ) plot( sf_plot[,'EOF1_g'], reset=FALSE, key.pos=NULL, border=NA )   plot( st_geometry(sf_maps), add=TRUE, border=NA, col=\"grey\" ) plot( sf_plot[,'EOF2_g'], reset=FALSE, key.pos=NULL, border=NA )   plot( st_geometry(sf_maps), add=TRUE, border=NA, col=\"grey\" ) plot( sf_plot[,'omega_g'], reset=FALSE, key.pos=NULL, border=NA )   plot( st_geometry(sf_maps), add=TRUE, border=NA, col=\"grey\" ) matplot( y=L_tf, x=unique(Data$year), type=\"l\",          col=viridisLite::viridis(n_eof), lwd=2, lty=\"solid\" )   legend( \"top\", ncol=n_eof, legend=paste0(\"EOF\",1:n_eof),           fill=viridisLite::viridis(n_eof) )"},{"path":[]},{"path":"https://vast-lib.github.io/tinyVAST/articles/web_only/overview.html","id":"background-materials","dir":"Articles > Web_only","previous_headings":"","what":"Background materials:","title":"Overview of vignettes","text":"tinyVAST Model description: Describes equations notation Comparison mgcv: Shows tinyVAST smoothers (approximately) identical using package mgcv, despite replacing generalized additive model wiggliness parameter mixed-effects variance parameter (.e., replacing * Spatial modeling: Shows fit simple spatial model, including covariates, visualize model output, deviance explained, diagnostics; Spatial models Multiple data types: Shows integrate data following different distributions, case showing presence/absence, count, biomass samples red snapper; Dynamic structural equation models: Shows tinyVAST can reduced time-series model simultaneous lagged effects (e.g., vector autoregressive model)","code":""},{"path":"https://vast-lib.github.io/tinyVAST/articles/web_only/overview.html","id":"alternative-spatial-domains","dir":"Articles > Web_only","previous_headings":"","what":"Alternative spatial domains","title":"Overview of vignettes","text":"Simulatenous autoregressive process: Shows use areal spatial domain (simultaneous autoregressive SAR process) instead two-dimensional smoother; Stream network models: Shows use stream network spatial domain (.e., Ornstein-Uhlenbeck process flow-unconnected sites acyclic graph);","code":""},{"path":"https://vast-lib.github.io/tinyVAST/articles/web_only/overview.html","id":"multivariate-spatio-temporal-models","dir":"Articles > Web_only","previous_headings":"","what":"Multivariate spatio-temporal models","title":"Overview of vignettes","text":"Age composition expansion: Shows fit multivariate spatio-temporal model standardize age composition data; Condition density: Shows jointly analyze different types data combined single estimator. case, use joint analysis numerical density animal condition calculate per-capita average condition Empirical orthogonal functions: Shows fit empirical orthogonal function (EOF) analysis, .e., model spatio-temporal variation product one time-series, associated spatial response map additive penalty generalized additive model log-determinant Hessian approximated marginal likelihood) Spatial factor analysis: Shows specify spatial factors represent covariance among multiple variables, including identifiability requirement post-hoc rotation estimated loadings; Vector autoregressive spatio-temporal: Shows fit simple (two-variable) spatial version vector autoregressive model.","code":""},{"path":[]},{"path":"https://vast-lib.github.io/tinyVAST/articles/web_only/probabilistic_forecasts.html","id":"probabilistic-forecasts-with-spatio-temporal-models","dir":"Articles > Web_only","previous_headings":"","what":"Probabilistic forecasts with spatio-temporal models","title":"Probabilistic forecasts","text":"developed new approaches forecasting spatio-temporal species distribution models (SDMs) generate efficient predictions, also separate quantify different sources prediction uncertainty (GrÃ¼ss et al. n.d.). models, uncertainty can arise : * Past process errors â€” randomness estimated random effects represent past temporal, spatial, spatio-temporal variation. * Future process errors â€” uncertainty random effects evolve future. * Parameter uncertainty â€” variability estimated fixed effects, turn affect structure spatio-temporal random fields. sources uncertainty can propagated function project, includes three key arguments: past_var, future_var, parm_var. * past_var logical argument indicates whether re-simulate past process errors predictive distribution random effects, thus changing boundary conditions forecasts. * future_var logical argument indicates whether simulate future process errors Gaussian Markov Random Fields (GMRFs) just compute predictive mean. * parm_var logical argument indicates whether re-sample fixed effects predictive distribution, thus changing GMRFs future process errors. , demonstrate one approaches, â€œprocess error resampling approachâ€, using fisheries-independent survey data Bering Sea capelin (Mallotus villosus) generating forecasts next century. Bering Sea capelin, first fit delta-Gamma model biomass catch rate data use fitted model forecast index relative biomass next century.","code":""},{"path":"https://vast-lib.github.io/tinyVAST/articles/web_only/probabilistic_forecasts.html","id":"load-data-and-define-mesh","dir":"Articles > Web_only","previous_headings":"Probabilistic forecasts with spatio-temporal models","what":"Load data and define mesh","title":"Probabilistic forecasts","text":"","code":"# Load data data( bering_sea_capelin_forecasts ) Data <- bering_sea_capelin_forecasts$Data  Data$var <- \"capelin\"  # Make mess mesh <- fm_mesh_2d( Data[,c(\"Lon\",\"Lat\")], cutoff = 1 )"},{"path":"https://vast-lib.github.io/tinyVAST/articles/web_only/probabilistic_forecasts.html","id":"define-autoregressive-structure","dir":"Articles > Web_only","previous_headings":"Probabilistic forecasts with spatio-temporal models","what":"Define autoregressive structure","title":"Probabilistic forecasts","text":"next define autoregressive structure allow hotspots propagated forward time. Bering Sea capelin application , preliminary analyses determined spatio-temporal variation modelled AR1 process linear predictors spatio-temporal SDMs. However, dynamics instead fitted forecasted using single linear predictor using Tweedie distribution.","code":"# Define spatial variation space_term <- \"   capelin <-> capelin, sd_space \"  # Define temporal and spatio-temporal variation based on the outcomes of preliminary analyses time_term <- \"   capelin <-> capelin, 0, IID_sd \" spacetime_term <- \"   capelin <-> capelin, 0, sd_spacetime   capelin -> capelin, 1, ar1_spacetime \""},{"path":"https://vast-lib.github.io/tinyVAST/articles/web_only/probabilistic_forecasts.html","id":"fit-model","dir":"Articles > Web_only","previous_headings":"Probabilistic forecasts with spatio-temporal models","what":"Fit model","title":"Probabilistic forecasts","text":"Finally, fit model","code":"# Fit the model (turning off use_anisotropy to save time) fit <- tinyVAST(   formula = Wt ~ 1 + sst_anomaly + offset(log(AreaSwept_km2)),   data = Data,   space_term = space_term,   spacetime_term = spacetime_term,   time_term = time_term,   family = delta_gamma( type = \"poisson-link\" ),   delta_options = list(     formula = ~ 1,     space_term = space_term,     spacetime_term = spacetime_term,     time_term = time_term   ),   spatial_domain = mesh,   control = tinyVASTcontrol(     use_anisotropy = FALSE   ),   space_columns = c(\"Lon\",\"Lat\"),   time_column = \"Year\",   variable_column = \"var\",   variables = \"capelin\",   spatial_varying = ~ 0 + sst_anomaly,   times = min(Data$Year):max(Data$Year) )"},{"path":"https://vast-lib.github.io/tinyVAST/articles/web_only/probabilistic_forecasts.html","id":"projections-and-forecasts","dir":"Articles > Web_only","previous_headings":"Probabilistic forecasts with spatio-temporal models","what":"Projections and forecasts","title":"Probabilistic forecasts","text":"process error resampling approach involves three steps. * Step 1 consists estimating uncertainty random effects temporal, spatial /spatio-temporal variation using precision (inner Hessian) matrix random effects, conditional upon maximum-likelihood estimates fixed effects; * Step 2 consists resampling temporal, spatial /spatio-temporal variation random effects estimated distribution produce parameter draws. * Step 3 consists sampling values random effects forecast period conditional distribution, starting resampled value random effects recent year data initial condition, using conditional krigging formula. implement process error resampling approach, following settings needed function project: past_var = TRUE, future_var = TRUE, parm_var = FALSE. can plot inspect predictive interval, confirm bridges uncertainty short-term forecasts long-term projections","code":"# Generate projections  # (using 50 candidate parameter draws to speed up vignette) New_Data <- bering_sea_capelin_forecasts$New_Data projected_index <- numeric(0) for( rI in 1:50 ){    message( Sys.time(), \": starting \", rI )   proj = project(     object = fit,     newdata = New_Data,     extra_times = (max(Data$Year)+1):max(New_Data$Year),     past_var = TRUE,     future_var = TRUE,     parm_var = FALSE   )   index_t = tapply( proj, INDEX = New_Data$Year, FUN = sum )   projected_index = cbind( projected_index, index_t ) } # Plot the projected index of relative biomass Y_tq <- t( apply( projected_index, MARGIN = 1, FUN = quantile,                    probs = c( 0.1, 0.5, 0.9 ) ) ) colnames(Y_tq) = c(\"lower\", \"abundance\", \"upper\") DF = data.frame( Year = as.numeric(rownames(Y_tq)), Y_tq )  ggplot( DF, aes(x=Year) ) +    geom_point( aes(y=abundance) ) +    geom_errorbar( aes(ymax=upper, ymin = lower) ) +    scale_y_log10()"},{"path":"https://vast-lib.github.io/tinyVAST/articles/web_only/probabilistic_forecasts.html","id":"alternative-options","dir":"Articles > Web_only","previous_headings":"Probabilistic forecasts with spatio-temporal models","what":"Alternative options","title":"Probabilistic forecasts","text":"Another approach forecasting spatio-temporal SDMs developed â€œconditional approach.â€ conditional approach implements Step 3 process error resampling approach, conditions samples random effects forecast period using initial conditions empirical Bayes predictions random effects recent year data. implement conditional approach, following settings needed function project: past_var = FALSE, future_var = TRUE, parm_var = FALSE. also developed approach forecasting spatio-temporal SDMs called â€œmixed effects resampling approach,â€ considers uncertainty fixed random effects generating forecasts, using joint precision matrix. mixed effects resampling approach: 1. assumes collection fixed random effect parameters spatio-temporal SDM can described multivariate normal (MVN) distribution mean values equal maximum likelihood estimates variability defined covariance dependency matrix; 2. samples MVN distribution produce forecasts. However, preliminary analyses revealed mixed effects resampling approach work fish populations, others; brief, mixed effects resampling approach works well variances relatively low, poorly fish populations variances high likely non-normal. implement mixed effects resampling approach, following settings needed function project: past_var = TRUE, future_var = TRUE, parm_var = TRUE. One important consideration generating forecasts spatio-temporal SDMs autoregressive structures temporal spatio-temporal variation: Regarding temporal variation, analysts may prefer model temporal variation first first-order autoregressive (AR1) process , estimated degree autocorrelation temporal variation approaches one, random walk (RW) process. modelling temporal variation AR1 RW process proves unwarranted (e.g., variance temporal variation approaches zero), can instead modelled (1) independent identically distributed (IID) random effect, sets variance temporal variation zero, , last resort, (1) constant, fixed effect, sets estimated degree autocorrelation temporal variation variance temporal variation zero. Preliminary analyses needed identify best autoregressive structures temporal variation, allowing model estimation/convergence sensible future predictions. Bering Sea capelin application , preliminary analyses determined temporal variation modelled random IID effect linear predictors spatio-temporal SDMs. Regarding spatio-temporal variation, analysts may model spatio-temporal variation AR1 process, RW process, IID random effect. However, analysts may prefer model spatio-temporal variation AR1 process rather RW process, latter results spatio-temporal variation term variance across space increases progressively forecast period. , spatio-temporal variation extrapolated calculate densities, forecasted indices relative abundance progressively dominated predicted density (single) extrapolation location(s). Runtime vignette: 7.78 mins","code":""},{"path":[]},{"path":"https://vast-lib.github.io/tinyVAST/articles/web_only/simultaneous_autoregressive_process.html","id":"load-and-format-data","dir":"Articles > Web_only","previous_headings":"","what":"Load and format data","title":"Simultaneous autoregressive process","text":", first load salmong returns, remove 0s allow comparison Tweedie lognormal distributions.","code":"data( salmon_returns )  # Transform data salmon_returns$Biomass_nozeros = ifelse( salmon_returns$Biomass==0,                                          NA, salmon_returns$Biomass ) Data = na.omit(salmon_returns)"},{"path":[]},{"path":"https://vast-lib.github.io/tinyVAST/articles/web_only/simultaneous_autoregressive_process.html","id":"independent-dynamics-among-populations","dir":"Articles > Web_only","previous_headings":"Analysis","what":"Independent dynamics among populations","title":"Simultaneous autoregressive process","text":"first explore AR2 process, independent variation among regions. model shows substantial first-order autocorrelation sockeye chum, substantial second-order autocorrelation pink salmon. AR(2) process stationary Ï•1+Ï•2<1\\phi_1 + \\phi_2 < 1 Ï•2âˆ’Ï•1<1\\phi_2 - \\phi_1 < 1, stationarity criterion suggests time-series close (quite) nonstationary.","code":"# Define graph for SAR process unconnected_graph = make_empty_graph( nlevels(Data$Region) ) V(unconnected_graph)$name = levels(Data$Region) plot(unconnected_graph) # Define SEM for AR2 process dsem = \"   sockeye -> sockeye, -1, lag1_sockeye   sockeye -> sockeye, -2, lag2_sockeye    pink -> pink, -1, lag1_pink   pink -> pink, -2, lag2_pink    chum -> chum, -1, lag1_chum   chum -> chum, -2, lag2_chum \"  # Fit tinyVAST model mytiny0 = tinyVAST(      formula = Biomass_nozeros ~ 0 + Species + Region,      data = Data,      spacetime_term = dsem,      variable_column = \"Species\",      time_column = \"Year\",      space_column = \"Region\",      distribution_column = \"Species\",      family = list( \"chum\" = lognormal(),                           \"pink\" = lognormal(),                           \"sockeye\" = lognormal() ),      spatial_domain = unconnected_graph,      control = tinyVASTcontrol( profile=\"alpha_j\" ) )  # Summarize output Summary = summary(mytiny0, what=\"spacetime_term\") knitr::kable( Summary, digits=3)"},{"path":"https://vast-lib.github.io/tinyVAST/articles/web_only/simultaneous_autoregressive_process.html","id":"spatially-correlated-dynamics-among-populations","dir":"Articles > Web_only","previous_headings":"Analysis","what":"Spatially correlated dynamics among populations","title":"Simultaneous autoregressive process","text":"also explore SAR process adjacency among regions can plot adjacency map emphasize simple way encode information spatial proximity:  can pass adjacency graph tinyVAST fitting:","code":"# Define graph for SAR process adjacency_graph = make_graph( ~ Korea - Japan - M.I - WKam - EKam -                                 WAK - SPen - Kod - CI - PWS -                                 SEAK - NBC - SBC - WA ) #maps = ne_countries( country = c(\"united states of america\",\"russia\",\"canada\",\"south korea\",\"north korea\",\"japan\") ) maps = ne_countries( continent = c(\"north america\",\"asia\",\"europe\") ) maps = st_combine( maps ) maps = st_transform( maps, crs=st_crs(3832) ) #maps = st_crop( maps, xmin = -5*1e5, xmax = 12*1e5, #                      ymin = 0 * 1e6, ymax=10 * 1e6 )  # Format inputs loc_xy = cbind(   x = c(129,143,140,156,163,-163,-161,-154,-154,-147,-138,-129,-126,-125),   y = c(36,40,57,53,57,60,55,56,59,61,57,54,50,45) ) loc_xy = sf_project( loc_xy, from=st_crs(4326), to=st_crs(3832) )  # Plot xlim = c(-4,10) * 1e6 ylim = c(3,10) * 1e6 plot( maps,        xlim = xlim,       ylim = ylim,       col = \"grey\",       asp = FALSE,       add = FALSE ) plot( adjacency_graph,        layout = loc_xy,       add = TRUE,        rescale = FALSE,       vertex.label.color = \"red\",       xlim = xlim,        ylim = ylim,        edge.width = 2,       edge.color = \"red\" ) # Fit tinyVAST model mytiny = tinyVAST(      formula = Biomass_nozeros ~ 0 + Species + Region,      data = Data,      spacetime_term = dsem,      variable_column = \"Species\",      time_column = \"Year\",      space_column = \"Region\",      distribution_column = \"Species\",      family = list( \"chum\" = lognormal(),                           \"pink\" = lognormal(),                           \"sockeye\" = lognormal() ),      spatial_domain = adjacency_graph,      control = tinyVASTcontrol( profile=\"alpha_j\" ) )  # Summarize output Summary = summary(mytiny, what=\"spacetime_term\") knitr::kable( Summary, digits=3)"},{"path":"https://vast-lib.github.io/tinyVAST/articles/web_only/simultaneous_autoregressive_process.html","id":"model-selection-and-visualization","dir":"Articles > Web_only","previous_headings":"Analysis","what":"Model selection and visualization","title":"Simultaneous autoregressive process","text":"can use AIC compare two models. comparison suggests spatial adjancency parsimonious way describe correlations among time-series. Finally, can plot observations predictions selected model  Runtime vignette: 8.76 secs","code":"# AIC for unconnected time-series AIC(mytiny0) #> [1] 49086.47 # AIC for SAR spatial variation AIC(mytiny) #> [1] 49755.91 # Compile long-form dataframe of observations and predictions Resid = rbind( cbind(Data[,c('Species','Year','Region','Biomass_nozeros')], \"Which\"=\"Obs\"),                cbind(Data[,c('Species','Year','Region')], \"Biomass_nozeros\"=predict(mytiny0,Data), \"Which\"=\"Pred\") )  # plot using ggplot library(ggplot2) ggplot( data=Resid, aes(x=Year, y=Biomass_nozeros, col=Which) ) + # , group=yhat.id   geom_line() +   facet_grid( rows=vars(Region), cols=vars(Species), scales=\"free\" ) +   scale_y_continuous(trans='log')  #"},{"path":[]},{"path":"https://vast-lib.github.io/tinyVAST/articles/web_only/spatial_structural_model.html","id":"load-data","dir":"Articles > Web_only","previous_headings":"","what":"Load data","title":"Spatial structural models","text":"","code":"# Load data data(alaska_sponge_coral_fish) combined_samples = alaska_sponge_coral_fish$combined_samples  # Define the spatial mesh mesh = fm_mesh_2d(    loc = combined_samples[,c('X','Y')],   cutoff = 10 # Value from original paper   #cutoff = 25 # Lower resolution to speed up vignette )"},{"path":"https://vast-lib.github.io/tinyVAST/articles/web_only/spatial_structural_model.html","id":"fit-model","dir":"Articles > Web_only","previous_headings":"","what":"Fit model","title":"Spatial structural models","text":"define separate intercept group year, log-area offset also specify AIC-selected structural model original paper, includes habitat-effects camera-measured coral sponge densities camera-measured fish densities, separate habitat-effects coral/sponge trawl-measured fish densities, proportional variation fish density camera trawl measurements. also estimate separate measurement-error parameters six variables run model without standard errors speed vignette:","code":"# Define formula Formula = Count ~ 0 + interaction(Group4,Year) + offset(log(AreaSwept)) # Define arrow-and-lag notation space_term = \"   # Habitat effects on drop-camera measurements   Coral -> Flat, b1   Sponge -> Flat, b2   Coral -> Rock, b3   Sponge -> Rock, b4      # Habitat effects on trawl measurements   Coral -> Flat_trawl, d1   Sponge -> Flat_trawl, d2   Coral -> Rock_trawl, d3   Sponge -> Rock_trawl, d4    # Fix these at 1    # (Proportional change in density between gears)   Flat -> Flat_trawl, NA, 1   Rock -> Rock_trawl, NA, 1 \" # Specify distribution for each variable Family = list(   Coral = tweedie(),   Sponge = tweedie(),   Rock = tweedie(),   Flat = tweedie(),   Rock_trawl = tweedie(),   Flat_trawl = tweedie() ) # Specify estimation settings control = tinyVASTcontrol(    profile = c(\"alpha_j\"),   getsd = FALSE # To speed up vignette )  # Fit model myfit = tinyVAST(   data = combined_samples,   formula = Formula,   space_term = space_term,   family = Family,   space_columns = c(\"X\", \"Y\"),   variable_column = \"Group4\",   variables = c(\"Coral\", \"Sponge\", \"Rock\", \"Flat\", \"Rock_trawl\", \"Flat_trawl\"),   distribution_column = \"Group4\",   spatial_domain = mesh,   control = control )"},{"path":"https://vast-lib.github.io/tinyVAST/articles/web_only/spatial_structural_model.html","id":"visualize-structural-linkages","dir":"Articles > Web_only","previous_headings":"","what":"Visualize structural linkages","title":"Spatial structural models","text":"Finally, use igraph allow detailed control plotting estimated structural linkages among variables:  Runtime vignette: 7.16 mins","code":"# Function to relabel variables Switch = function(x){   switch( x, \"Coral\"=\"C\", \"Sponge\"=\"S\", \"Rock\"=\"R\",            \"Flat\"=\"F\", \"Rock_trawl\"=\"R2\", \"Flat_trawl\"=\"F2\" ) }  # Extract objects out = summary( myfit ) variables = as.character(myfit$internal$variables) var_labels = sapply( variables, FUN=Switch ) label = round(out$Estimate,2)  # Define location for plotting variables layout = cbind(    x=c(2,2,1,3,1,3),    y=c(2,3,1,1,4,4) ) rownames(layout) = c( \"Coral\", \"Sponge\", \"Rock\",                        \"Flat\", \"Rock_trawl\", \"Flat_trawl\" )  # Define locations for plotting arrows df <- data.frame(   from = sapply(out$from,FUN=Switch),   to = sapply(out$to,FUN=Switch),   label = label,   x = NA,   y = NA )  # Only show one-headed arrows df = subset( df, from!=to )  # Define location for labels of one-headed arrows df$x = c( 0.5, 0.5, -0.5, -0.5, 0.5, 0.5, -0.5, -0.5, 1, -1 ) df$y = c( -0.66, -0.22, -0.66, -0.33, 0.33, 0.66, 0.33, 0.66, 0, 0 )  # Make graph pg = graph_from_data_frame(   d = df[,1:3],   directed=TRUE,   vertices=data.frame(var_labels) )  # Make plot par( mar=c(0,0,0,0) ) plot.igraph(   pg,   vertex.shape=\"rectangle\",   vertex.size=0,   vertex.size2=0,   vertex.label.cex=2,   vertex.color=\"grey\",   vertex.label.color=\"black\",   edge.label.color=\"black\",   edge.label.cex=1,   layout=layout[as.character(variables),],   xlim=1.2*c(-1,1),   ylim=1.2*c(-1,1),   edge.label.dist=0.8,   edge.label.x=df$x,   edge.label.y=df$y )"},{"path":[]},{"path":"https://vast-lib.github.io/tinyVAST/articles/web_only/stream_networks.html","id":"load-and-format-spatial-domain","dir":"Articles > Web_only","previous_headings":"","what":"Load and format spatial domain","title":"Stream network models","text":"First, load shapefile representing stream network, convert sfnetwork format. format includes edges representing stream segments, nodes edges connect.  convert S3 class â€œsfnetwork_meshâ€ defined tinyVAST stream networks, rescale distances 1000 ft (ensure distances 0.01 100, avoiding issues numerical overflow).","code":"stream <- st_read( file.path(system.file(\"stream_network\",package=\"tinyVAST\"),                    \"East_Fork_Lewis_basin.shp\"), quiet=TRUE ) stream = as_sfnetwork(stream) plot(stream, main=\"East Fork Lewis Basin\") # Rescale graph = sfnetwork_mesh( stream ) graph$table$dist = graph$table$dist / 1000  # Convert distance scale"},{"path":"https://vast-lib.github.io/tinyVAST/articles/web_only/stream_networks.html","id":"simulate-data","dir":"Articles > Web_only","previous_headings":"","what":"Simulate data","title":"Stream network models","text":"Next, â€™ll simulate Gaussian Markov random field stream vertices using simulate_sfnetwork, sample evenly spaced locations along stream using st_line_sample, project GMRF locations using sfnetwork_evaluator, simulate data locations: can visualize GMRF locations using sfnetwork","code":"# Parameters alpha = 2 kappa = 0.05 # mean(graph$table$dist) * kappa = 0.63 -> exp(-0.63) = 0.5 average correlation  # simulate omega_s = simulate_sfnetwork( n=1, sfnetwork_mesh=graph, theta=kappa)[,1]  # sample locations along network extrap = st_union( st_line_sample( activate(stream,\"edges\"), density=1/10000)) extrap = st_cast( extrap, \"POINT\" )  # Project to sampled locations A_is = sfnetwork_evaluator( stream = graph$stream,                                 loc = st_coordinates(extrap) ) omega_i = (A_is %*% omega_s)[,1]  # Simulate sampling #Count = rpois( n=graph$n, lambda=exp(alpha + omega) ) Count_i = rnorm( n=length(omega_i), mean=alpha + omega_i, sd=0.5 )  # Format into long-form data frame expected by tinyVAST Data = data.frame( Count = Count_i,                    st_coordinates(extrap),                    var = \"species\",  # Univariate model so only one value                    time = \"2020\",    # no time-dynamics, so only one value                    dist = \"obs\" )    # only one type of sampling in data # Plot stream plot(stream) # Extract nodes and plot on network plot( st_sf(st_geometry(activate(stream,\"nodes\")), \"omega\"=omega_s),       add=TRUE, pch=19, cex=2)"},{"path":"https://vast-lib.github.io/tinyVAST/articles/web_only/stream_networks.html","id":"fit-model","dir":"Articles > Web_only","previous_headings":"","what":"Fit model","title":"Stream network models","text":"Finally, can fit model: predict GMRF dense locations along stream network, plot true (simulated) values location simulated samples.  Runtime vignette: 2.78 secs","code":"# fit model out = tinyVAST( data = Data,            formula = Count ~ 1,            spatial_domain = graph,            space_column = c(\"X\",\"Y\"),            variable_column = \"var\",            time_column = \"time\",            distribution_column = \"dist\",            space_term = \"\" ) # Define plotting points sf_plot = st_union( st_line_sample( activate(stream,\"edges\"), density=1/1000)) sf_plot = st_cast( sf_plot, \"POINT\" )  # Format as `newdata` for prediction newdata = data.frame(    Count = NA,   st_coordinates(sf_plot),   var = \"species\",  # Univariate model so only one value   time = \"2020\",    # no time-dynamics, so only one value   dist = \"obs\"    # only one type of sampling in data )  # Extract predicted spatial variable omega_plot = predict( out, newdata = newdata )  # Plot stream object plot(    stream,    main=\"omegahat_i\" )  # Add predicted spatial variable plot(    st_sf(sf_plot,\"omega\"=omega_plot),    add=TRUE, pch=19, cex=0.5, pal=viridis  )  # Add true (simulated) values plot(    st_sf(extrap,\"omega\"=omega_i),    add=TRUE, pch=19, cex=2, pal=viridis  )"},{"path":[]},{"path":"https://vast-lib.github.io/tinyVAST/articles/web_only/VAST.html","id":"univariate-spatio-temporal-autoregressive-model","dir":"Articles > Web_only","previous_headings":"","what":"Univariate spatio-temporal autoregressive model","title":"Vector autoregressive spatio-temporal models","text":"first explore ability specify first-order autoregressive spatio-temporal process, .e., spatial Gompertz model (Thorson et al. 2014).","code":""},{"path":"https://vast-lib.github.io/tinyVAST/articles/web_only/VAST.html","id":"simulate-univariate-autoregressive-process","dir":"Articles > Web_only","previous_headings":"Univariate spatio-temporal autoregressive model","what":"Simulate univariate autoregressive process","title":"Vector autoregressive spatio-temporal models","text":", simulate process:","code":"# Simulate settings theta_xy = 0.4 n_x = n_y = 10 n_t = 15 rho = 0.8 spacetime_sd = 0.5 space_sd = 0.5 gamma = 0  # Simulate GMRFs R_s = exp(-theta_xy * abs(outer(1:n_x, 1:n_y, FUN=\"-\")) ) R_ss = kronecker(R_s, R_s) Vspacetime_ss = spacetime_sd^2 * R_ss  Vspace_ss = space_sd^2 * R_ss  # make spacetime AR1 over time eps_ts = mvtnorm::rmvnorm( n_t, sigma=Vspacetime_ss ) for( t in seq_len(n_t) ){   if(t>1) eps_ts[t,] = rho*eps_ts[t-1,] + eps_ts[t,]/(1 + rho^2) }  # make space term omega_s = mvtnorm::rmvnorm( 1, sigma=Vspace_ss )[1,]  # linear predictor p_ts = gamma + outer( rep(1,n_t),omega_s ) + eps_ts  # Shape into longform data-frame and add error Data = data.frame( expand.grid(time=1:n_t, x=1:n_x, y=1:n_y),                     var = \"logn\",                     mu = exp(as.vector(p_ts)) ) Data$n = tweedie::rtweedie( n=nrow(Data), mu=Data$mu, phi=0.5, power=1.5 ) mean(Data$n==0) #> [1] 0.072"},{"path":"https://vast-lib.github.io/tinyVAST/articles/web_only/VAST.html","id":"fit-univariate-spatio-temporal-model","dir":"Articles > Web_only","previous_headings":"Univariate spatio-temporal autoregressive model","what":"Fit univariate spatio-temporal model","title":"Vector autoregressive spatio-temporal models","text":"specify fit model estimated values beta_z correspond simulated value rho spatial_sd. can compare true densities:  estimated densities:  scatterplot shows highly correlated:  can also use DHARMa package visualize simulation residuals:  can calculate area-weighted total abundance compare true value:","code":"# make mesh mesh = fm_mesh_2d( Data[,c('x','y')] )  # Spatial variable space_term = \"   logn <-> logn, sd_space \"  # AR1 spatio-temporal variable spacetime_term = \"   logn -> logn, 1, rho   logn <-> logn, 0, sd_spacetime \"  # fit model mytinyVAST = tinyVAST(             space_term = space_term,            spacetime_term = spacetime_term,            data = Data,            formula = n ~ 1,            spatial_domain = mesh,            family = tweedie() ) mytinyVAST #> Call:  #> tinyVAST(formula = n ~ 1, data = Data, space_term = space_term,  #>     spacetime_term = spacetime_term, family = tweedie(), spatial_domain = mesh) #>  #> Run time:  #> Time difference of 14.37207 secs #>  #> Family:  #> $obs #>  #> Family: tweedie  #> Link function: log  #>  #>  #>  #>  #> sdreport(.) result #>              Estimate Std. Error #> alpha_j   -0.51042312 0.20682192 #> beta_z     0.84975372 0.07526572 #> beta_z    -0.25841774 0.03730119 #> theta_z    0.44410419 0.06898295 #> log_sigma -0.64811502 0.05006806 #> log_sigma  0.01446398 0.06494080 #> log_kappa -0.15608153 0.16446880 #> Maximum gradient component: 0.005583835  #>  #> Proportion conditional deviance explained:  #> [1] 0.543224 #>  #> space_term:  #>   heads   to from parameter start  Estimate  Std_Error  z_value      p_value #> 1     2 logn logn         1  <NA> 0.4441042 0.06898295 6.437883 1.211509e-10 #>  #> spacetime_term:  #>   heads   to from parameter start lag   Estimate  Std_Error   z_value #> 1     1 logn logn         1  <NA>   1  0.8497537 0.07526572 11.290049 #> 2     2 logn logn         2  <NA>   0 -0.2584177 0.03730119 -6.927869 #>        p_value #> 1 1.469547e-29 #> 2 4.272276e-12 #>  #> Fixed terms:  #>               Estimate Std_Error   z_value    p_value #> (Intercept) -0.5104231 0.2068219 -2.467935 0.01358949 library(sf) data_wide = reshape( Data[,c('x','y','time','mu')],                      direction = \"wide\", idvar = c('x','y'), timevar = \"time\") sf_data = st_as_sf( data_wide, coords=c(\"x\",\"y\")) sf_grid = sf::st_make_grid( sf_data ) sf_plot = st_sf(sf_grid, st_drop_geometry(sf_data) ) plot(sf_plot, max.plot=n_t ) Data$mu_hat = predict(mytinyVAST) data_wide = reshape( Data[,c('x','y','time','mu_hat')],                      direction = \"wide\", idvar = c('x','y'), timevar = \"time\") sf_data = st_as_sf( data_wide, coords=c(\"x\",\"y\")) sf_plot = st_sf(sf_grid, st_drop_geometry(sf_data) ) plot(sf_plot, max.plot=n_t ) plot( x=Data$mu, y=Data$mu_hat ) # simulate new data conditional on fixed effects # and sampling random effects from their predictive distribution y_ir = simulate(mytinyVAST, nsim=100, type=\"mle-mvn\")  # res = DHARMa::createDHARMa( simulatedResponse = y_ir,                              observedResponse = Data$n,                              fittedPredictedResponse = fitted(mytinyVAST) ) plot(res) # Predicted sample-weighted total (Est = sapply( seq_len(n_t),    FUN=\\(t) integrate_output(mytinyVAST, newdata=subset(Data,time==t)) )) #>                          [,1]      [,2]     [,3]      [,4]      [,5]      [,6] #> Estimate            69.774342 68.167115 68.24959 64.038611 58.736780 60.506542 #> Std. Error           4.733476  4.404922  4.32475  4.092695  3.880481  3.887897 #> Est. (bias.correct) 72.867322 71.288122 71.44284 67.062705 61.536991 63.391199 #> Std. (bias.correct)        NA        NA       NA        NA        NA        NA #>                          [,7]      [,8]      [,9]     [,10]     [,11]     [,12] #> Estimate            54.977480 58.463756 64.523920 74.895696 84.490757 76.981720 #> Std. Error           3.772127  3.863062  4.166782  4.702731  5.335555  5.141678 #> Est. (bias.correct) 57.610639 61.214950 67.544399 78.336996 88.253689 80.405085 #> Std. (bias.correct)        NA        NA        NA        NA        NA        NA #>                         [,13]      [,14]     [,15] #> Estimate            87.189025  96.106379 93.626461 #> Std. Error           5.514166   6.001112  6.338951 #> Est. (bias.correct) 91.106042 100.570708 98.734105 #> Std. (bias.correct)        NA         NA        NA  # True (latent) sample-weighted total (True = tapply( Data$mu, INDEX=Data$time, FUN=sum )) #>         1         2         3         4         5         6         7         8  #>  70.98033  70.14925  68.40932  68.70763  58.38332  65.95801  60.52297  55.14115  #>         9        10        11        12        13        14        15  #>  60.02083  74.91768  86.40811  77.73359  85.88998  98.33442 105.16020  # Index = data.frame( time=seq_len(n_t), t(Est), True ) Index$low = Index[,'Est...bias.correct.'] - 1.96*Index[,'Std..Error'] Index$high = Index[,'Est...bias.correct.'] + 1.96*Index[,'Std..Error']  # library(ggplot2) ggplot(Index, aes(time, Estimate)) +   geom_ribbon(aes(ymin = low,                   ymax = high),    # shadowing cnf intervals               fill = \"lightgrey\") +   geom_line( color = \"black\",             linewidth = 1) +   geom_point( aes(time, True), color = \"red\" )"},{"path":"https://vast-lib.github.io/tinyVAST/articles/web_only/VAST.html","id":"comparison-with-vast-or-sdmtmb","dir":"Articles > Web_only","previous_headings":"Univariate spatio-temporal autoregressive model","what":"Comparison with VAST or sdmTMB","title":"Vector autoregressive spatio-temporal models","text":"Next, compare current version VAST (Thorson Barnett 2017) sdmTMB (Anderson et al. n.d.) models similar runtimes","code":"settings = make_settings( purpose=\"index3\",                           n_x = n_x*n_y,                           Region = \"Other\",                           bias.correct = FALSE,                           use_anisotropy = FALSE ) settings$FieldConfig['Epsilon','Component_1'] = 0 settings$FieldConfig['Omega','Component_1'] = 0 settings$RhoConfig['Epsilon2'] = 4 settings$RhoConfig[c('Beta1','Beta2')] = 3 settings$ObsModel = c(10,2)  # Run VAST myVAST = fit_model( settings=settings,                  Lat_i = Data[,'y'],                  Lon_i = Data[,'x'],                  t_i = Data[,'time'],                  b_i = Data[,'n'],                  a_i = rep(1,nrow(Data)),                  observations_LL = cbind(Lat=Data[,'y'],Lon=Data[,'x']),                  grid_dim_km = c(100,100),                  newtonsteps = 0,                  loopnum = 1,                  control = list(eval.max = 10000, iter.max = 10000, trace = 0) ) myVAST #> fit_model(.) result #> $par #>       beta1_ft       beta2_ft     L_omega2_z   L_epsilon2_z      logkappa2  #>    -0.59988031     0.09993533     0.55005057     0.26695392    -4.68896241  #> Epsilon_rho2_f      logSigmaM  #>     0.89582684     0.05547658  #>  #> $objective #> [1] 1256.257 #>  #> $iterations #> [1] 3 #>  #> $evaluations #> function gradient  #>        7        3  #>  #> $time_for_MLE #> Time difference of 1.127294 secs #>  #> $max_gradient #> [1] 0.0007302205 #>  #> $Convergence_check #> [1] \"The model is likely not converged\" #>  #> $number_of_coefficients #>  Total  Fixed Random  #>   2183      7   2176  #>  #> $AIC #> [1] 2526.515 #>  #> $diagnostics #>                         Param starting_value     Lower         MLE     Upper #> beta1_ft             beta1_ft    -0.59987818      -Inf -0.59988031       Inf #> beta2_ft             beta2_ft     0.09993558      -Inf  0.09993533       Inf #> L_omega2_z         L_omega2_z     0.55005171      -Inf  0.55005057       Inf #> L_epsilon2_z     L_epsilon2_z     0.26695303      -Inf  0.26695392       Inf #> logkappa2           logkappa2    -4.68896169 -6.214608 -4.68896241 -3.565449 #> Epsilon_rho2_f Epsilon_rho2_f     0.89582671 -0.990000  0.89582684  0.990000 #> logSigmaM           logSigmaM     0.05547811      -Inf  0.05547658 10.000000 #>                final_gradient #> beta1_ft         7.302205e-04 #> beta2_ft         3.958129e-05 #> L_omega2_z       1.120546e-04 #> L_epsilon2_z    -1.264247e-04 #> logkappa2        9.682345e-05 #> Epsilon_rho2_f  -1.139032e-04 #> logSigmaM       -2.508978e-04 #>  #> $SD #> sdreport(.) result #>                   Estimate Std. Error #> beta1_ft       -0.59988031 0.04573745 #> beta2_ft        0.09993533 0.21591340 #> L_omega2_z      0.55005057 0.08905102 #> L_epsilon2_z    0.26695392 0.04043402 #> logkappa2      -4.68896241 0.18202530 #> Epsilon_rho2_f  0.89582684 0.06297620 #> logSigmaM       0.05547658 0.06294172 #> Maximum gradient component: 0.0007302205  #>  #> $time_for_sdreport #> Time difference of 3.667329 secs #>  #> $time_for_run #> Time difference of 18.8686 secs library(sdmTMB) sdmTMB_mesh = make_mesh(Data, c(\"x\",\"y\"), n_knots=n_x*n_y )  start_time2 = Sys.time() mysdmTMB = sdmTMB(   formula = n ~ 1,   data = Data,   mesh = sdmTMB_mesh,   spatial = \"on\",   spatiotemporal = \"ar1\",   time = \"time\",   family = tweedie() ) sdmTMBtime = Sys.time() - start_time2 Times = c( \"tinyVAST\" = mytinyVAST$run_time,            \"VAST\" = myVAST$total_time,            \"sdmTMB\" = sdmTMBtime ) knitr::kable( cbind(\"run times (sec.)\"=Times), digits=1)"},{"path":"https://vast-lib.github.io/tinyVAST/articles/web_only/VAST.html","id":"delta-models","dir":"Articles > Web_only","previous_headings":"Univariate spatio-temporal autoregressive model","what":"Delta models","title":"Vector autoregressive spatio-temporal models","text":"can also fit univariate spatio-temporal process using Poisson-linked gamma delta model (Thorson 2018) can use DHARMa package (Hartig 2017) visualize conditional simulation quantile (.k.. Dunn-Smythe) residuals (Dunn Smyth 1996):  can use marginal conditional AIC compare fit delta-model Tweedie distribution:","code":"# fit model mydelta2 = tinyVAST(    data = Data,   formula = n ~ 1,   delta_options = list(     formula = ~ 0 + factor(time),     spacetime_term = \"logn -> logn, 1, rho\"),   family = delta_lognormal(type=\"poisson-link\"),   spatial_domain = mesh  )  mydelta2 #> Call:  #> tinyVAST(formula = n ~ 1, data = Data, family = delta_lognormal(type = \"poisson-link\"),  #>     delta_options = list(formula = ~0 + factor(time), spacetime_term = \"logn -> logn, 1, rho\"),  #>     spatial_domain = mesh) #>  #> Run time:  #> Time difference of 12.24713 secs #>  #> Family:  #> $obs #>  #> Family: binomial lognormal  #> Link function: log log  #>  #>  #>  #>  #> sdreport(.) result #>              Estimate Std. Error #> alpha_j    0.96740001 0.03523113 #> alpha2_j  -1.24655464 0.14981014 #> alpha2_j  -1.29278791 0.17500129 #> alpha2_j  -1.30567555 0.19172149 #> alpha2_j  -1.32180772 0.20304204 #> alpha2_j  -1.57098808 0.21258829 #> alpha2_j  -1.44507840 0.21944962 #> alpha2_j  -1.71680200 0.22626333 #> alpha2_j  -1.54485934 0.23247418 #> alpha2_j  -1.39904962 0.23307993 #> alpha2_j  -1.12515798 0.23638029 #> alpha2_j  -1.22354406 0.23877401 #> alpha2_j  -1.51311723 0.24006132 #> alpha2_j  -1.24691177 0.24216425 #> alpha2_j  -1.12785623 0.24209137 #> alpha2_j  -1.07071406 0.24334579 #> beta2_z    0.89674417 0.03512480 #> beta2_z    0.31332882 0.03906491 #> log_sigma  0.02962681 0.02475180 #> log_kappa  0.10856726 0.14818594 #> Maximum gradient component: 0.002532163  #>  #> Proportion conditional deviance explained:  #> [1] 0.3295016 #>  #> Fixed terms:  #>             Estimate  Std_Error  z_value       p_value #> (Intercept)   0.9674 0.03523113 27.45867 5.474652e-166 # simulate new data conditional on fixed effects # and sampling random effects from their predictive distribution y_ir = simulate(mydelta2, nsim=100, type=\"mle-mvn\")  # Visualize using DHARMa res = DHARMa::createDHARMa( simulatedResponse = y_ir,                              observedResponse = Data$n,                              fittedPredictedResponse = fitted(mydelta2) ) plot(res) # AIC table AIC_table = cbind(   mAIC = c( \"Tweedie\" = AIC(mytinyVAST),              \"delta-lognormal\" = AIC(mydelta2) ),    cAIC = c( \"Tweedie\" = tinyVAST::cAIC(mytinyVAST),              \"delta-lognormal\" = tinyVAST::cAIC(mydelta2) )  )  # Print table knitr::kable(    AIC_table,   digits=3 )"},{"path":"https://vast-lib.github.io/tinyVAST/articles/web_only/VAST.html","id":"bivariate-vector-autoregressive-spatio-temporal-model","dir":"Articles > Web_only","previous_headings":"","what":"Bivariate vector autoregressive spatio-temporal model","title":"Vector autoregressive spatio-temporal models","text":"next highlight specify bivariate spatio-temporal model cross-laggged (vector autoregressive) interaction Thorson, Adams, Holsman (2019). ## Simulate bivariate model first simulate artificial data sake demonstration:","code":"# Simulate settings theta_xy = 0.2 n_x = n_y = 10 n_t = 20 B = rbind( c( 0.5, -0.25),            c(-0.1,  0.50) )  # Simulate GMRFs R = exp(-theta_xy * abs(outer(1:n_x, 1:n_y, FUN=\"-\")) ) d1 = mvtnorm::rmvnorm(n_t, sigma=0.2*kronecker(R,R) ) d2 = mvtnorm::rmvnorm(n_t, sigma=0.2*kronecker(R,R) ) d = abind::abind( d1, d2, along=3 )  # Project through time and add mean for( t in seq_len(n_t) ){   if(t>1) d[t,,] = t(B%*%t(d[t-1,,])) + d[t,,] }  # Shape into longform data-frame and add error Data = data.frame( expand.grid(time=1:n_t, x=1:n_x, y=1:n_y, \"var\"=c(\"d1\",\"d2\")),                    mu = exp(as.vector(d))) Data$n = tweedie::rtweedie( n=nrow(Data), mu=Data$mu, phi=0.5, power=1.5 )"},{"path":"https://vast-lib.github.io/tinyVAST/articles/web_only/VAST.html","id":"fit-bivariate-model","dir":"Articles > Web_only","previous_headings":"Bivariate vector autoregressive spatio-temporal model","what":"Fit bivariate model","title":"Vector autoregressive spatio-temporal models","text":"next set inputs run model: values beta_z correspond specified value interaction-matrix B can calculate area-weighted total abundance compare true value:","code":"# make mesh mesh = fm_mesh_2d( Data[,c('x','y')] )  # Define DSEM dsem = \"   d1 -> d1, 1, b11   d2 -> d2, 1, b22   d2 -> d1, 1, b21   d1 -> d2, 1, b12   d1 <-> d1, 0, var1   d2 <-> d2, 0, var1 \"  # fit model out = tinyVAST( spacetime_term = dsem,            data = Data,            formula = n ~ 0 + var,            spatial_domain = mesh,            family = tweedie() ) out #> Call:  #> tinyVAST(formula = n ~ 0 + var, data = Data, spacetime_term = dsem,  #>     family = tweedie(), spatial_domain = mesh) #>  #> Run time:  #> Time difference of 1.049404 mins #>  #> Family:  #> $obs #>  #> Family: tweedie  #> Link function: log  #>  #>  #>  #>  #> sdreport(.) result #>               Estimate Std. Error #> alpha_j    0.264368410 0.09266171 #> alpha_j    0.035863841 0.07360860 #> beta_z     0.455447934 0.06734774 #> beta_z     0.389078121 0.08038421 #> beta_z    -0.405603382 0.08530597 #> beta_z    -0.084083282 0.06545855 #> beta_z     0.329048842 0.01844056 #> log_sigma -0.691801477 0.02886804 #> log_sigma  0.007588811 0.05777685 #> log_kappa -0.487467936 0.09474226 #> Maximum gradient component: 0.003829853  #>  #> Proportion conditional deviance explained:  #> [1] 0.4593592 #>  #> spacetime_term:  #>   heads to from parameter start lag    Estimate  Std_Error   z_value #> 1     1 d1   d1         1  <NA>   1  0.45544793 0.06734774  6.762632 #> 2     1 d2   d2         2  <NA>   1  0.38907812 0.08038421  4.840231 #> 3     1 d1   d2         3  <NA>   1 -0.40560338 0.08530597 -4.754689 #> 4     1 d2   d1         4  <NA>   1 -0.08408328 0.06545855 -1.284527 #> 5     2 d1   d1         5  <NA>   0  0.32904884 0.01844056 17.843757 #> 6     2 d2   d2         5  <NA>   0  0.32904884 0.01844056 17.843757 #>        p_value #> 1 1.355075e-11 #> 2 1.296885e-06 #> 3 1.987519e-06 #> 4 1.989576e-01 #> 5 3.232147e-71 #> 6 3.232147e-71 #>  #> Fixed terms:  #>         Estimate  Std_Error   z_value     p_value #> vard1 0.26436841 0.09266171 2.8530492 0.004330192 #> vard2 0.03586384 0.07360860 0.4872235 0.626099937 # Predicted sample-weighted total  # for each year-variable combination Est1 = Est2 = NULL for( t in seq_len(n_t) ){   Est1 = rbind(Est1, integrate_output(      out,      newdata = subset(Data, time==t & var==\"d1\")   ))   Est2 = rbind(Est2, integrate_output(      out,      newdata = subset(Data, time==t & var==\"d2\")   )) }  # True (latent) sample-weighted total True = tapply(    Data$mu,    INDEX=list(\"time\"=Data$time,\"var\"=Data$var),    FUN=sum  )  # Make long-form data frame for ggplot Index = data.frame(    expand.grid(dimnames(True)),    True = as.vector(True),   rbind(Est1, Est2) )  # Format intervals for ggplot Index$low = Index[,'Est...bias.correct.'] - 1.96*Index[,'Std..Error'] Index$high = Index[,'Est...bias.correct.'] + 1.96*Index[,'Std..Error']  # library(ggplot2) ggplot(Index, aes( time, Estimate )) +   facet_grid( rows=vars(var), scales=\"free\" ) +   geom_segment(aes(y = low,                   yend = high,                   x = time,                   xend = time) ) +   geom_point( aes(x=time, y=Estimate), color = \"black\") +   geom_point( aes(x=time, y=True), color = \"red\" )"},{"path":[]},{"path":"https://vast-lib.github.io/tinyVAST/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"James T. Thorson. Author, maintainer. Sean C. Anderson. Author.","code":""},{"path":"https://vast-lib.github.io/tinyVAST/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Thorson JT, Anderson SC, Goddard P, Rooper CN (2025). â€œtinyVAST: R package expressive interface specify lagged simultaneous effects multivariate spatio-temporal models.â€ Global Ecology Biogeography, 34(4), e70035. doi:10.1111/geb.70035, https://doi.org/10.1111/geb.70035.","code":"@Article{,   title = {tinyVAST: R package with an expressive interface to specify lagged and simultaneous effects in multivariate spatio-temporal models},   author = {James T. Thorson and Sean C. Anderson and Pamela Goddard and Christopher N. Rooper},   volume = {34},   number = {4},   pages = {e70035},   year = {2025},   url = {https://doi.org/10.1111/geb.70035},   journal = {Global Ecology and Biogeography},   doi = {10.1111/geb.70035}, }"},{"path":"https://vast-lib.github.io/tinyVAST/header.html","id":null,"dir":"","previous_headings":"","what":"tinyVAST","title":"tinyVAST","text":"Multivariate spatio-temporal models using dynamic structural equations  tinyVAST R package fits multivariate spatio-temporal models using Gaussian Markov random fields represent nonseparable interactions among variables time. See preprint: Thorson, J. T., Anderson, S. C., Goddard, P., & Rooper, C. N. (2024). tinyVAST: R package expressive interface specify lagged simultaneous effects multivariate spatio-temporal models (arXiv:2401.10193). arXiv. http://arxiv.org/abs/2401.10193","code":""},{"path":[]},{"path":"https://vast-lib.github.io/tinyVAST/index.html","id":"tinyvast-","dir":"","previous_headings":"","what":"Multivariate Spatio-Temporal Models using Structural Equations","title":"Multivariate Spatio-Temporal Models using Structural Equations","text":"Multivariate spatio-temporal models using dynamic structural equations tinyVAST R package fits multivariate spatio-temporal models using Gaussian Markov random fields represent nonseparable interactions among variables time. See preprint: Thorson, J. T., Anderson, S. C., Goddard, P., & Rooper, C. N. (2024). tinyVAST: R package expressive interface specify lagged simultaneous effects multivariate spatio-temporal models (arXiv:2401.10193). arXiv. http://arxiv.org/abs/2401.10193","code":""},{"path":"https://vast-lib.github.io/tinyVAST/index.html","id":"table-of-contents","dir":"","previous_headings":"","what":"Table of contents","title":"Multivariate Spatio-Temporal Models using Structural Equations","text":"Installation Citation Related software","code":""},{"path":"https://vast-lib.github.io/tinyVAST/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Multivariate Spatio-Temporal Models using Structural Equations","text":"tinyVAST can installed GitHub:","code":"library(devtools) install_github(\"vast-lib/tinyVAST\", dependencies = TRUE)"},{"path":"https://vast-lib.github.io/tinyVAST/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Multivariate Spatio-Temporal Models using Structural Equations","text":"cite tinyVAST publications use: Thorson, J. T., Anderson, S. C., Goddard, P., & Rooper, C. N. (2025). tinyVAST: R package expressive interface specify lagged simultaneous effects multivariate spatio-temporal models. Global Ecology Biogeography. 34(4): e70035. https://doi.org/10.1111/geb.70035","code":"citation(\"tinyVAST\")"},{"path":"https://vast-lib.github.io/tinyVAST/index.html","id":"related-software","dir":"","previous_headings":"","what":"Related software","title":"Multivariate Spatio-Temporal Models using Structural Equations","text":"tinyVAST builds upon many packages. includes VAST R package: Thorson, J.T. 2019. Guidance decisions using Vector Autoregressive Spatio-Temporal (VAST) package stock, ecosystem, habitat climate assessments. Fisheries Research 210: 143â€“161. https://doi.org/10.1016/j.fishres.2018.10.013. sdmTMB R package: Anderson, S.C., E.J. Ward, P.. English, L..K. Barnett. 2022. sdmTMB: R package fast, flexible, user-friendly generalized linear mixed effects models spatial spatiotemporal random fields. bioRxiv 2022.03.24.485545; doi: https://doi.org/10.1101/2022.03.24.485545 glmmTMB R package: Brooks, M.E., Kristensen, K., van Benthem, K.J., Magnusson, ., Berg, C.W., Nielsen, ., Skaug, H.J., Maechler, M., Bolker, B.M. 2017. glmmTMB balances speed flexibility among packages zero-inflated generalized linear mixed modeling. R Journal 9(2): 378â€“400. https://doi.org/10.32614/rj-2017-066. INLA inlabru can fit many models sdmTMB (many ) approximate Bayesian inference framework. mgcv can fit similar SPDE-based Gaussian random field models code included Miller et al.Â (2019).","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/add_mesh_covariates.html","id":null,"dir":"Reference","previous_headings":"","what":"Add mesh covariates to vertices and triangles â€” add_mesh_covariates","title":"Add mesh covariates to vertices and triangles â€” add_mesh_covariates","text":"Interpolates covariate values data frame mesh vertices using inverse distance weighting (IDW). Uses gstat exact IDW interpolation default, optional high-performance RANN method large datasets.","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/add_mesh_covariates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add mesh covariates to vertices and triangles â€” add_mesh_covariates","text":"","code":"add_mesh_covariates(   mesh,   data,   covariates,   coords,   power = 2,   method = c(\"gstat\", \"rann\"),   k = 10,   barrier = NULL )"},{"path":"https://vast-lib.github.io/tinyVAST/reference/add_mesh_covariates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add mesh covariates to vertices and triangles â€” add_mesh_covariates","text":"mesh mesh object fmesher sdmTMB (sdmTMB::sdmTMB() models ). data data frame coordinate columns covariate columns, sf object. covariates Character vector covariate column names interpolate. coords Character vector coordinate column names. Ignored data sf object. power Numeric power parameter inverse distance weighting (default 2; Euclidean squared decay). method Interpolation method. Options: \"gstat\" (default, exact inverse distance weighting using gstat package) \"rann\" (fast k-nearest neighbours inverse distance weighting using RANN package large datasets). k Number nearest neighbours use \"rann\" method (default 10). Ignored \"gstat\" method. barrier Optional sf polygon object defining barrier regions. provided, adds logical barrier column vertex_covariates triangle_covariates. E.g., case modelling fish ocean, TRUE represents vertices/triangle centers land FALSE represents vertices/triangle centers water. triangles, also adds barrier_proportion column indicating proportion triangle's area intersects barrier polygon (0 = intersection, 1 = triangle completely within barrier).","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/add_mesh_covariates.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add mesh covariates to vertices and triangles â€” add_mesh_covariates","text":"Modified mesh object vertex_covariates triangle_covariates elements added class vertex_cov added. vertex_covariates data frame contains covariate values interpolated mesh vertices, triangle_covariates contains covariate values interpolated triangle centers.","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/add_mesh_covariates.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add mesh covariates to vertices and triangles â€” add_mesh_covariates","text":"","code":"library(sdmTMB) #>  #> Attaching package: â€˜sdmTMBâ€™ #> The following objects are masked from â€˜package:tinyVASTâ€™: #>  #>     cAIC, delta_gamma, delta_lognormal, project library(sf) #> Linking to GEOS 3.13.1, GDAL 3.11.0, PROJ 9.6.0; sf_use_s2() is TRUE  # Regular data frame mesh <- fmesher::fm_mesh_2d(pcod[, c(\"X\", \"Y\")], cutoff = 10) mesh_with_covs <- add_mesh_covariates(   mesh,   data = qcs_grid,   covariates = c(\"depth\"),   coords = c(\"X\", \"Y\") ) head(mesh_with_covs$vertex_covariates) #>      depth #> 1 187.1538 #> 2 130.0879 #> 3 131.7996 #> 4 146.7183 #> 5 165.7199 #> 6 157.8532  # Visualize what we've done: if (requireNamespace(\"ggplot2\", quietly = TRUE)) {   library(ggplot2)   df <- as.data.frame(mesh_with_covs$loc[,1:2])   df <- cbind(df, mesh_with_covs$vertex_covariates)   ggplot() +     geom_raster(data = qcs_grid, aes(X, Y, fill = depth), alpha = 0.7) +     geom_point( data = df, aes(V1, V2, fill = depth),                 colour = \"#00000010\", pch = 21) +     scale_fill_viridis_c(option = \"G\", trans = \"log\", direction = -1)    df_tri <- mesh_with_covs$triangle_covariates   ggplot() +     geom_raster( data = qcs_grid, aes(X, Y, fill = depth), alpha = 0.7) +     geom_point( data = df_tri, aes(x = .x_triangle, y = .y_triangle, fill = depth),                 colour = \"#00000010\", pch = 21) +     scale_fill_viridis_c(option = \"G\", trans = \"log\", direction = -1) }   # Piped version mesh_with_covs <- fmesher::fm_mesh_2d(pcod[, c(\"X\", \"Y\")], cutoff = 10) |>   add_mesh_covariates(     qcs_grid,     covariates = c(\"depth_scaled\", \"depth_scaled2\"),     coords = c(\"X\", \"Y\")   )  # With sf objects (coords automatically extracted) pcod_sf <- st_as_sf(pcod, coords = c(\"X\", \"Y\")) grid_sf <- st_as_sf(qcs_grid, coords = c(\"X\", \"Y\")) mesh_sf <- fmesher::fm_mesh_2d(pcod_sf, cutoff = 10) |>   add_mesh_covariates(grid_sf, c(\"depth\"))  # With sdmTMB mesh (coordinate names and mesh automatically detected) mesh <- make_mesh(pcod, c(\"X\", \"Y\"), cutoff = 10) |>   add_mesh_covariates(qcs_grid, c(\"depth\"))  # Use RANN method for very large datasets (much faster) mesh_fast <- fmesher::fm_mesh_2d(pcod[, c(\"X\", \"Y\")], cutoff = 10) |>   add_mesh_covariates(     qcs_grid,     covariates = c(\"depth_scaled\", \"depth_scaled2\"),     coords = c(\"X\", \"Y\"),     method = \"rann\",     k = 15   )"},{"path":"https://vast-lib.github.io/tinyVAST/reference/add_predictions.html","id":null,"dir":"Reference","previous_headings":"","what":"Add predictions to data-list â€” add_predictions","title":"Add predictions to data-list â€” add_predictions","text":"Given user-provided newdata, expand object tmb_data include predictions corresponding new observations","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/add_predictions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add predictions to data-list â€” add_predictions","text":"","code":"add_predictions(object, newdata, remove_origdata = FALSE)"},{"path":"https://vast-lib.github.io/tinyVAST/reference/add_predictions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add predictions to data-list â€” add_predictions","text":"object Output tinyVAST(). newdata New data-frame independent variables used predict response. remove_origdata Whether remove original-data allow faster evaluation. remove_origdata=TRUE eliminates information distribution random effects, combined epsilon bias-correction. WARNING:  feature experimental subject change.","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/add_predictions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add predictions to data-list â€” add_predictions","text":"object fit$tmb_inputs$tmb_data representing data used fitting, updated values slots associated predictions, updated object can recompiled TMB provide predictions","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/alaska_sponge_coral_fish.html","id":null,"dir":"Reference","previous_headings":"","what":"Data to analyze sponge-coral-fish associations â€” alaska_sponge_coral_fish","title":"Data to analyze sponge-coral-fish associations â€” alaska_sponge_coral_fish","text":"Data used Thorson et al. 2025 copied Zenodo allow inclusion package vignette.  includes bottom-trawl samples rockfish flatfish Alaska Fisheries Science Center Gulf Alaska Aleutian Islands, drop-camera samples rockfish, flatfish, sponges, corals Alaska Fisheries Science Center funded Deep Sea Coral Initiative.","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/alaska_sponge_coral_fish.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Data to analyze sponge-coral-fish associations â€” alaska_sponge_coral_fish","text":"","code":"data(alaska_sponge_coral_fish)"},{"path":"https://vast-lib.github.io/tinyVAST/reference/bering_sea.html","id":null,"dir":"Reference","previous_headings":"","what":"Survey domain for the eastern and northern Bering Sea surveys â€” bering_sea","title":"Survey domain for the eastern and northern Bering Sea surveys â€” bering_sea","text":"Shapefile defining spatial domain eastern northern Bering Sea bottom trawl surveys.","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/bering_sea.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Survey domain for the eastern and northern Bering Sea surveys â€” bering_sea","text":"","code":"data(bering_sea)"},{"path":"https://vast-lib.github.io/tinyVAST/reference/bering_sea_capelin_forecasts.html","id":null,"dir":"Reference","previous_headings":"","what":"Data to demonstrate probabilistic forecasting â€” bering_sea_capelin_forecasts","title":"Data to demonstrate probabilistic forecasting â€” bering_sea_capelin_forecasts","text":"Data estimate probabilistic forecasting, bridges uncertainty short-term (decadal) projections long-term (end--century) forecasts.  use capelin sampling survey trawl survey eastern northern Bering Sea, well annual sea surface temperature anomalies.  data set includes data frames fitted data Data projected values New_Data","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/bering_sea_capelin_forecasts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Data to demonstrate probabilistic forecasting â€” bering_sea_capelin_forecasts","text":"","code":"data(bering_sea_capelin_forecasts)"},{"path":"https://vast-lib.github.io/tinyVAST/reference/bering_sea_pollock_ages.html","id":null,"dir":"Reference","previous_headings":"","what":"Survey catch-rates at age for Alaska pollock in the Eastern and Northern Bering Sea â€” bering_sea_pollock_ages","title":"Survey catch-rates at age for Alaska pollock in the Eastern and Northern Bering Sea â€” bering_sea_pollock_ages","text":"Data used demonstrate test model-based age expansion, using density= dependence corrected survey catch rates first=stage expansion bottom trawl survey ages 1-15, conducted Alaska Fisheries Science Center, including annual surveys eastern Bering Sea 1982-2019 2021-2023, well northern Bering Sea 1982/85/88/91 2010/17/18/19/21/22/23.","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/bering_sea_pollock_ages.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Survey catch-rates at age for Alaska pollock in the Eastern and Northern Bering Sea â€” bering_sea_pollock_ages","text":"","code":"data(bering_sea_pollock_ages)"},{"path":"https://vast-lib.github.io/tinyVAST/reference/bering_sea_pollock_vast.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimated proportion-at-age for Alaska pollock using VAST â€” bering_sea_pollock_vast","title":"Estimated proportion-at-age for Alaska pollock using VAST â€” bering_sea_pollock_vast","text":"Estimated proporrtion--age Alaska pollock using package VAST, comparison output using tinyVAST.","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/bering_sea_pollock_vast.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimated proportion-at-age for Alaska pollock using VAST â€” bering_sea_pollock_vast","text":"","code":"data(bering_sea_pollock_vast)"},{"path":"https://vast-lib.github.io/tinyVAST/reference/cAIC.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate conditional AIC â€” cAIC","title":"Calculate conditional AIC â€” cAIC","text":"Calculates conditional Akaike Information criterion (cAIC).","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/cAIC.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate conditional AIC â€” cAIC","text":"","code":"cAIC(object)"},{"path":"https://vast-lib.github.io/tinyVAST/reference/cAIC.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate conditional AIC â€” cAIC","text":"object Output tinyVAST().","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/cAIC.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate conditional AIC â€” cAIC","text":"cAIC value","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/cAIC.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate conditional AIC â€” cAIC","text":"cAIC designed optimize expected --sample predictive performance new data share random effects -sample (fitted) data, e.g., spatial interpolation.  sense, fast approximation optimizing model structure based k-fold cross-validation. contrast, AIC() calculates marginal Akaike Information Criterion, designed optimize expected predictive performance new data new random effects, e.g., extrapolation, inference generative parameters. cAIC EDF calculated using Eq. 6 Zheng, Cadigan, Thorson (2024). models include profiled fixed effects, profiles turned .","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/cAIC.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Calculate conditional AIC â€” cAIC","text":"Zheng, N., Cadigan, N., & Thorson, J. T. (2024). note numerical evaluation conditional Akaike information nonlinear mixed-effects models (arXiv:2411.14185). arXiv. doi:10.48550/arXiv.2411.14185","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/cAIC.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate conditional AIC â€” cAIC","text":"","code":"data( red_snapper ) red_snapper = droplevels(subset(red_snapper, Data_type==\"Biomass_KG\"))  # Define mesh mesh = fmesher::fm_mesh_2d( red_snapper[,c('Lon','Lat')],                            cutoff = 1 )  # define formula with a catchability covariate for gear formula = Response_variable ~ factor(Year) + offset(log(AreaSwept_km2))  # make variable column red_snapper$var = \"logdens\" # fit using tinyVAST fit = tinyVAST( data = red_snapper,                 formula = formula,                 space_term = \"logdens <-> logdens, sd_space\",                 space_columns = c(\"Lon\",'Lat'),                 spatial_domain = mesh,                 family = tweedie(link=\"log\"),                 variable_column = \"var\",                 control = tinyVASTcontrol( getsd = FALSE,                                            profile = \"alpha_j\" ) )  cAIC(fit) # conditional AIC #> Error in UseMethod(\"cAIC\", object): no applicable method for 'cAIC' applied to an object of class \"tinyVAST\" AIC(fit) # marginal AIC #> [1] 43073.52"},{"path":"https://vast-lib.github.io/tinyVAST/reference/classify_variables.html","id":null,"dir":"Reference","previous_headings":"","what":"Classify variables path â€” classify_variables","title":"Classify variables path â€” classify_variables","text":"classify_variables copied sem:::classifyVariables","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/classify_variables.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Classify variables path â€” classify_variables","text":"","code":"classify_variables(model)"},{"path":"https://vast-lib.github.io/tinyVAST/reference/classify_variables.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Classify variables path â€” classify_variables","text":"model syntax structural equation model","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/classify_variables.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Classify variables path â€” classify_variables","text":"Tagged-list defining exogenous endogenous variables","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/classify_variables.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Classify variables path â€” classify_variables","text":"Copied package sem licence GPL (>= 2) permission John Fox","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/conditional_gmrf.html","id":null,"dir":"Reference","previous_headings":"","what":"Conditional simulation from a GMRF â€” conditional_gmrf","title":"Conditional simulation from a GMRF â€” conditional_gmrf","text":"Generates samples Gaussian Markov random field (GMRF) conditional upon fixed values elements.","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/conditional_gmrf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Conditional simulation from a GMRF â€” conditional_gmrf","text":"","code":"conditional_gmrf(   Q,   observed_idx,   x_obs,   n_sims = 1,   what = c(\"simulate\", \"predict\") )"},{"path":"https://vast-lib.github.io/tinyVAST/reference/conditional_gmrf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Conditional simulation from a GMRF â€” conditional_gmrf","text":"Q precision zero-centered GMRF. observed_idx integer vector listing rows Q corresponding fixed measurements x_obs numeric vector fixed values indices observed_idx n_sims integer listing number simulated values Whether simulate conditional GMRF, predict mean precision","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/conditional_gmrf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Conditional simulation from a GMRF â€” conditional_gmrf","text":"matrix n_sims columns row every row Q observed_idx, simulations rows","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/condition_and_density.html","id":null,"dir":"Reference","previous_headings":"","what":"Condition and density example â€” condition_and_density","title":"Condition and density example â€” condition_and_density","text":"Data used demonstrate test bivariate model morphometric condition (.e., residuals weight--length relationship) density fishes, using example provided wiki example VAST. Data doi:10.3354/meps13213","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/condition_and_density.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Condition and density example â€” condition_and_density","text":"","code":"data(condition_and_density)"},{"path":"https://vast-lib.github.io/tinyVAST/reference/deviance_explained.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate deviance explained â€” deviance_explained","title":"Calculate deviance explained â€” deviance_explained","text":"deviance_explained fits null model, calculates deviance relative saturated model original null model, uses calculate proportion deviance explained. implementation conditions upon maximum likelihood estimate fixed effects empirical Bayes (\"plug-\") prediction random effects.  can described \"conditional deviance explained\". state-space model estimates measurement error variance approaching zero (.e., collapses process-error-model) conditional deviance explained approaches 1.0","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/deviance_explained.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate deviance explained â€” deviance_explained","text":"","code":"deviance_explained(x, null_formula, null_delta_formula = ~1)"},{"path":"https://vast-lib.github.io/tinyVAST/reference/deviance_explained.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate deviance explained â€” deviance_explained","text":"x output \\code{tinyVAST()} null_formula formula null model.  missing, uses null_formula = response ~ 1. multivariate models, might make sense use null_formula = response ~ category null_delta_formula formula null model delta component. missing, uses null_formula = response ~ 1. multivariate models, might make sense use null_delta_formula = response ~ category","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/deviance_explained.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate deviance explained â€” deviance_explained","text":"proportion conditional deviance explained.","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/families.html","id":null,"dir":"Reference","previous_headings":"","what":"Additional families â€” Families","title":"Additional families â€” Families","text":"Additional families compatible tinyVAST().","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/families.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Additional families â€” Families","text":"","code":"delta_lognormal(link1, link2 = \"log\", type = c(\"standard\", \"poisson-link\"))  delta_gamma(link1, link2 = \"log\", type = c(\"standard\", \"poisson-link\"))"},{"path":"https://vast-lib.github.io/tinyVAST/reference/families.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Additional families â€” Families","text":"link1 Link first part delta/hurdle model. link2 Link second part delta/hurdle model. type Delta/hurdle family type. \"standard\" classic hurdle model. \"poisson-link\" Poisson-link delta model (Thorson 2018). link Link.","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/families.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Additional families â€” Families","text":"list elements common standard R family objects including family, link, linkfun, linkinv. Delta/hurdle model families also elements delta (logical) type (standard vs. Poisson-link).","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/families.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Additional families â€” Families","text":"Poisson-link delta families: Thorson, J.T. 2018. Three problems conventional delta-model biomass sampling data, computationally efficient alternative. Canadian Journal Fisheries Aquatic Sciences, 75(9), 1369-1382. doi:10.1139/cjfas-2017-0266 Poisson-link delta families: Thorson, J.T. 2018. Three problems conventional delta-model biomass sampling data, computationally efficient alternative. Canadian Journal Fisheries Aquatic Sciences, 75(9), 1369-1382. doi:10.1139/cjfas-2017-0266","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/GetResponse.tinyVAST.html","id":null,"dir":"Reference","previous_headings":"","what":"Get response â€” GetResponse.tinyVAST","title":"Get response â€” GetResponse.tinyVAST","text":"S3 generic package cv, used crossvalidation","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/GetResponse.tinyVAST.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get response â€” GetResponse.tinyVAST","text":"","code":"# S3 method for class 'tinyVAST' GetResponse(model, ...)"},{"path":"https://vast-lib.github.io/tinyVAST/reference/GetResponse.tinyVAST.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get response â€” GetResponse.tinyVAST","text":"model output tinyVAST() ... used","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/get_data.tinyVAST.html","id":null,"dir":"Reference","previous_headings":"","what":"Get data â€” get_data.tinyVAST","title":"Get data â€” get_data.tinyVAST","text":"S3 generic package insight, used crossvalidation","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/get_data.tinyVAST.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get data â€” get_data.tinyVAST","text":"","code":"# S3 method for class 'tinyVAST' get_data(x, ...)"},{"path":"https://vast-lib.github.io/tinyVAST/reference/get_data.tinyVAST.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get data â€” get_data.tinyVAST","text":"x output tinyVAST() ... used","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/integrate_output.html","id":null,"dir":"Reference","previous_headings":"","what":"Integration for target variable â€” integrate_output","title":"Integration for target variable â€” integrate_output","text":"Calculates estimator derived quantity summing across multiple predictions. can used approximate integral estimating area-expanded abundance, abundance-weighting covariate calculate distribution shifts, /weighting one model variable another.","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/integrate_output.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Integration for target variable â€” integrate_output","text":"","code":"integrate_output(   object,   newdata,   area,   type = rep(1, nrow(newdata)),   weighting_index,   covariate,   getsd = TRUE,   bias.correct = TRUE,   apply.epsilon = FALSE,   intern = FALSE )"},{"path":"https://vast-lib.github.io/tinyVAST/reference/integrate_output.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Integration for target variable â€” integrate_output","text":"object Output tinyVAST(). newdata New data-frame independent variables used predict response, total value calculated combining across individual predictions. locations randomly drawn specified spatial domain, integrate_output applies midpoint integration approximate total area.  locations drawn sysmatically domain, integrate_output applying midpoint approximation integral. area vector values used area-weighted expansion estimated density surface row newdata length nrow(newdata). type Integer-vector indicating type expansion apply row newdata, length nrow(newdata). type=1 Area-weighting: weight predictor argument area type=2 Abundance-weighted covariate: weight covariate proportion total row newdata type=3 Abundance-weighted variable: weight predictor proportion total prior row newdata. option used weight prediction one category based predicted proportional density another category, e.g., calculate abundance-weighted condition bivariate model. type=4 Abundance-expanded variable: weight predictor density prior row newdata. option used weight prediction one category based predicted density another category, e.g., calculate abundance-expanded consumption bivariate model. type=0 Exclude weighting: give weight zero given row newdata. Including row newdata type=0 useful, e.g., calculating abundance location, eventual index uses abundance weighting term without otherwise using predicted density calculating total value. weighting_index integer-vector used indicate previous row used calculate weighted average applied given row newdata. used type=3. covariate numeric-vector used provide covariate used expansion, e.g., provide positional coordinates calculating abundance-weighted centroid respect coordinate. used type=2. getsd logical indicating whether get standard error, getsd=FALSE faster initial exploration bias.correct logical indicating bias correction applied using standard methods TMB::sdreport() apply.epsilon Apply epsilon bias correction using manual calculation rather using conventional method TMB::sdreport? See details information. intern Laplace approximation C++ side? Passed TMB::MakeADFun().","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/integrate_output.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Integration for target variable â€” integrate_output","text":"vector containing plug-estimate, standard error, epsilon bias-corrected estimate available, standard error bias-corrected estimator. Depending upon settings, one NA values, function can repeatedly called get multiple estimators /statistics.","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/integrate_output.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Integration for target variable â€” integrate_output","text":"Analysts often want calculate value combining predicted response multiple locations, potentially multiple variables multivariate analysis. arises univariate model, e.g., calculating integral predicted density function, approximated using midpoint Monte Carlo approximation calculating linear predictors location newdata, applying inverse-link-trainsformation, calling predicted response mu_g.  Total abundance approximated multiplying mu_g area associated midpoint Monte Carlo approximation point (supplied argument area), summing across area-expanded values. complicated cases, analyst can use covariate calculate weighted average covariate midpoint location. example, covariate positional coordinates depth/elevation, type=2 measures shifts average habitat utilization respect covariate. Alternatively, analyst fitting multivariate model might weight one variable based another using weighting_index, e.g., calculate abundance-weighted average condition, predator-expanded stomach contents. practice, spatial integration multivariate model requires two passes rows newdata calculating total value.  following, write equations using C++ indexing conventions indexing starts 0, match way integrate_output expects indices supplied. Given inverse-link-transformed predictor \\( \\mu_g \\), function argument type \\( type_g \\) function argument area \\( a_g \\), function argument covariate \\( x_g \\), function argument weighting_index \\eqn{ h_g } function argument weighting_index \\eqn{ h_g } first pass calculates: $$ \\nu_g = \\mu_g a_g $$ total value first pass calculated : $$ \\nu^* = \\sum_{g=0}^{G-1} \\nu_g $$ second pass applies weighting, depends upon \\( type_g \\), potentially upon \\( x_g \\) \\( h_g \\). \\(type_g = 0\\) \\(\\phi_g = 0\\) \\(type_g = 1\\) \\(\\phi_g = \\nu_g\\) \\(type_g = 2\\) \\(\\phi_g = x_g \\frac{\\nu_g}{\\nu^*} \\) \\(type_g = 3\\) \\(\\phi_g = \\frac{\\nu_{h_g}}{\\nu^*} \\mu_g \\) \\(type_g = 4\\) \\(\\phi_g = \\nu_{h_g} \\mu_g \\) Finally, total value second pass calculated : $$ \\phi^* = \\sum_{g=0}^{G-1} \\phi_g $$ \\(\\phi^*\\) outputted integrate_output, along standard error potentially using epsilon bias-correction estimator correct skewness retransformation bias. Standard bias-correction using bias.correct=TRUE can slow, cases might faster apply.epsilon=TRUE intern=TRUE. However, option somewhat experimental, user might want confirm two options give identical results. Similarly, using bias.correct=TRUE still calculate standard-error, whereas using apply.epsilon=TRUE intern=TRUE .","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/logLik.tinyVAST.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract the (marginal) log-likelihood of a tinyVAST model â€” logLik.tinyVAST","title":"Extract the (marginal) log-likelihood of a tinyVAST model â€” logLik.tinyVAST","text":"Extract (marginal) log-likelihood tinyVAST model","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/logLik.tinyVAST.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract the (marginal) log-likelihood of a tinyVAST model â€” logLik.tinyVAST","text":"","code":"# S3 method for class 'tinyVAST' logLik(object, ...)"},{"path":"https://vast-lib.github.io/tinyVAST/reference/logLik.tinyVAST.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract the (marginal) log-likelihood of a tinyVAST model â€” logLik.tinyVAST","text":"object output tinyVAST ... used","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/logLik.tinyVAST.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract the (marginal) log-likelihood of a tinyVAST model â€” logLik.tinyVAST","text":"object class logLik attributes val log-likelihood df number parameters","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/make_dsem_ram.html","id":null,"dir":"Reference","previous_headings":"","what":"Make a RAM (Reticular Action Model) â€” make_dsem_ram","title":"Make a RAM (Reticular Action Model) â€” make_dsem_ram","text":"make_dsem_ram converts SEM arrow notation ram describing SEM parameters","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/make_dsem_ram.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make a RAM (Reticular Action Model) â€” make_dsem_ram","text":"","code":"make_dsem_ram(   dsem,   times,   variables,   covs = NULL,   quiet = FALSE,   remove_na = TRUE )"},{"path":"https://vast-lib.github.io/tinyVAST/reference/make_dsem_ram.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make a RAM (Reticular Action Model) â€” make_dsem_ram","text":"dsem dynamic structural equation model structure, passed either specifyModel specifyEquations parsed control set path coefficients variance-covariance parameters times character vector listing set times order variables character vector listing set variables covs optional: character vector one elements, element   \tgiving string variable names, separated commas. Variances covariances   \tamong variables string added model. confirmatory   \tfactor analysis models specified via cfa, covs defaults   \tfactors model, thus specifying variances covariances among factors.   \tWarning: covs=\"x1, x2\" covs=c(\"x1\", \"x2\")   \tequivalent: covs=\"x1, x2\" specifies variance x1, variance   \tx2, covariance, covs=c(\"x1\", \"x2\") specifies   \tvariance x1 variance x2 covariance. quiet Boolean indicating whether print messages terminal remove_na Boolean indicating whether remove NA values RAM (default) . remove_NA=FALSE might useful exploration diagnostics advanced users","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/make_dsem_ram.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make a RAM (Reticular Action Model) â€” make_dsem_ram","text":"reticular action module (RAM) describing dependencies","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/make_dsem_ram.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Make a RAM (Reticular Action Model) â€” make_dsem_ram","text":"RAM specification using arrow--lag notation line RAM specification make_dsem_ram consists four (unquoted) entries, separated commas: 1. Arrow specification: simple formula, form -> B , equivalently, B <- regression coefficient (.e., single-headed directional arrow); <-> variance <-> B covariance (.e., double-headed bidirectional arrow). , B variable names model. name correspond observed variable, assumed latent variable. Spaces can appear freely arrow specification, can number hyphens arrows, including zero: Thus, e.g., ->B, --> B, >B legitimate equivalent. 2. Lag (using positive values): integer specifying whether linkage simultaneous (lag=0) lagged (e.g., X -> Y, 1, XtoY indicates X time T affects Y time T+1), one-headed arrows can lagged. Using positive values indicate lags matches notational convention used package dynlm. 3. Parameter name: name regression coefficient, variance, covariance specified arrow. Assigning name two arrows results equality constraint. Specifying parameter name NA produces fixed parameter. 4. Value: start value free parameter value fixed parameter. given NA (simply omitted), model provide default starting value. Lines may end comment following #. function extends code copied package sem licence GPL (>= 2) permission John Fox. Simultaneous autoregressive process simultaneous lagged effects text specifies linkages multivariate time-series model variables \\(\\mathbf X\\) dimensions \\(T \\times C\\) \\(T\\) times \\(C\\) variables. make_dsem_ram parses text build path matrix \\(\\mathbf P\\) dimensions \\(TC \\times TC\\), \\(\\rho_{k_2,k_1}\\) represents impact \\(x_{t_1,c_1}\\) \\(x_{t_2,c_2}\\), \\(k_1=T c_1+t_1\\) \\(k_2=T c_2+t_2\\).  path matrix defines simultaneous equation $$ \\mathrm{vec}(\\mathbf X) = \\mathbf P \\mathrm{vec}(\\mathbf X) + \\mathrm{vec}(\\mathbf \\Delta)$$ \\(\\mathbf \\Delta\\) matrix exogenous errors covariance \\(\\mathbf{V = \\Gamma \\Gamma}^t\\), \\(\\mathbf \\Gamma\\) Cholesky exogenous covariance.  simultaneous autoregressive (SAR) process results \\(\\mathbf X\\) covariance: $$ \\mathrm{Cov}(\\mathbf X) = \\mathbf{(- P)}^{-1} \\mathbf{\\Gamma \\Gamma}^t \\mathbf{((- P)}^{-1})^t $$ Usefully, also easy compute inverse-covariance (precision) matrix \\(\\mathbf{Q = V}^{-1}\\): $$ \\mathbf{Q} = (\\mathbf{\\Gamma}^{-1} \\mathbf{(- P)})^t \\mathbf{\\Gamma}^{-1} \\mathbf{(- P)} $$ Example: univariate first-order autoregressive model simultaneous autoregressive (SAR) process across variables times allows user specify simultaneous effects (effects among variables within year \\(T\\)) lagged effects (effects among variables among years \\(T\\)). one example, consider univariate first-order autoregressive process \\(T=4\\). independent errors.  specified passing  dsem = X -> X, 1, rho; X <-> X, 0, sigma  make_dsem_ram. parsed RAM: Rows RAM heads=1 interpreted construct path matrix \\(\\mathbf P\\):   rows heads=2 interpreted construct Cholesky exogenous covariance \\(\\mathbf \\Gamma\\):   two estimated parameters \\(\\mathbf \\beta = (\\rho, \\sigma) \\). results covariance:   Similarly, arrow--lag notation can used specify SAR representing conventional structural equation model (SEM), cross-lagged (.k.. vector autoregressive) models (VAR), dynamic factor analysis (DFA), many time-series models.","code":"\\deqn{ \\mathbf P = \\begin{bmatrix}     0 & 0 & 0 & 0 \\     \\rho & 0 & 0 & 0 \\     0 & \\rho & 0 & 0 \\     0 & 0 & \\rho & 0\\     \\end{bmatrix} } \\deqn{ \\mathbf \\Gamma = \\begin{bmatrix}     \\sigma & 0 & 0 & 0 \\     0 & \\sigma & 0 & 0 \\     0 & 0 & \\sigma & 0 \\     0 & 0 & 0 & \\sigma\\     \\end{bmatrix} } \\deqn{ \\mathrm{Cov}(\\mathbf X) = \\sigma^2 \\begin{bmatrix}     1 & \\rho^1 & \\rho^2 & \\rho^3 \\     \\rho^1 & 1 & \\rho^1 & \\rho^2 \\     \\rho^2 & \\rho^1 & 1 & \\rho^1 \\     \\rho^3 & \\rho^2 & \\rho^1 & 1\\     \\end{bmatrix} }"},{"path":"https://vast-lib.github.io/tinyVAST/reference/make_dsem_ram.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Make a RAM (Reticular Action Model) â€” make_dsem_ram","text":"","code":"# Univariate AR1 dsem = \"   X -> X, 1, rho   X <-> X, 0, sigma \" make_dsem_ram( dsem=dsem, variables=\"X\", times=1:4 ) #> $model #>      path      lag name    start parameter first second direction #> [1,] \"X->X\"    \"1\" \"rho\"   NA    \"1\"       \"X\"   \"X\"    \"1\"       #> [2,] \"X <-> X\" \"0\" \"sigma\" NA    \"2\"       \"X\"   \"X\"    \"2\"       #>  #> $ram #>   heads to from parameter start #> 1     1  2    1         1  <NA> #> 2     1  3    2         1  <NA> #> 3     1  4    3         1  <NA> #> 5     2  1    1         2  <NA> #> 6     2  2    2         2  <NA> #> 7     2  3    3         2  <NA> #> 8     2  4    4         2  <NA> #>  #> attr(,\"class\") #> [1] \"dsem_ram\"  # Univariate AR2 dsem = \"   X -> X, 1, rho1   X -> X, 2, rho2   X <-> X, 0, sigma \" make_dsem_ram( dsem=dsem, variables=\"X\", times=1:4 ) #> $model #>      path      lag name    start parameter first second direction #> [1,] \"X->X\"    \"1\" \"rho1\"  NA    \"1\"       \"X\"   \"X\"    \"1\"       #> [2,] \"X->X\"    \"2\" \"rho2\"  NA    \"2\"       \"X\"   \"X\"    \"1\"       #> [3,] \"X <-> X\" \"0\" \"sigma\" NA    \"3\"       \"X\"   \"X\"    \"2\"       #>  #> $ram #>    heads to from parameter start #> 1      1  2    1         1  <NA> #> 2      1  3    2         1  <NA> #> 3      1  4    3         1  <NA> #> 5      1  3    1         2  <NA> #> 6      1  4    2         2  <NA> #> 9      2  1    1         3  <NA> #> 10     2  2    2         3  <NA> #> 11     2  3    3         3  <NA> #> 12     2  4    4         3  <NA> #>  #> attr(,\"class\") #> [1] \"dsem_ram\"  # Bivariate VAR dsem = \"   X -> X, 1, XtoX   X -> Y, 1, XtoY   Y -> X, 1, YtoX   Y -> Y, 1, YtoY   X <-> X, 0, sdX   Y <-> Y, 0, sdY \" make_dsem_ram( dsem=dsem, variables=c(\"X\",\"Y\"), times=1:4 ) #> $model #>      path      lag name   start parameter first second direction #> [1,] \"X->X\"    \"1\" \"XtoX\" NA    \"1\"       \"X\"   \"X\"    \"1\"       #> [2,] \"X->Y\"    \"1\" \"XtoY\" NA    \"2\"       \"X\"   \"Y\"    \"1\"       #> [3,] \"Y->X\"    \"1\" \"YtoX\" NA    \"3\"       \"Y\"   \"X\"    \"1\"       #> [4,] \"Y->Y\"    \"1\" \"YtoY\" NA    \"4\"       \"Y\"   \"Y\"    \"1\"       #> [5,] \"X <-> X\" \"0\" \"sdX\"  NA    \"5\"       \"X\"   \"X\"    \"2\"       #> [6,] \"Y <-> Y\" \"0\" \"sdY\"  NA    \"6\"       \"Y\"   \"Y\"    \"2\"       #>  #> $ram #>    heads to from parameter start #> 1      1  2    1         1  <NA> #> 2      1  3    2         1  <NA> #> 3      1  4    3         1  <NA> #> 5      1  6    1         2  <NA> #> 6      1  7    2         2  <NA> #> 7      1  8    3         2  <NA> #> 9      1  2    5         3  <NA> #> 10     1  3    6         3  <NA> #> 11     1  4    7         3  <NA> #> 13     1  6    5         4  <NA> #> 14     1  7    6         4  <NA> #> 15     1  8    7         4  <NA> #> 17     2  1    1         5  <NA> #> 18     2  2    2         5  <NA> #> 19     2  3    3         5  <NA> #> 20     2  4    4         5  <NA> #> 21     2  5    5         6  <NA> #> 22     2  6    6         6  <NA> #> 23     2  7    7         6  <NA> #> 24     2  8    8         6  <NA> #>  #> attr(,\"class\") #> [1] \"dsem_ram\"  # Dynamic factor analysis with one factor and two manifest variables # (specifies a random-walk for the factor, and miniscule residual SD) dsem = \"   factor -> X, 0, loadings1   factor -> Y, 0, loadings2   factor -> factor, 1, NA, 1   X <-> X, 0, NA, 0           # No additional variance   Y <-> Y, 0, NA, 0           # No additional variance \" make_dsem_ram( dsem=dsem, variables=c(\"X\",\"Y\",\"factor\"), times=1:4 ) #> NOTE: adding 1 variances to the model #> $model #>                                              parameter first    second   #> [1,] \"factor->X\"         \"0\" \"loadings1\" NA  \"1\"       \"factor\" \"X\"      #> [2,] \"factor->Y\"         \"0\" \"loadings2\" NA  \"2\"       \"factor\" \"Y\"      #> [3,] \"factor->factor\"    \"1\" NA          \"1\" \"0\"       \"factor\" \"factor\" #> [4,] \"X <-> X\"           \"0\" NA          \"0\" \"0\"       \"X\"      \"X\"      #> [5,] \"Y <-> Y\"           \"0\" NA          \"0\" \"0\"       \"Y\"      \"Y\"      #> [6,] \"factor <-> factor\" \"0\" \"V[factor]\" NA  \"3\"       \"factor\" \"factor\" #>      direction #> [1,] \"1\"       #> [2,] \"1\"       #> [3,] \"1\"       #> [4,] \"2\"       #> [5,] \"2\"       #> [6,] \"2\"       #>  #> $ram #>    heads to from parameter start #> 1      1  1    9         1  <NA> #> 2      1  2   10         1  <NA> #> 3      1  3   11         1  <NA> #> 4      1  4   12         1  <NA> #> 5      1  5    9         2  <NA> #> 6      1  6   10         2  <NA> #> 7      1  7   11         2  <NA> #> 8      1  8   12         2  <NA> #> 9      1 10    9         0     1 #> 10     1 11   10         0     1 #> 11     1 12   11         0     1 #> 13     2  1    1         0     0 #> 14     2  2    2         0     0 #> 15     2  3    3         0     0 #> 16     2  4    4         0     0 #> 17     2  5    5         0     0 #> 18     2  6    6         0     0 #> 19     2  7    7         0     0 #> 20     2  8    8         0     0 #> 21     2  9    9         3  <NA> #> 22     2 10   10         3  <NA> #> 23     2 11   11         3  <NA> #> 24     2 12   12         3  <NA> #>  #> attr(,\"class\") #> [1] \"dsem_ram\"  # ARIMA(1,1,0) dsem = \"   factor -> factor, 1, rho1 # AR1 component   X -> X, 1, NA, 1          # Integrated component   factor -> X, 0, NA, 1   X <-> X, 0, NA, 0         # No additional variance \" make_dsem_ram( dsem=dsem, variables=c(\"X\",\"factor\"), times=1:4 ) #> NOTE: adding 1 variances to the model #> $model #>                                              parameter first    second   #> [1,] \"factor->factor\"    \"1\" \"rho1\"      NA  \"1\"       \"factor\" \"factor\" #> [2,] \"X->X\"              \"1\" NA          \"1\" \"0\"       \"X\"      \"X\"      #> [3,] \"factor->X\"         \"0\" NA          \"1\" \"0\"       \"factor\" \"X\"      #> [4,] \"X <-> X\"           \"0\" NA          \"0\" \"0\"       \"X\"      \"X\"      #> [5,] \"factor <-> factor\" \"0\" \"V[factor]\" NA  \"2\"       \"factor\" \"factor\" #>      direction #> [1,] \"1\"       #> [2,] \"1\"       #> [3,] \"1\"       #> [4,] \"2\"       #> [5,] \"2\"       #>  #> $ram #>    heads to from parameter start #> 1      1  6    5         1  <NA> #> 2      1  7    6         1  <NA> #> 3      1  8    7         1  <NA> #> 5      1  2    1         0     1 #> 6      1  3    2         0     1 #> 7      1  4    3         0     1 #> 9      1  1    5         0     1 #> 10     1  2    6         0     1 #> 11     1  3    7         0     1 #> 12     1  4    8         0     1 #> 13     2  1    1         0     0 #> 14     2  2    2         0     0 #> 15     2  3    3         0     0 #> 16     2  4    4         0     0 #> 17     2  5    5         2  <NA> #> 18     2  6    6         2  <NA> #> 19     2  7    7         2  <NA> #> 20     2  8    8         2  <NA> #>  #> attr(,\"class\") #> [1] \"dsem_ram\"  # ARIMA(0,0,1) dsem = \"   factor -> X, 0, NA, 1   factor -> X, 1, rho1     # MA1 component   X <-> X, 0, NA, 0        # No additional variance \" make_dsem_ram( dsem=dsem, variables=c(\"X\",\"factor\"), times=1:4 ) #> NOTE: adding 1 variances to the model #> $model #>                                              parameter first    second   #> [1,] \"factor->X\"         \"0\" NA          \"1\" \"0\"       \"factor\" \"X\"      #> [2,] \"factor->X\"         \"1\" \"rho1\"      NA  \"1\"       \"factor\" \"X\"      #> [3,] \"X <-> X\"           \"0\" NA          \"0\" \"0\"       \"X\"      \"X\"      #> [4,] \"factor <-> factor\" \"0\" \"V[factor]\" NA  \"2\"       \"factor\" \"factor\" #>      direction #> [1,] \"1\"       #> [2,] \"1\"       #> [3,] \"2\"       #> [4,] \"2\"       #>  #> $ram #>    heads to from parameter start #> 1      1  1    5         0     1 #> 2      1  2    6         0     1 #> 3      1  3    7         0     1 #> 4      1  4    8         0     1 #> 5      1  2    5         1  <NA> #> 6      1  3    6         1  <NA> #> 7      1  4    7         1  <NA> #> 9      2  1    1         0     0 #> 10     2  2    2         0     0 #> 11     2  3    3         0     0 #> 12     2  4    4         0     0 #> 13     2  5    5         2  <NA> #> 14     2  6    6         2  <NA> #> 15     2  7    7         2  <NA> #> 16     2  8    8         2  <NA> #>  #> attr(,\"class\") #> [1] \"dsem_ram\""},{"path":"https://vast-lib.github.io/tinyVAST/reference/make_eof_ram.html","id":null,"dir":"Reference","previous_headings":"","what":"Make a RAM (Reticular Action Model) â€” make_eof_ram","title":"Make a RAM (Reticular Action Model) â€” make_eof_ram","text":"make_eof_ram converts SEM arrow notation ram describing SEM parameters","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/make_eof_ram.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make a RAM (Reticular Action Model) â€” make_eof_ram","text":"","code":"make_eof_ram(   times,   variables,   n_eof,   remove_na = TRUE,   standard_deviations = \"unequal\" )"},{"path":"https://vast-lib.github.io/tinyVAST/reference/make_eof_ram.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make a RAM (Reticular Action Model) â€” make_eof_ram","text":"times character vector listing set times order variables character vector listing set variables n_eof Number EOF modes variability estimate remove_na Boolean indicating whether remove NA values RAM (default) . remove_NA=FALSE might useful exploration diagnostics advanced users standard_deviations One \"equal\", \"unequal\", numeric vector indicating fixed values.","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/make_eof_ram.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make a RAM (Reticular Action Model) â€” make_eof_ram","text":"reticular action module (RAM) describing dependencies","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/make_eof_ram.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Make a RAM (Reticular Action Model) â€” make_eof_ram","text":"","code":"# Two EOFs for two variables make_eof_ram( times = 2010:2020, variables = c(\"pollock\",\"cod\"), n_eof=2 ) #> $model #>      to  from parameter #> 1  2010 EOF_1         1 #> 2  2011 EOF_1         2 #> 3  2012 EOF_1         3 #> 4  2013 EOF_1         4 #> 5  2014 EOF_1         5 #> 6  2015 EOF_1         6 #> 7  2016 EOF_1         7 #> 8  2017 EOF_1         8 #> 9  2018 EOF_1         9 #> 10 2019 EOF_1        10 #> 11 2020 EOF_1        11 #> 12 2010 EOF_2        NA #> 13 2011 EOF_2        12 #> 14 2012 EOF_2        13 #> 15 2013 EOF_2        14 #> 16 2014 EOF_2        15 #> 17 2015 EOF_2        16 #> 18 2016 EOF_2        17 #> 19 2017 EOF_2        18 #> 20 2018 EOF_2        19 #> 21 2019 EOF_2        20 #> 22 2020 EOF_2        21 #>  #> $ram #>       heads to from parameter start #>  [1,]     1  3    1         1  0.01 #>  [2,]     1  4    1         2  0.01 #>  [3,]     1  5    1         3  0.01 #>  [4,]     1  6    1         4  0.01 #>  [5,]     1  7    1         5  0.01 #>  [6,]     1  8    1         6  0.01 #>  [7,]     1  9    1         7  0.01 #>  [8,]     1 10    1         8  0.01 #>  [9,]     1 11    1         9  0.01 #> [10,]     1 12    1        10  0.01 #> [11,]     1 13    1        11  0.01 #> [12,]     1  4    2        12  0.01 #> [13,]     1  5    2        13  0.01 #> [14,]     1  6    2        14  0.01 #> [15,]     1  7    2        15  0.01 #> [16,]     1  8    2        16  0.01 #> [17,]     1  9    2        17  0.01 #> [18,]     1 10    2        18  0.01 #> [19,]     1 11    2        19  0.01 #> [20,]     1 12    2        20  0.01 #> [21,]     1 13    2        21  0.01 #> [22,]     1 16   14         1  0.01 #> [23,]     1 17   14         2  0.01 #> [24,]     1 18   14         3  0.01 #> [25,]     1 19   14         4  0.01 #> [26,]     1 20   14         5  0.01 #> [27,]     1 21   14         6  0.01 #> [28,]     1 22   14         7  0.01 #> [29,]     1 23   14         8  0.01 #> [30,]     1 24   14         9  0.01 #> [31,]     1 25   14        10  0.01 #> [32,]     1 26   14        11  0.01 #> [33,]     1 17   15        12  0.01 #> [34,]     1 18   15        13  0.01 #> [35,]     1 19   15        14  0.01 #> [36,]     1 20   15        15  0.01 #> [37,]     1 21   15        16  0.01 #> [38,]     1 22   15        17  0.01 #> [39,]     1 23   15        18  0.01 #> [40,]     1 24   15        19  0.01 #> [41,]     1 25   15        20  0.01 #> [42,]     1 26   15        21  0.01 #> [43,]     2  1    1         0  1.00 #> [44,]     2  2    2         0  1.00 #> [45,]     2  3    3        22    NA #> [46,]     2  4    4        22    NA #> [47,]     2  5    5        22    NA #> [48,]     2  6    6        22    NA #> [49,]     2  7    7        22    NA #> [50,]     2  8    8        22    NA #> [51,]     2  9    9        22    NA #> [52,]     2 10   10        22    NA #> [53,]     2 11   11        22    NA #> [54,]     2 12   12        22    NA #> [55,]     2 13   13        22    NA #> [56,]     2 14   14         0  1.00 #> [57,]     2 15   15         0  1.00 #> [58,]     2 16   16        23    NA #> [59,]     2 17   17        23    NA #> [60,]     2 18   18        23    NA #> [61,]     2 19   19        23    NA #> [62,]     2 20   20        23    NA #> [63,]     2 21   21        23    NA #> [64,]     2 22   22        23    NA #> [65,]     2 23   23        23    NA #> [66,]     2 24   24        23    NA #> [67,]     2 25   25        23    NA #> [68,]     2 26   26        23    NA #>  #> $variances #>        to    from parameter #> 1   EOF_1   EOF_1         0 #> 2   EOF_2   EOF_2         0 #> 3 pollock pollock        22 #> 4     cod     cod        23 #>  #> $standard_deviations #> [1] \"unequal\" #>  #> attr(,\"class\") #> [1] \"eof_ram\""},{"path":"https://vast-lib.github.io/tinyVAST/reference/make_sem_ram.html","id":null,"dir":"Reference","previous_headings":"","what":"Make a RAM (Reticular Action Model) from a SEM (structural equation model) â€” make_sem_ram","title":"Make a RAM (Reticular Action Model) from a SEM (structural equation model) â€” make_sem_ram","text":"make_sem_ram converts SEM arrow notation ram describing SEM parameters","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/make_sem_ram.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make a RAM (Reticular Action Model) from a SEM (structural equation model) â€” make_sem_ram","text":"","code":"make_sem_ram(sem, variables, quiet = FALSE, covs = variables)"},{"path":"https://vast-lib.github.io/tinyVAST/reference/make_sem_ram.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make a RAM (Reticular Action Model) from a SEM (structural equation model) â€” make_sem_ram","text":"sem structural equation model structure, passed either specifyModel specifyEquations parsed control set path coefficients variance-covariance parameters variables character vector listing set variables quiet FALSE, default, number input lines reported     message printed suggesting specifyEquations cfa used. covs optional: character vector one elements, element   \tgiving string variable names, separated commas. Variances covariances   \tamong variables string added model. confirmatory   \tfactor analysis models specified via cfa, covs defaults   \tfactors model, thus specifying variances covariances among factors.   \tWarning: covs=\"x1, x2\" covs=c(\"x1\", \"x2\")   \tequivalent: covs=\"x1, x2\" specifies variance x1, variance   \tx2, covariance, covs=c(\"x1\", \"x2\") specifies   \tvariance x1 variance x2 covariance.","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/make_sem_ram.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make a RAM (Reticular Action Model) from a SEM (structural equation model) â€” make_sem_ram","text":"S3-class \"sem_ram\" containing: model Output specifyEquations specifyModel defines paths parameters ram reticular action module (RAM) describing dependencies","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/parse_path.html","id":null,"dir":"Reference","previous_headings":"","what":"Parse path â€” parse_path","title":"Parse path â€” parse_path","text":"parse_path copied sem::parse.path","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/parse_path.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parse path â€” parse_path","text":"","code":"parse_path(path)"},{"path":"https://vast-lib.github.io/tinyVAST/reference/parse_path.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parse path â€” parse_path","text":"path character string indicating one-headed two-headed path structural equation model","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/parse_path.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parse path â€” parse_path","text":"Tagged-list defining variables direction specified path coefficient","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/parse_path.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Parse path â€” parse_path","text":"Copied package sem licence GPL (>= 2) permission John Fox","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/predict.tinyVAST.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict using vector autoregressive spatio-temporal model â€” predict.tinyVAST","title":"Predict using vector autoregressive spatio-temporal model â€” predict.tinyVAST","text":"Predicts values given new covariates using tinyVAST model","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/predict.tinyVAST.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict using vector autoregressive spatio-temporal model â€” predict.tinyVAST","text":"","code":"# S3 method for class 'tinyVAST' predict(   object,   newdata,   remove_origdata = FALSE,   what = c(\"mu_g\", \"p_g\", \"p1_g\", \"palpha1_g\", \"pgamma1_g\", \"pepsilon1_g\", \"pomega1_g\",     \"pdelta1_g\", \"pxi1_g\", \"p2_g\", \"palpha2_g\", \"pgamma2_g\", \"pepsilon2_g\", \"pomega2_g\",     \"pdelta2_g\", \"pxi2_g\"),   se.fit = FALSE,   bias.correct = FALSE,   ... )"},{"path":"https://vast-lib.github.io/tinyVAST/reference/predict.tinyVAST.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict using vector autoregressive spatio-temporal model â€” predict.tinyVAST","text":"object Output tinyVAST(). newdata New data-frame independent variables used predict response. remove_origdata Whether eliminate original data TMB object, thereby speeding TMB object construction.  However, also eliminates information random-effect variance, appropriate requesting predictive standard errors epsilon bias-correction. REPORTed object output, mu_g inverse-linked transformed predictor including linear components, p_g sum first second linear predictors (makes sense inspect using Poisson-linked delta model), p1_g first linear predictor, palpha_g first predictor fixed covariates formula, pgamma_g first predictor random covariates formula (e.g., splines), pomega_g first predictor spatial variation, pepsilon_g first predictor spatio-temporal variation, pxi_g first predictor spatially varying coefficients, p2_g second linear predictor, palpha2_g second predictor fixed covariates formula, pgamma2_g second predictor random covariates formula (e.g., splines), pomega2_g second predictor spatial variation, pepsilon2_g second predictor spatio-temporal variation, pxi2_g second predictor spatially varying coefficients. se.fit Calculate standard errors? bias.correct whether epsilon bias-correct predicted value ... used.","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/predict.tinyVAST.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predict using vector autoregressive spatio-temporal model â€” predict.tinyVAST","text":"Either vector prediction row newdata, named list prediction standard error (se.fit = TRUE).","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/print.tinyVAST.html","id":null,"dir":"Reference","previous_headings":"","what":"print summary of tinyVAST model â€” print.tinyVAST","title":"print summary of tinyVAST model â€” print.tinyVAST","text":"print summary tinyVAST model","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/print.tinyVAST.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"print summary of tinyVAST model â€” print.tinyVAST","text":"","code":"# S3 method for class 'tinyVAST' print(x, ...)"},{"path":"https://vast-lib.github.io/tinyVAST/reference/print.tinyVAST.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"print summary of tinyVAST model â€” print.tinyVAST","text":"x output tinyVAST ... used","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/print.tinyVAST.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"print summary of tinyVAST model â€” print.tinyVAST","text":"invisibly returns named list key model outputs summary statements","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/project.html","id":null,"dir":"Reference","previous_headings":"","what":"Project tinyVAST to future times (EXPERIMENTAL) â€” project","title":"Project tinyVAST to future times (EXPERIMENTAL) â€” project","text":"Projects fitted model forward time.","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/project.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Project tinyVAST to future times (EXPERIMENTAL) â€” project","text":"","code":"project(   object,   extra_times,   newdata,   what = \"mu_g\",   future_var = TRUE,   past_var = FALSE,   parm_var = FALSE )"},{"path":"https://vast-lib.github.io/tinyVAST/reference/project.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Project tinyVAST to future times (EXPERIMENTAL) â€” project","text":"object fitted model tinyVAST(.) extra_times vector extra times, matching values newdata newdata data frame including new values time_variable REPORTed object output, mu_g inverse-linked transformed predictor including linear components, p_g sum first second linear predictors (makes sense inspect using Poisson-linked delta model), p1_g first linear predictor, palpha_g first predictor fixed covariates formula, pgamma_g first predictor random covariates formula (e.g., splines), pomega_g first predictor spatial variation, pepsilon_g first predictor spatio-temporal variation, pxi_g first predictor spatially varying coefficients, p2_g second linear predictor, palpha2_g second predictor fixed covariates formula, pgamma2_g second predictor random covariates formula (e.g., splines), pomega2_g second predictor spatial variation, pepsilon2_g second predictor spatio-temporal variation, pxi2_g second predictor spatially varying coefficients. future_var logical indicating whether simulate future process errors GMRFs, just compute predictive mean past_var logical indicating whether re-simulate past process errors predictive distribution random effects, thus changing boundary condition forecast parm_var logical indicating whether re-sample fixed effects predictive distribution, thus changing GMRF future process errors","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/project.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Project tinyVAST to future times (EXPERIMENTAL) â€” project","text":"vector values corresponding rows newdata","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/project.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Project tinyVAST to future times (EXPERIMENTAL) â€” project","text":"","code":"# Convert to long-form set.seed(123) n_obs = 100 rho = 0.9 sigma_x = 0.2 sigma_y = 0.1 x = rnorm(n_obs, mean=0, sd = sigma_x) for(i in 2:length(x)) x[i] = rho * x[i-1] + x[i] y = x + rnorm( length(x), mean = 0, sd = sigma_y ) data = data.frame( \"val\" = y, \"var\" = \"y\", \"time\" = seq_along(y) )  # Define AR2 time_term time_term = \"   y -> y, 1, rho1   y -> y, 2, rho2   y <-> y, 0, sd \"  # fit model mytiny = tinyVAST(   time_term = time_term,   data = data,   times = unique(data$t),   variables = \"y\",   formula = val ~ 1,   control = tinyVASTcontrol( getJointPrecision = TRUE ) )  # Deterministic projection extra_times = length(x) + 1:100 n_sims = 10 newdata = data.frame( \"time\" = c(seq_along(x),extra_times), \"var\" = \"y\" ) Y = project(   mytiny,   newdata = newdata,   extra_times = extra_times,   future_var = FALSE ) #> Error: object does not inherit from class sdmTMB plot( x = seq_along(Y),       y = Y,       type = \"l\", lty = \"solid\", col = \"black\" ) #> Error: object 'Y' not found  # Stochastic projection with future process errors if (FALSE) { # \\dontrun{ extra_times = length(x) + 1:100 n_sims = 10 newdata = data.frame( \"time\" = c(seq_along(x),extra_times), \"var\" = \"y\" ) Y = NULL for(i in seq_len(n_sims) ){   tmp = project(     mytiny,     newdata = newdata,     extra_times = extra_times,     future_var = TRUE,     past_var = TRUE,     parm_var = TRUE   )   Y = cbind(Y, tmp) } matplot( x = row(Y),          y = Y,          type = \"l\", lty = \"solid\", col = \"black\" ) } # }"},{"path":"https://vast-lib.github.io/tinyVAST/reference/red_grouper_diet.html","id":null,"dir":"Reference","previous_headings":"","what":"Data to demonstrate model-based diet proportions â€” red_grouper_diet","title":"Data to demonstrate model-based diet proportions â€” red_grouper_diet","text":"Data estimate predator-expanded stomach contents (PESC), .e., multi-prey single-predator model stomach contents red grouper Gulf Mexico also estimates biomass density red grouper. Diet proportions product predicted diet proportions prey specific consumption, normalized across prey categories. Copied VAST data set PESC_example_red_grouper","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/red_grouper_diet.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Data to demonstrate model-based diet proportions â€” red_grouper_diet","text":"","code":"data(red_grouper_diet)"},{"path":"https://vast-lib.github.io/tinyVAST/reference/red_snapper.html","id":null,"dir":"Reference","previous_headings":"","what":"Presence/absence, count, and biomass data for red snapper â€” red_snapper","title":"Presence/absence, count, and biomass data for red snapper â€” red_snapper","text":"Data used demonstrate test analysis using multiple data types","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/red_snapper.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Presence/absence, count, and biomass data for red snapper â€” red_snapper","text":"","code":"data(red_snapper)"},{"path":"https://vast-lib.github.io/tinyVAST/reference/red_snapper_shapefile.html","id":null,"dir":"Reference","previous_headings":"","what":"Shapefile for red snapper analysis â€” red_snapper_shapefile","title":"Shapefile for red snapper analysis â€” red_snapper_shapefile","text":"Spatial extent used red snapper analysis, derived Chap-7 doi:10.1201/9781003410294","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/red_snapper_shapefile.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Shapefile for red snapper analysis â€” red_snapper_shapefile","text":"","code":"data(red_snapper_shapefile)"},{"path":"https://vast-lib.github.io/tinyVAST/reference/reexports.html","id":null,"dir":"Reference","previous_headings":"","what":"Objects exported from other packages â€” reexports","title":"Objects exported from other packages â€” reexports","text":"objects imported packages. Follow links see documentation. sdmTMB lognormal, nbinom1, nbinom2, tweedie","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/reload_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Reload a previously fitted model â€” reload_model","title":"Reload a previously fitted model â€” reload_model","text":"reload_model allows user save fitted model, reload new R terminal, relink DLLs functions expected.","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/reload_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reload a previously fitted model â€” reload_model","text":"","code":"reload_model(x, check_gradient = TRUE)"},{"path":"https://vast-lib.github.io/tinyVAST/reference/reload_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reload a previously fitted model â€” reload_model","text":"x Output tinyVAST, potentially DLLs linked check_gradient Whether check gradients reloaded model","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/reload_model.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reload a previously fitted model â€” reload_model","text":"Output tinyVAST DLLs relinked","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/residuals.tinyVAST.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate deviance or response residuals for tinyVAST â€” residuals.tinyVAST","title":"Calculate deviance or response residuals for tinyVAST â€” residuals.tinyVAST","text":"Calculate residuals","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/residuals.tinyVAST.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate deviance or response residuals for tinyVAST â€” residuals.tinyVAST","text":"","code":"# S3 method for class 'tinyVAST' residuals(object, type = c(\"deviance\", \"response\"), ...)"},{"path":"https://vast-lib.github.io/tinyVAST/reference/residuals.tinyVAST.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate deviance or response residuals for tinyVAST â€” residuals.tinyVAST","text":"object Output tinyVAST() type type residuals compute (option \"deviance\" \"response\" now) ... Note used","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/residuals.tinyVAST.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate deviance or response residuals for tinyVAST â€” residuals.tinyVAST","text":"vector residuals, associated row data supplied fitting","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/rmvnorm_prec.html","id":null,"dir":"Reference","previous_headings":"","what":"Multivariate Normal Random Deviates using Sparse Precision â€” rmvnorm_prec","title":"Multivariate Normal Random Deviates using Sparse Precision â€” rmvnorm_prec","text":"function provides random number generator multivariate normal distribution mean equal mu sparse precision matrix prec.","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/rmvnorm_prec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Multivariate Normal Random Deviates using Sparse Precision â€” rmvnorm_prec","text":"","code":"rmvnorm_prec(prec, n = 1, mu = rep(0, nrow(prec)))"},{"path":"https://vast-lib.github.io/tinyVAST/reference/rmvnorm_prec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Multivariate Normal Random Deviates using Sparse Precision â€” rmvnorm_prec","text":"prec sparse precision (inverse-covariance) matrix. n number observations. mu mean vector.","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/rmvnorm_prec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Multivariate Normal Random Deviates using Sparse Precision â€” rmvnorm_prec","text":"matrix dimension length(mu) n, containing realized draws specified mean precision","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/rotate_pca.html","id":null,"dir":"Reference","previous_headings":"","what":"Rotate factors to match Principal-Components Analysis â€” rotate_pca","title":"Rotate factors to match Principal-Components Analysis â€” rotate_pca","text":"Rotate lower-triangle loadings matrix order factors largest smallest variance.","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/rotate_pca.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rotate factors to match Principal-Components Analysis â€” rotate_pca","text":"","code":"rotate_pca(   L_tf,   x_sf = matrix(0, nrow = 0, ncol = ncol(L_tf)),   order = c(\"none\", \"increasing\", \"decreasing\") )"},{"path":"https://vast-lib.github.io/tinyVAST/reference/rotate_pca.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rotate factors to match Principal-Components Analysis â€” rotate_pca","text":"L_tf Loadings matrix dimension \\(T \\times F\\). x_sf Spatial response dimensions \\(S \\times F\\). order Options resolving label-switching via reflecting factor achieve given order across dimension \\(T\\).","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/rotate_pca.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rotate factors to match Principal-Components Analysis â€” rotate_pca","text":"List containing rotated loadings L_tf, inverse-rotated response matrix x_sf, rotation H","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/salmon_returns.html","id":null,"dir":"Reference","previous_headings":"","what":"North Pacific salmon returns â€” salmon_returns","title":"North Pacific salmon returns â€” salmon_returns","text":"Data used demonstrate test multivariate second-order autoregressive models using simultaneous autoregressive (SAR) process across regions. Data doi:10.1002/mcf2.10023","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/salmon_returns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"North Pacific salmon returns â€” salmon_returns","text":"","code":"data(salmon_returns)"},{"path":"https://vast-lib.github.io/tinyVAST/reference/sample_variable.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample from predictive distribution of a variable â€” sample_variable","title":"Sample from predictive distribution of a variable â€” sample_variable","text":"sample_variable samples joint distribution random fixed effects approximate predictive distribution variable Using sample_fixed=TRUE (default) sample_variable propagates variance fixed random effects, using sample_fixed=FALSE . Sampling fixed effects sometimes cause numerical - overflow (.e., output values NA) cases variance parameters estimated imprecisely.  cases, multivariate normal approximation used poor representation tail probabilities, results samples implausibly high (negative) variances, associated random effects implausibly high magnitude.","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/sample_variable.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample from predictive distribution of a variable â€” sample_variable","text":"","code":"sample_variable(   object,   newdata = NULL,   variable_name = \"mu_i\",   n_samples = 100,   sample_fixed = TRUE,   seed = 123456 )"},{"path":"https://vast-lib.github.io/tinyVAST/reference/sample_variable.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample from predictive distribution of a variable â€” sample_variable","text":"object output \\code{tinyVAST()} newdata data frame new data, used sample model components predictions e.g., mu_g variable_name name variable available report using Obj$report() parameters using Obj$env$parList() n_samples number samples joint predictive distribution fixed random effects.  Default 100, slow. sample_fixed whether sample fixed random effects, sample_fixed=TRUE default, just sample random effects, sample_fixed=FALSE seed integer used set random-number seed sampling variables, passed set.seed(.)","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/sample_variable.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sample from predictive distribution of a variable â€” sample_variable","text":"matrix row data supplied fitting, n_samples columns, column vector samples requested quantity given sampled uncertainty fixed /random effects","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/sample_variable.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sample from predictive distribution of a variable â€” sample_variable","text":"","code":"set.seed(101)  x = runif(n = 100, min = 0, max = 2*pi)  y = 1 + sin(x) + 0.1 * rnorm(100)   # Do fit with getJointPrecision=TRUE  fit = tinyVAST( formula = y ~ s(x),                  data = data.frame(x=x,y=y) )   # samples from distribution for the mean  # excluding fixed effects due to CRAN checks  samples = sample_variable(fit, sample_fixed = FALSE) #> # Obtaining samples from predictive distribution for variable mu_i #>   Finished sample 10 of 100 #>   Finished sample 20 of 100 #>   Finished sample 30 of 100 #>   Finished sample 40 of 100 #>   Finished sample 50 of 100 #>   Finished sample 60 of 100 #>   Finished sample 70 of 100 #>   Finished sample 80 of 100 #>   Finished sample 90 of 100 #>   Finished sample 100 of 100"},{"path":"https://vast-lib.github.io/tinyVAST/reference/sea_ice.html","id":null,"dir":"Reference","previous_headings":"","what":"Arctic September sea ice concentrations â€” sea_ice","title":"Arctic September sea ice concentrations â€” sea_ice","text":"Data used demonstrate test empirical orthogonal function generalized linear latent variable model (EOF-GLLVM)","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/sea_ice.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Arctic September sea ice concentrations â€” sea_ice","text":"","code":"data(sea_ice)"},{"path":"https://vast-lib.github.io/tinyVAST/reference/sfnetwork_evaluator.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct projection matrix for stream network â€” sfnetwork_evaluator","title":"Construct projection matrix for stream network â€” sfnetwork_evaluator","text":"Make sparse matrix project stream-network nodes user-supplied points","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/sfnetwork_evaluator.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct projection matrix for stream network â€” sfnetwork_evaluator","text":"","code":"sfnetwork_evaluator(stream, loc, tolerance = 0.01)"},{"path":"https://vast-lib.github.io/tinyVAST/reference/sfnetwork_evaluator.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct projection matrix for stream network â€” sfnetwork_evaluator","text":"stream sfnetworks object representing stream network loc sf object representing points projected tolerance error-check tolerance","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/sfnetwork_evaluator.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct projection matrix for stream network â€” sfnetwork_evaluator","text":"sparse interpolation matrix, rows row data supplied fitting columns spatial random effect.","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/sfnetwork_mesh.html","id":null,"dir":"Reference","previous_headings":"","what":"Make mesh for stream network â€” sfnetwork_mesh","title":"Make mesh for stream network â€” sfnetwork_mesh","text":"make object representing spatial information required specify stream-network spatial domain, similar usage link[fmesher]{fm_mesh_2d} 2-dimensional continuous domain","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/sfnetwork_mesh.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make mesh for stream network â€” sfnetwork_mesh","text":"","code":"sfnetwork_mesh(stream)"},{"path":"https://vast-lib.github.io/tinyVAST/reference/sfnetwork_mesh.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make mesh for stream network â€” sfnetwork_mesh","text":"stream sfnetworks object representing stream network","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/sfnetwork_mesh.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make mesh for stream network â€” sfnetwork_mesh","text":"object (list) class sfnetwork_mesh. Elements include: N number random effects used represent network table table containing description parent nodes (), childen nodes (), distance separating stream copy stream network object passed argument","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/simulate.tinyVAST.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate new data from a fitted model â€” simulate.tinyVAST","title":"Simulate new data from a fitted model â€” simulate.tinyVAST","text":"simulate.tinyVAST S3 method producing matrix simulations fitted model. can used DHARMa package among uses.  Code modified version sdmTMB","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/simulate.tinyVAST.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate new data from a fitted model â€” simulate.tinyVAST","text":"","code":"# S3 method for class 'tinyVAST' simulate(   object,   nsim = 1L,   seed = sample.int(1e+06, 1L),   type = c(\"mle-eb\", \"mle-mvn\"),   ... )"},{"path":"https://vast-lib.github.io/tinyVAST/reference/simulate.tinyVAST.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate new data from a fitted model â€” simulate.tinyVAST","text":"object output tinyVAST() nsim many simulations seed random seed type parameters treated. \"mle-eb\": fixed effects maximum likelihood (MLE) estimates  random effects empirical Bayes (EB) estimates. \"mle-mvn\": fixed effects MLEs random effects taken single approximate sample. latter option suggested approach simulations used goodness fit testing (e.g., DHARMa package). ... used","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/simulate.tinyVAST.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate new data from a fitted model â€” simulate.tinyVAST","text":"matrix row row data fitted model nsim columns, containing new samples fitted model.","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/simulate.tinyVAST.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate new data from a fitted model â€” simulate.tinyVAST","text":"","code":"set.seed(101) x = seq(0, 2*pi, length=100) y = sin(x) + 0.1*rnorm(length(x)) fit = tinyVAST( data=data.frame(x=x,y=y), formula = y ~ s(x) ) sims = simulate(fit, nsim=100, type=\"mle-mvn\")  if(requireNamespace(\"DHARMa\")){   # simulate new data conditional on fixed effects   # and sampling random effects from their predictive distribution   y_iz = simulate(fit, nsim=500, type=\"mle-mvn\")    # Visualize using DHARMa   res = DHARMa::createDHARMa( simulatedResponse = y_iz,                       observedResponse = y,                       fittedPredictedResponse = fitted(fit) )   plot(res) }"},{"path":"https://vast-lib.github.io/tinyVAST/reference/simulate_sfnetwork.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate GMRF for stream network â€” simulate_sfnetwork","title":"Simulate GMRF for stream network â€” simulate_sfnetwork","text":"Simulate values GMRF using tail-(flow-unconnected) exponential model stream network","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/simulate_sfnetwork.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate GMRF for stream network â€” simulate_sfnetwork","text":"","code":"simulate_sfnetwork(sfnetwork_mesh, theta, n = 1, what = c(\"samples\", \"Q\"))"},{"path":"https://vast-lib.github.io/tinyVAST/reference/simulate_sfnetwork.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate GMRF for stream network â€” simulate_sfnetwork","text":"sfnetwork_mesh Output sfnetwork_mesh theta Decorrelation rate n number simulated GMRFs Whether return simulated GMRF precision matrix","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/simulate_sfnetwork.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate GMRF for stream network â€” simulate_sfnetwork","text":"matrix simulated values Gaussian Markov random field arising stream-network spatial domain, row spatial random effect n columns, using sparse precision matrix defined Charsley et al. (2023)","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/simulate_sfnetwork.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Simulate GMRF for stream network â€” simulate_sfnetwork","text":"Charsley, . R., Gruss, ., Thorson, J. T., Rudd, M. B., Crow, S. K., David, B., Williams, E. K., & Hoyle, S. D. (2023). Catchment-scale stream network spatio-temporal models, applied freshwater stages diadromous fish species, longfin eel (Anguilla dieffenbachii). Fisheries Research, 259, 106583. doi:10.1016/j.fishres.2022.106583","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/spatial_cor.html","id":null,"dir":"Reference","previous_headings":"","what":"Approximate spatial correlation â€” spatial_cor","title":"Approximate spatial correlation â€” spatial_cor","text":"Extract approximated spatial correlation one coordinate coordinates using sparse precision SPDE mesh","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/spatial_cor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Approximate spatial correlation â€” spatial_cor","text":"","code":"spatial_cor(Q, mesh, coord, pred)"},{"path":"https://vast-lib.github.io/tinyVAST/reference/spatial_cor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Approximate spatial correlation â€” spatial_cor","text":"Q sparse precision matrix mesh SPDE mesh coord vector length-2 spatial coordinates focal point pred matrix two columns multiple rows, location points predict correlation","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/spatial_cor.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Approximate spatial correlation â€” spatial_cor","text":"vector length nrow(pred) giving spatial correlation","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/summary.tinyVAST.html","id":null,"dir":"Reference","previous_headings":"","what":"summarize tinyVAST â€” summary.tinyVAST","title":"summarize tinyVAST â€” summary.tinyVAST","text":"summarize parameters fitted tinyVAST","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/summary.tinyVAST.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"summarize tinyVAST â€” summary.tinyVAST","text":"","code":"# S3 method for class 'tinyVAST' summary(   object,   what = c(\"space_term\", \"time_term\", \"spacetime_term\", \"fixed\"),   predictor = c(\"one\", \"two\"),   ... )"},{"path":"https://vast-lib.github.io/tinyVAST/reference/summary.tinyVAST.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"summarize tinyVAST â€” summary.tinyVAST","text":"object Output tinyVAST() component summarize, whether space_term, spacetime_term, fixed fixed effects included GAM formula predictor whether get 1st 2nd linear predictor (latter applicable delta models) ... used","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/summary.tinyVAST.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"summarize tinyVAST â€” summary.tinyVAST","text":"data-frame containing estimate (standard errors, two-sided Wald-test z-value, associated p-value standard errors available) model parameters, including fixed-effects specified via formula, path coefficients spatial SEM specified via space_term, dynamic SEM specified via time_term, spatial dynamic SEM specified via spacetime_term","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/summary.tinyVAST.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"summarize tinyVAST â€” summary.tinyVAST","text":"tinyVAST includes three components: Space-variable interaction separable Gaussian Markov random field (GMRF) constructed structural equation model (SEM) spatial variable Space-variable-time interaction separable GMRF constructed dynamic SEM (nonseparable time-variable interaction) spatial variable Additive variation generalized additive model (GAM), representing exogenous covariates summarized interpreted differently, summary.tinyVAST facilitates . Regarding DSEM componennt, tinyVAST includes \"arrow lag\" notation, specifies set path coefficients exogenous variance parameters estimated. Function tinyVAST estimates maximum likelihood value coefficients parameters maximizing log-marginal likelihood. However, many users want associate individual parameters standard errors path coefficients specified using \"arrow lag\" notation. task complicated models path coefficients variance parameters specified share single value priori, assigned name NA hence assumed fixed value priori (coefficients parameters assigned value standard error). summary function therefore compiles MLE coefficients (including duplicating values path coefficients assigned value) standard error estimates, outputs table associates user-supplied path parameter names. also outputs z-score p-value arising two-sided Wald test (.e. comparing estimate divided standard error standard normal distribution).","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/term_covariance.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract covariance â€” term_covariance","title":"Extract covariance â€” term_covariance","text":"Extract covariance resulting specified path structure estimated parameters SEM DSEM term tinyVAST","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/term_covariance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract covariance â€” term_covariance","text":"","code":"term_covariance(   object,   what = c(\"space_term\", \"time_term\", \"spacetime_term\"),   pred = c(\"one\", \"two\"),   n_times = NULL )"},{"path":"https://vast-lib.github.io/tinyVAST/reference/term_covariance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract covariance â€” term_covariance","text":"object Output tinyVAST SEM DSEM term extract pred Extract term linear predictor n_times number times include calculating covariance DSEM component, .e., time_term spacetime_term.  missing, default use one maximum specified lag (e.g., n_times=2 default maximum lag=1)","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/term_covariance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract covariance â€” term_covariance","text":"covariance matrix among variables","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/term_covariance.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extract covariance â€” term_covariance","text":"tinyVAST constructs covariance specified path structure estimated parameters","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/term_covariance.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract covariance â€” term_covariance","text":"","code":"# Extract covariance for spatial factor analysis (too slow for CRAN) # \\donttest{ # Simulate settings set.seed(101) theta_xy = 0.4 n_x = n_y = 10 n_c = 3           # Number of species n_f = 1           # Number of factors rho = 0.8 resid_sd = 0.5  # Simulate GMRFs R_s = exp(-theta_xy * abs(outer(1:n_x, 1:n_y, FUN=\"-\")) ) R_ss = kronecker(X=R_s, Y=R_s) delta_fs = mvtnorm::rmvnorm(n_c, sigma=R_ss )  # Simulate loadings for two factors L_cf = matrix( rnorm(n_c^2), nrow=n_c ) L_cf[,seq(from=n_f+1, to=n_c)] = 0 L_cf = L_cf + resid_sd * diag(n_c)  # Simulate correlated densities d_cs = L_cf %*% delta_fs  # Shape into longform data-frame and add error Data = data.frame( expand.grid(species=1:n_c, x=1:n_x, y=1:n_y),                    \"var\"=\"logn\", \"z\"=exp(as.vector(d_cs)) ) Data$n = rnorm( n=nrow(Data), mean=Data$z, sd=1 )  # make mesh mesh = fmesher::fm_mesh_2d( Data[,c('x','y')] )  # Specify factor model with two factors and additional independent variance with shared SD sem = \"   # Loadings matrix   f1 -> 1, l1   f1 -> 2, l2   f1 -> 3, l3    # Factor variance = 1   f1 <-> f1, NA, 1    # Shared residual variance   1 <-> 1, sd, 1   2 <-> 2, sd, 1   3 <-> 3, sd, 1 \"  # fit model out = tinyVAST( space_term = sem,            data = Data,            formula = n ~ 0 + factor(species),            spatial_domain = mesh,            variables = c( \"f1\", \"f2\", 1:n_c ),            space_columns = c(\"x\",\"y\"),            variable_column = \"species\",            time_column = \"time\",            distribution_column = \"dist\" )  # Extract covariance among species and factors, where # estimated covariance is obtained by ignoring factors V = term_covariance( out, what = \"space_term\", pred = \"one\" ) # }"},{"path":"https://vast-lib.github.io/tinyVAST/reference/tinyVAST.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit vector autoregressive spatio-temporal model â€” tinyVAST","title":"Fit vector autoregressive spatio-temporal model â€” tinyVAST","text":"Fits vector autoregressive spatio-temporal (VAST) model using minimal feature-set widely used interface.","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/tinyVAST.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit vector autoregressive spatio-temporal model â€” tinyVAST","text":"","code":"tinyVAST(   formula,   data,   time_term = NULL,   space_term = NULL,   spacetime_term = NULL,   family = gaussian(),   delta_options = list(formula = ~1),   spatial_varying = NULL,   weights = NULL,   spatial_domain = NULL,   development = list(),   control = tinyVASTcontrol(),   space_columns = c(\"x\", \"y\"),   time_column = \"time\",   times = NULL,   variable_column = \"var\",   variables = NULL,   distribution_column = \"dist\" )"},{"path":"https://vast-lib.github.io/tinyVAST/reference/tinyVAST.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit vector autoregressive spatio-temporal model â€” tinyVAST","text":"formula Formula response left-hand-side predictors right-hand-side, parsed mgcv hence allowing s(.) splines offset(.) offset. data Data-frame predictor, response, offset variables.  Also includes variables specify space, time, variables, distribution samples, identified arguments variable_column, time_column, space_columns, distribution_column. time_term Specification time-series structural equation model structure constructing time-variable interaction defines time-varying intercept variable (.e., applies uniformly across space). time_term=NULL disables space-variable interaction; see make_dsem_ram() notation. space_term Specification structural equation model structure constructing space-variable interaction. space_term=NULL disables space-variable interaction; see make_sem_ram() notation. spacetime_term Specification time-series structural equation model structure including lagged simultaneous effects constructing time-variable interaction, combined separable process spatial correlation form space-time-variable interaction (.e., interaction occurs locally site). spacetime_term=NULL disables space-variable interaction; see make_dsem_ram()  make_eof_ram(). family function returning class family, including gaussian(), lognormal(), tweedie(),  binomial(),  Gamma(), poisson(), nbinom1(), nbinom2(). Alternatively, can named list functions, names match levels data$distribution_column allow different families row data. Delta model families possible, see Families delta-model options. binomial family options, see 'Binomial families' Details section . delta_options named list slots formula, space_term, spacetime_term. specify options second linear predictor delta model, used (estimable) delta family used samples. spatial_varying formula specifying spatially varying coefficients (SVC). Note using formulas R, spatial_varying = ~ X automatically adds intercept implicitly read spatial_varying = ~ 1 + X, tinyVAST estimates SVC intercept addition covariate X. Therefore, want SVC single covariate, use spatial_varying = ~ 0 + X suppress default behavior formulas R. weights numeric vector representing optional likelihood weights data likelihood. Weights sum one internally modified. Thee weights argument needs vector name variable data frame. spatial_domain Object represents spatial relationships, either using fmesher::fm_mesh_2d() apply SPDE method, igraph::make_empty_graph() independent time-series, igraph::make_graph() apply simultaneous autoregressive (SAR) process user-supplied graph, sfnetwork_mesh() stream networks, class sfc_GEOMETRY e.g constructed using sf::st_make_grid apply SAR areal model adjacency based geometry object, NULL specify single site.  using igraph graph must vertex names V(graph)$name match levels data[,'space_columns'] development Specify options active development.  Please use features without coordinating package authors. control Output tinyVASTcontrol(), used define user settings. space_columns string character vector indicates column(s) data indicating location sample. spatial_domain igraph object, space_columns string levels matching names vertices object. spatial_domain fmesher sfnetwork object, space_columns character vector indicating columns data coordinates sample. time_column character string indicating column data listing time-interval sample, set times argument times. times integer vector listing set times order. times=NULL, filled vector integers minimum maximum value data$time.  Alternatively, minimum value data$time future years, model can forecast future years. variable_column character string indicating column data listing variable sample, set times argument variables. variables character vector listing set variables. variables=NULL, filled unique values data$variable_columns. distribution_column character string indicating column data listing distribution sample, set names argument family. variables=NULL, filled unique values data$variables.","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/tinyVAST.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit vector autoregressive spatio-temporal model â€” tinyVAST","text":"object (list) class tinyVAST. Elements include: data Data-frame supplied model fitting spatial_domain spatial domain supplied fitting formula formula specified model fitting obj TMB object MakeADFun opt output nlminb opt report obj$report() sdrep output sdreport tmb_inputs list inputs passed MakeADFun call record function call run_time Total time run model interal Objects useful package function, .e., arguments passed call deviance_explained output deviance_explained","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/tinyVAST.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fit vector autoregressive spatio-temporal model â€” tinyVAST","text":"tinyVAST includes several basic inputs specify model structure: formula specifies covariates splines Generalized Additive Model; time_term specifies interactions among variables time constant across space, constructing time-variable interaction. space_term specifies interactions among variables time occur based variable values location, constructing space-variable interaction. spacetime_term specifies interactions among variables time, constructing space-time-variable interaction. inputs require defining domain model.  includes: spatial_domain specifies spatial domain, determines spatial correlations times specifies temporal domain, .e., sequence time-steps variables specifies set variables, .e., variables modeled default spacetime_term=NULL space_term=NULL turns multivariate temporal indexing, spatial_domain ignored, model collapses generalized additive model using gam.  specify univariate spatial model, user must specify spatial_domain either space_term=\"\" spacetime_term=\"\", latter two parsed include single exogenous variance single variable Model building notes binomial familes:  binomial family can specified one way: response observed proportion (proportion = successes / trials), 'weights' argument used specify Binomial size (trials, N) parameter (proportion ~ ..., weights = N). factor models:  factor model desired, factor(s) must named included variables.  factor modeled space_term, time_term, spacetime_term variance must fixed priori term used.","code":""},{"path":[]},{"path":"https://vast-lib.github.io/tinyVAST/reference/tinyVAST.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit vector autoregressive spatio-temporal model â€” tinyVAST","text":"","code":"# Simulate a seperable two-dimensional AR1 spatial process n_x = n_y = 25 n_w = 10 R_xx = exp(-0.4 * abs(outer(1:n_x, 1:n_x, FUN=\"-\")) ) R_yy = exp(-0.4 * abs(outer(1:n_y, 1:n_y, FUN=\"-\")) ) z = mvtnorm::rmvnorm(1, sigma=kronecker(R_xx,R_yy) )  # Simulate nuissance parameter z from oscillatory (day-night) process w = sample(1:n_w, replace=TRUE, size=length(z)) Data = data.frame( expand.grid(x=1:n_x, y=1:n_y), w=w, z=as.vector(z) + cos(w/n_w*2*pi)) Data$n = Data$z + rnorm(nrow(Data), sd=1)  # Add columns for multivariate and/or temporal dimensions Data$var = \"n\"  # make SPDE mesh for spatial term mesh = fmesher::fm_mesh_2d( Data[,c('x','y')], n=100 )  # fit model with cyclic confounder as GAM term out = tinyVAST( data = Data,                 formula = n ~ s(w),                 spatial_domain = mesh,                 space_term = \"n <-> n, sd_n\" )  # Run crossvalidation (too slow for CRAN) # \\donttest{ CV = cv::cv( out, k = 4 ) #> R RNG seed set to 635383 #> Error in eval(call, parent.frame()): object 'mesh' not found CV #> Error: object 'CV' not found # }"},{"path":"https://vast-lib.github.io/tinyVAST/reference/tinyVASTcontrol.html","id":null,"dir":"Reference","previous_headings":"","what":"Control parameters for tinyVAST â€” tinyVASTcontrol","title":"Control parameters for tinyVAST â€” tinyVASTcontrol","text":"Control parameters tinyVAST","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/tinyVASTcontrol.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Control parameters for tinyVAST â€” tinyVASTcontrol","text":"","code":"tinyVASTcontrol(   nlminb_loops = 1,   newton_loops = 0,   eval.max = 1000,   iter.max = 1000,   getsd = TRUE,   silent = getOption(\"tinyVAST.silent\", TRUE),   trace = getOption(\"tinyVAST.trace\", 0),   verbose = getOption(\"tinyVAST.verbose\", FALSE),   profile = c(),   tmb_par = NULL,   tmb_map = NULL,   gmrf_parameterization = c(\"separable\", \"projection\"),   reml = FALSE,   getJointPrecision = FALSE,   calculate_deviance_explained = TRUE,   run_model = TRUE,   suppress_nlminb_warnings = TRUE,   suppress_user_warnings = FALSE,   get_rsr = FALSE,   extra_reporting = FALSE,   use_anisotropy = FALSE,   sar_adjacency = \"queen\",   barrier_stiffness = 0.01 )"},{"path":"https://vast-lib.github.io/tinyVAST/reference/tinyVASTcontrol.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Control parameters for tinyVAST â€” tinyVASTcontrol","text":"nlminb_loops Integer number times call stats::nlminb(). newton_loops Integer number Newton steps running stats::nlminb(). eval.max Maximum number evaluations objective function allowed. Passed control stats::nlminb(). iter.max Maximum number iterations allowed. Passed control stats::nlminb(). getsd Boolean indicating whether call TMB::sdreport() silent Disable terminal output inner optimizer? trace Parameter values printed every trace iteration outer optimizer. Passed control stats::nlminb(). verbose Output additional messages model steps fitting? profile Character-vector passed TMB::MakeADFun see description .  Fixed effects highly correlated random effects can often estimated faster (.e., fewer iterations) adding profile. common use-case profile = c(\"alpha_j\",\"alpha2_j\").  However, small impact model estimates predictions. tmb_par list parameters starting values, shape identical tinyVAST(...)$internal$parlist tmb_map input passed TMB::MakeADFun argument map, -writing version tinyVAST(...)$tmb_inputs$tmb_map allowing detailed control estimated parameters (advanced feature) gmrf_parameterization Parameterization use Gaussian Markov random field, default separable constructs full-rank separable precision matrix, alternative projection constructs full-rank IID precision variables time, projects using inverse-cholesky precision, projection allows rank-deficient covariance. reml Logical: use REML (restricted maximum likelihood) estimation rather maximum likelihood? Internally, adds fixed effects list random effects integrate . getJointPrecision whether get joint precision matrix.  Passed sdreport. calculate_deviance_explained whether calculate proportion deviance explained.  See deviance_explained() run_model whether run model export TMB objects prior compilation (useful debugging) suppress_nlminb_warnings whether suppress uniformative warnings nlminb arising function evaluation NA, replaced Inf avoided estimation suppress_user_warnings whether suppress warnings package author regarding dangerous non-standard options get_rsr Experimental option, whether report restricted spatial regression (RSR) adjusted estimator covariate responses extra_reporting Whether report much larger set quantities via obj$env$report() use_anisotropy Whether estimate two parameters representing geometric anisotropy sar_adjacency Whether use queen rook adjacency defining Simultaneous Autoregressive spatial precision sfc_GEOMETRY (default queen) barrier_stiffness ratio local stiffness (scale diffusion rate resulting decorrelation distance) barriers relative normal areas SPDE method using add_mesh_covariates.  default barrier_stiffness = 0.01 value Bakka et al. 2019.","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/tinyVASTcontrol.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Control parameters for tinyVAST â€” tinyVASTcontrol","text":"object (list) class tinyVASTcontrol, containing either default updated values supplied user model settings","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/tinyVASTcontrol.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Control parameters for tinyVAST â€” tinyVASTcontrol","text":"Bakka, H., Vanhatalo, J., Illian, J., Simpson, D., Rue, H. (2019).  Non-stationary Gaussian models physical barriers. Spatial Statistics, 29, 268-288. doi:10.1016/j.spasta.2019.01.002","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/vcov.tinyVAST.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract Variance-Covariance Matrix â€” vcov.tinyVAST","title":"Extract Variance-Covariance Matrix â€” vcov.tinyVAST","text":"extract covariance fixed effects, fixed random effects.","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/vcov.tinyVAST.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract Variance-Covariance Matrix â€” vcov.tinyVAST","text":"","code":"# S3 method for class 'tinyVAST' vcov(object, which = c(\"fixed\", \"random\", \"both\"), ...)"},{"path":"https://vast-lib.github.io/tinyVAST/reference/vcov.tinyVAST.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract Variance-Covariance Matrix â€” vcov.tinyVAST","text":"object output tinyVAST() whether extract covariance among fixed effects, random effects, ... ignored, method compatibility","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/vcov.tinyVAST.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract Variance-Covariance Matrix â€” vcov.tinyVAST","text":"square matrix containing estimated covariances among parameter estimates model. dimensions dependend upon argument , determine whether fixed, random effects, outputted.","code":""},{"path":"https://vast-lib.github.io/tinyVAST/news/index.html","id":"tinyvast-130","dir":"Changelog","previous_headings":"","what":"tinyVAST 1.3.0","title":"tinyVAST 1.3.0","text":"CRAN release: 2025-09-13 Adding add_vertex_covariates associate mesh vertices covariates (hean Anderson) Adding option covariate-based anisotropy using vertex_formula, also allowing geometric anisotropy. Adding option barriers using triangle_formula permits offset barrier covariates Adding spatial_cor use sparse matrices compute correlation coord pred coordinates, e.g.Â visualize covariate-based anisotropy Fix make_eof_ram work intended multivariate models, e.g., separate response map shared indices across variables (previously shared response map shared indices, .e., collapsed univariate model) Fix bug arising predict spatial_varying involved column newdata expecting factor, provided character-vector. Now coercers factors using levels original data (behavior formula) Export fit$rep$negloglik_i log-likelihood datum, use calculating --sample predictive score Turn SE reporting index calculations (speedup), allow SE reporting mu_g predict Fix bug arising project spatial_varying specified Adding web-vignette showing predator-expanded diet estimator using joint model specific stomach contents predator density Fix bug arising using weights argument using family delta_gamma delta_lognormal, bug introduced release 1.2.0 (h/t Peri Gerson identifying issue) Add vignette showing project function Add web-vignette showing sponge-coral-fish case study illustrate spatial structural modelling","code":""},{"path":"https://vast-lib.github.io/tinyVAST/news/index.html","id":"tinyvast-120","dir":"Changelog","previous_headings":"","what":"tinyVAST 1.2.0","title":"tinyVAST 1.2.0","text":"CRAN release: 2025-07-19 Adding new spatial domain using sf::st_make_grid Adding option geometric anisotropy using sf::st_make_grid Fix bug deviance lognormal distribution delta models (h/t Sean Anderson finding ) Change family = â€œbinomialâ€ use weights number Binomial trials N Fix deviance_explained work non-default weights argument Add fit$internal$packageVersion allow predict, cAIC etc check throw error â€™s package inconsistency object installed package Add conditional_gmrf conditional simulations GMRF Add project project tinyVAST forward time Eliminate ... argument tinyVAST â€™s obvious argument mis-named. Fix bug previously resulted non-converged models, including DSEM arrow â€œx<->x, 0, sd_xyâ€ improperly add another term â€œx <-> x, 0, V[x]â€ didnâ€™t previously parse whitespaces detecting missing covariances (h/t Jon Reum flagging issue)","code":""},{"path":"https://vast-lib.github.io/tinyVAST/news/index.html","id":"tinyvast-111","dir":"Changelog","previous_headings":"","what":"tinyVAST 1.1.1","title":"tinyVAST 1.1.1","text":"CRAN release: 2025-05-07 Adding option geometric anisotropy using SPDE method reason, CPP edits also address error message devtools::check_win_devel â€œarray subscript â€™const __m128i[0]â€™ partly outside array bounds â€˜unsigned char [12]â€™â€","code":""},{"path":"https://vast-lib.github.io/tinyVAST/news/index.html","id":"tinyvast-110","dir":"Changelog","previous_headings":"","what":"tinyVAST 1.1.0","title":"tinyVAST 1.1.0","text":"CRAN release: 2025-05-03 Adding term_covariance calculate covariance among variables SEM term, covariance among variables--lags DSEM terms Adding Restricted Spatial Regression estimator covariates alphaprime_j alphaprime2_j fit$rep output. Adding methods allow use cv calculate crossvalidation skill Add bias.correct option predict (still flag SEs anything except p_i) Switch sample_variable using obj$env$MC obj$env$spHess(random=TRUE) seems stable dependency Add functionality te ti splines, although remain poorly tested Add error check sfnetwork_mesh detect stream network ordered tree Improve stream network vignette use matrix notation joint precision, modify simulate_sfnetwork use Change tinyVAST.cpp use matrix notation constructor fix bug previous constructor covariance first second nodes right Expand test-sfnetworks.R integrated test confirm matrix-notation precision constructor identical inverse Ornstein-Uhlenbeck covariance intended.","code":""},{"path":"https://vast-lib.github.io/tinyVAST/news/index.html","id":"tinyvast-101","dir":"Changelog","previous_headings":"","what":"tinyVAST 1.0.1","title":"tinyVAST 1.0.1","text":"CRAN release: 2025-03-21 Modify examples simulate.tinyVAST sample_variable try avoid terminal output giving error valgrind check Add ivector_minus_one function satisfy clang-UBSAN Swap GMRF(Q).Quadform(x) x.matrix().transpose() * (Q * x.matrix()) avoid calculating log-determinant Q smoothers penalty, avoid valgrind errors Add tinyVASTcontrol option suppresses nlminb warning messages default, typically informative casual users","code":""},{"path":"https://vast-lib.github.io/tinyVAST/news/index.html","id":"tinyvast-100","dir":"Changelog","previous_headings":"","what":"tinyVAST 1.0.0","title":"tinyVAST 1.0.0","text":"CRAN release: 2025-03-13 Adding nbinom1 nbinom2 families Simplify argument names, changing sem space_term, dsem spacetime_term spatial_graph spatial_domain, eliminating delta_ names arguments delta_options Add time_term allow time-variable interaction (e.g., AR1 intercepts) Adding overview model-description vignettes Add simulate S3 generic","code":""},{"path":"https://vast-lib.github.io/tinyVAST/news/index.html","id":"tinyvast-071","dir":"Changelog","previous_headings":"","what":"tinyVAST 0.7.1","title":"tinyVAST 0.7.1","text":"Fixed bug (wrong output) using predict(fit, =\"mu_g\") Poisson-linked delta model Fixed bug (cryptic error message) using integrate_output Add cAIC (disabling EDF calculation now)","code":""},{"path":"https://vast-lib.github.io/tinyVAST/news/index.html","id":"tinyvast-070","dir":"Changelog","previous_headings":"","what":"tinyVAST 0.7.0","title":"tinyVAST 0.7.0","text":"Adding option spatially-varying-coefficient (SVC) models Add error-check data factor extra levels, conflicted logic adding origdata levels newdata calling predict, hence caused uniformative error previously","code":""},{"path":"https://vast-lib.github.io/tinyVAST/news/index.html","id":"tinyvast-060","dir":"Changelog","previous_headings":"","what":"tinyVAST 0.6.0","title":"tinyVAST 0.6.0","text":"Change integrate_output interface splitting W_gz V_gz four vectors area, type, covariate, weighting_index simplify documentations improve naming Fix bug cloglog logit links previously implemented use predict integrate_output","code":""},{"path":"https://vast-lib.github.io/tinyVAST/news/index.html","id":"tinyvast-050","dir":"Changelog","previous_headings":"","what":"tinyVAST 0.5.0","title":"tinyVAST 0.5.0","text":"Adding vignette showing fit multiple data types SDM Adding deviance_explained calculating default","code":""},{"path":"https://vast-lib.github.io/tinyVAST/news/index.html","id":"tinyvast-040","dir":"Changelog","previous_headings":"","what":"tinyVAST 0.4.0","title":"tinyVAST 0.4.0","text":"Adding code simulation residuals, examples vignettes","code":""},{"path":"https://vast-lib.github.io/tinyVAST/news/index.html","id":"tinyvast-030","dir":"Changelog","previous_headings":"","what":"tinyVAST 0.3.0","title":"tinyVAST 0.3.0","text":"Adding sdmTMB dependency, importing family options Adding vignette joint analysis condition density","code":""},{"path":"https://vast-lib.github.io/tinyVAST/news/index.html","id":"tinyvast-020","dir":"Changelog","previous_headings":"","what":"tinyVAST 0.2.0","title":"tinyVAST 0.2.0","text":"Add option specify covariance SEM DSEM notation","code":""},{"path":"https://vast-lib.github.io/tinyVAST/news/index.html","id":"tinyvast-010","dir":"Changelog","previous_headings":"","what":"tinyVAST 0.1.0","title":"tinyVAST 0.1.0","text":"Initial public alpha release","code":""}]
