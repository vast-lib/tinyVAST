[{"path":"https://vast-lib.github.io/tinyVAST/articles/model-description.html","id":"bivariate-generalized-linear-mixed-model-structure","dir":"Articles","previous_headings":"","what":"Bivariate generalized linear mixed model structure","title":"tinyVAST model description","text":"tinyVAST bivariate extension generalized linear mixed model (see Tables 1 2 notation), includes two linear predictors include four additive components: Spatial interactions among variables: user can specify interactions among variables given site (spatially correlated latent variables) using arrow notation derived path analysis, based interface R package sem; Temporal interaction among variables: user can specify simultaneous lagged interactions among variables time using expanded arrow--lag notation derived R package dsem, interactions annual intercept given variable therefore apply uniformly locations. Spatio-temporal interactions among variables: user can specify simultaneous lagged interactions among variables time, interactions occur site--site basis. Generalized additive model: user specifies formula generalized additive model (GAM) interpreted R package mgcv. model components missing, tinyVAST estimates parameters similar mgcv, small differences resulting different methods parameter estimation; four components assembled two linear predictors: p1,=𝐗1,𝛂1+𝐙1,𝛄1+𝐀𝛀1,c[]+𝐃1,c[],t[]+𝐀𝐄1,c[],t[]p2,=𝐗2,𝛂2+𝐙2,𝛄2+𝐀𝛀2,c[]+𝐃2,c[],t[]+𝐀𝐄2,c[],t[] \\begin{aligned} p_{\\mathrm 1,} &= \\mathbf X_{\\mathrm 1,} \\mathbf\\alpha_{\\mathrm 1} + \\mathbf Z_{\\mathrm 1,} \\mathbf\\gamma_{\\mathrm 1} + \\mathbf A_{} \\mathbf\\Omega_{\\mathrm 1,c[]} + \\mathbf D_{\\mathrm 1,c[],t[]} + \\mathbf A_i \\mathbf E_{\\mathrm 1,c[],t[]}  \\\\ p_{\\mathrm 2,} &= \\mathbf X_{\\mathrm 2,} \\mathbf\\alpha_{\\mathrm 2} + \\mathbf Z_{\\mathrm 2,} \\mathbf\\gamma_{\\mathrm 2} + \\mathbf A_{} \\mathbf\\Omega_{\\mathrm 2,c[]} + \\mathbf D_{\\mathrm 2,c[],t[]} + \\mathbf A_i \\mathbf E_{\\mathrm 2,c[],t[]} \\end{aligned} p1,ip_{\\mathrm 1,} first linear predictor; 𝐗1,𝛂1+𝐙1,𝛄1\\mathbf X_{\\mathrm 1,} \\mathbf\\alpha_{\\mathrm 1} + \\mathbf Z_{\\mathrm 1,} \\mathbf\\gamma_{\\mathrm 1} GAM component 𝛂1\\mathbf\\alpha_{\\mathrm 1} GAM fixed effects associated design matrix 𝐗1\\mathbf X_{\\mathrm 1}, 𝐗1,\\mathbf X_{\\mathrm 1,} row design matrix sample ii; 𝛄1\\mathbf\\gamma_{\\mathrm 1} GAM random effects associated design matrix 𝐙\\mathbf Z, 𝐙1,\\mathbf Z_{\\mathrm 1,} row design matrix; 𝐀𝛀1,c[]\\mathbf A_{} \\mathbf\\Omega_{\\mathrm 1,c[]} projection space-veriable interaction 𝛀\\mathbf\\Omega sample ii; 𝐃1,c[],t[]\\mathbf D_{\\mathrm 1,c[],t[]} time-variable interaction 𝐃\\mathbf D sample ii; 𝐀𝐄1,c[],t[]\\mathbf A_i \\mathbf E_{\\mathrm 1,c[],t[]} projection space-variable-time interaction 𝐄\\mathbf E sample ii; p2,ip_{\\mathrm 2,} second linear predictor, terms defined similarly using subscript-2; linear predictors passed bivariate inverse-link function specify distribution errors: yi∼fe[](ge[]−1(p1,,p2,),θe[]) y_i \\sim f_{e[]}( g_{e[]}^{-1} (p_{\\mathrm 1,}, p_{\\mathrm 2,}), \\theta_{e[]} ) fe[]f_{e[]} probability density mass function sample ii; ge[]−1(p1,,p2,)g_{e[]}^{-1} (p_{\\mathrm 1,}, p_{\\mathrm 2,}) bivariate inverse-link function transforms linear predictors central tendancy parameters distribution; θe[]\\theta_{e[]} dispersion parameters distribution e[]e[]; simple case, distribution requires single linear predictor 𝐩2=𝟎\\mathbf p_{\\mathrm 2} = \\mathbf 0 construction drops model. case, model collapses generalized linear mixed model. example might log-link Poisson distribution, collapses log-linked Poisson GLMM, yi∼Poisson(ep1,)y_i \\sim \\mathrm{Poisson}(e^{p_{\\mathrm 1,}}). However, tinyVAST can also handle delta-model using either logit-log Poisson-linked link functions: ge[]−1(p1,,p2,)=(μ1,,μ2,) g_{e[]}^{-1} (p_{\\mathrm 1,}, p_{\\mathrm 2,}) = ( \\mu_{\\mathrm 1,}, \\mu_{\\mathrm 2,}  ) μ1,\\mu_{\\mathrm 1,} μ2,\\mu_{\\mathrm 2,} two linear predictors, 𝔼[yi]=μ1,iμ2,\\mathbb{E}[y_i] = \\mu_{\\mathrm 1,} \\mu_{\\mathrm 2,}; conventional logit-log bivariate link function obtain: μ1,=ep1,i1+ep1,iμ2,=ep2,\\begin{aligned} \\mu_{\\mathrm 1,} &= \\frac{e^{p_{\\mathrm 1,}}}{1+e^{p_{\\mathrm 1,}}}  \\\\ \\mu_{\\mathrm 2,} &= e^{p_{\\mathrm 2,}} \\end{aligned} Poisson-linked link function obtain: μ1,=1−e−p1,iμ2,=ep1,iμ1,iep2,\\begin{aligned} \\mu_{\\mathrm 1,} &= 1 - e^{-p_{\\mathrm 1,}} \\\\ \\mu_{\\mathrm 2,} &= \\frac{e^{p_{\\mathrm 1,}}}{\\mu_{\\mathrm 1,}} e^{p_{\\mathrm 2,}} \\end{aligned} either case, μ1,\\mu_{\\mathrm 1,} Pr(Y>0)\\mathrm{Pr}(Y>0) (fitted Bernoulli distribution), μ2,\\mu_{\\mathrm 2,} central tendancy positive values, .e., 𝔼(Y|Y>0)=μ2,\\mathbb{E}(Y | Y>0) = \\mu_{\\mathrm 2,}.","code":""},{"path":"https://vast-lib.github.io/tinyVAST/articles/model-description.html","id":"spatial-domains","dir":"Articles","previous_headings":"","what":"Spatial domains","title":"tinyVAST model description","text":"Linear predictors include spatially autocorrelated latent variables. variables treated Gaussian Markov random fields (GMRFs), evaluating probability density GMRFs involves calculating precision matrix 𝐐domain=𝚺−1\\mathbf Q_{\\mathrm{domain}} = \\mathbf\\Sigma^{-1} inverse spatial covariance matrix. tinyVAST involves three options specifying spatial precision: Stochastic partial differentiaul equation (SPDE): analyst can approximate spatial variation continuous two-dimensional surface constructing finite element mesh (FEM), treating value vertices GMRF, using bilinear interpolation (.e., piecewise linear approximation) interpolate vertices spatial domain. case, precision constructred : 𝐐domain=τ2(κ4𝐌0+2κ2𝐌1+𝐌2) \\mathbf Q_{\\mathrm{domain}} = \\tau^2 ( \\kappa^4 \\mathbf M_{\\mathrm 0} + 2\\kappa^2 \\mathbf M_{\\mathrm 1} + \\mathbf M_{\\mathrm 2} )  every row 𝐀\\mathbf A_i interpolation matrix 𝐀\\mathbf nonzero three vertices triangle contains sample ii Simultaneous autoregressive (SAR): Alternatively, analyst can specify areal model representing value within spatial strata: 𝐐domain=τ2(𝐈−κ𝐀*)2 \\mathbf Q_{\\mathrm{domain}} = \\tau^2 (\\mathbf - \\kappa \\mathbf ^*)^2   𝐀*\\mathbf ^* adjacency matrix graph specified analyst, row 𝐀\\mathbf A_i interpolation matrix 𝐀\\mathbf nonzero single spatial stratum containing sample ii (noting adjacency matrix 𝐀*\\mathbf ^* different interpolation matrix 𝐀\\mathbf , use term due collision standard notation). Stream networks: Finally, analyst can specify sites partially correlated adjacent along stream network (ignoring flow direction). results Onstein-Uhlenbeck process along stream network, exponential tail-model.","code":""},{"path":"https://vast-lib.github.io/tinyVAST/articles/model-description.html","id":"structural-equation-models","dir":"Articles","previous_headings":"","what":"Structural equation models","title":"tinyVAST model description","text":"tinyVAST also involves specifying structural equation model (SEM). SEM viewed either: Weak interpretation: flexible way parameterize correlation among variables; Strong interpretation: structural causal model, allowing inference counterfactual changes system. specify SEM, user uses arrow notation. example, specify linear model involves: estimates single slope parameter (represented one-headed arrow), well variance W1W_1 W2W_2 (specified two-headed arrows). complicated case, W1W_1 might cause W2W_2, turn causes W3W_3. represented : Path coefficients one-headed arrows define path matrix 𝐏\\mathbf P: 𝐏=(000b12000b230) \\mathbf P =  \\begin{pmatrix}   0 & 0 & 0 \\\\   b_{12} & 0 & 0 \\\\   0 & b_{23} & 0  \\end{pmatrix} coefficents two-headed arrows define Cholesky 𝐆\\mathbf G exnogenous covariance matrix 𝐆T𝐆\\mathbf G^T \\mathbf G: 𝐆=(s1000s2000s3) \\mathbf G =  \\begin{pmatrix}   s_{1} & 0 & 0 \\\\   0 & s_{2} & 0 \\\\   0 & 0 & s_{3}  \\end{pmatrix} matrices define simultaneous equation model: $$ \\mathbf{ w = P w + \\epsilon} \\\\ \\mathbf\\epsilon \\sim \\mathrm{MVN}( \\mathbf 0, \\mathbf G^T \\mathbf G ) $$ variance Var(𝐰)=(𝐈−𝐏)−1𝐆2(𝐈−𝐏T)−1\\mathrm{Var}(\\mathbf w) = (\\mathbf{- P})^{-1} \\mathbf G^2 (\\mathbf{- P}^T)^{-1}. results sparse precision matrix: 𝐐=(𝐈−𝐏T)𝐆−1𝐆−T(𝐈−𝐏) \\mathbf Q = (\\mathbf{- P}^T) \\mathbf G^{-1} \\mathbf G^{-T} (\\mathbf{- P})","code":"w1 -> w2, b_12 w1 <-> w1, sd_1 w2 <-> w2, sd_2 w1 -> w2, b_12 w2 -> w3, b_23 w1 <-> w1, s_1 w2 <-> w2, s_2 w3 <-> w3, s_3"},{"path":"https://vast-lib.github.io/tinyVAST/articles/model-description.html","id":"dynamic-structural-equation-models","dir":"Articles","previous_headings":"","what":"Dynamic structural equation models","title":"tinyVAST model description","text":"Similarly, tinyVAST involves specifying dynamic structural equation models (DSEM). specify DSEM, user uses arrow--lag notation. example, specify univariate first-order autoregressive process: four time-intervals (T=4T=4) result path matrix: 𝐏=(0000ρ0000ρ0000ρ0) \\mathbf P =  \\begin{pmatrix}   0 & 0 & 0 & 0 \\\\   \\rho & 0 & 0 & 0 \\\\   0 & \\rho & 0 & 0 \\\\   0 & 0 & \\rho & 0  \\end{pmatrix} DSEM involves multiple times variables, sparse precision formed summing across Kronecker product time-lag interaction matrices. DSEM defines GMRF nonseparable interaction time variables, represented matrix 𝐐time_term\\mathbf Q_{\\mathrm{time\\_term}} dimension CT×CTCT \\times CT. user can specify separate arrow--lag notation define precision matrix time-variable interaction 𝐐time_term\\mathbf Q_{\\mathrm{time\\_term}} space-time-variable interaction 𝐐spacetime_term\\mathbf Q_{\\mathrm{spacetime\\_term}}. time term 𝐐time_term\\mathbf Q_{\\mathrm{time\\_term}} used define time-varying intercept variable: vec(𝐃)∼MVN(𝟎,𝐐time_term) \\mathrm{vec}(\\mathbf D) \\sim \\mathrm{MVN}(\\mathbf 0, \\mathbf Q_{\\mathrm{time\\_term}})  Meanwhile, space-time term 𝐐spacetime_term\\mathbf Q_{\\mathrm{spacetime\\_term}} combined spatial precision 𝐐space_term\\mathbf Q_{\\mathrm{space\\_term}} explain next.","code":"w1 -> w1, 1, rho"},{"path":"https://vast-lib.github.io/tinyVAST/articles/model-description.html","id":"spatial-interactions-for-sem-and-dsem","dir":"Articles","previous_headings":"","what":"Spatial interactions for SEM and DSEM","title":"tinyVAST model description","text":"tinyVAST uses SEM DSEM notation construct joint precision space-variable interaction 𝛀\\mathbf\\Omega dimension S×CS \\times C, space-time-variable interaction 𝐄\\mathbf E dimension S×C×TS \\times C \\times T. , constructs separable precision process: vec(𝐄)∼MVN(𝟎,𝐐spacetime_term⊗𝐐domain) \\mathrm{vec}(\\mathbf E) \\sim \\mathrm{MVN}(\\mathbf 0, \\mathbf Q_{\\mathrm{spacetime\\_term}} \\otimes \\mathbf Q_{\\mathrm{domain}}) precision matrix 𝐐spacetime_term⊗𝐐domain\\mathbf Q_{\\mathrm{spacetime\\_term}} \\otimes \\mathbf Q_{\\mathrm{domain}} dimension STC×STCSTC \\times STC match length vec(𝐄)\\mathrm{vec}(\\mathbf E), vec(𝛀)∼MVN(𝟎,𝐐space_term⊗𝐐domain) \\mathrm{vec}(\\mathbf\\Omega) \\sim \\mathrm{MVN}(\\mathbf 0, \\mathbf Q_{\\mathrm{space\\_term}} \\otimes \\mathbf Q_{\\mathrm{domain}}) precision matrix 𝐐space_term⊗𝐐domain\\mathbf Q_{\\mathrm{space\\_term}} \\otimes \\mathbf Q_{\\mathrm{domain}} dimension SC×SCSC \\times SC, match length vec(𝛀)\\mathrm{vec}(\\mathbf\\Omega).","code":""},{"path":"https://vast-lib.github.io/tinyVAST/articles/model-description.html","id":"generalized-additive-model","dir":"Articles","previous_headings":"","what":"Generalized additive model","title":"tinyVAST model description","text":"Finally, analyst can specify generalized additive model using syntax package mgcv. example might involve: year species factors depth log_area continuous, specify fixed effect level year, spline smoother depth, using log_area offset, estimating random intercept level species. formula parsed internally assemble fixed effects design matrix 𝐗\\mathbf X basis functions spline smoothers random effects design matrix 𝐙\\mathbf Z. coefficients 𝛄\\mathbf\\gamma associated smoothers random effects specified follow GMRF: 𝛄∼GMRF(𝟎,𝐐gam) \\mathbf\\gamma \\sim \\mathrm{GMRF}( \\mathbf 0, \\mathbf Q_{\\mathrm{gam}})  𝐐gam\\mathbf Q_{\\mathrm{gam}} blockwise diagonal matrix, assembled estimated variance parameters matrices constructed mgcv. Table 1: Subscript notation Table 2: Symbol notation, code representation (model output model template code), descriptions.","code":"count ~ year + offset(log_area) + s(depth) + s(species, bs=\"re\")"},{"path":"https://vast-lib.github.io/tinyVAST/articles/spatial.html","id":"percent-deviance-explained","dir":"Articles","previous_headings":"","what":"Percent deviance explained","title":"Spatial modeling","text":"can compute deviance residuals percent-deviance explained: can compare PDE reported mgcv comparison shows using SPDE method tinyVAST results higher percent-deviance-explained. reduced performance splines relative SPDE method presumably arises due reduced rank spline basis expansion, better match Matern function (SPDE method) relative true (simulated) exponential semivariogram. easy confirm mgcv tinyVAST give (essentially) identical PDE switching tinyVAST use bivariate spline space.","code":"# Percent deviance explained out$deviance_explained #> [1] 0.5051624 start_time = Sys.time() mygam = gam( n ~ s(w) + s(x,y), data=Data ) # Sys.time() - start_time #> Time difference of 0.03309298 secs summary(mygam)$dev.expl #> [1] 0.3517756 out_reduced = tinyVAST( data = Data,                         formula = n ~ s(w) + s(x,y) )  # Extract PDE for GAM-style spatial smoother in tinyVAST out_reduced$deviance_explained #> [1] 0.3497174"},{"path":"https://vast-lib.github.io/tinyVAST/articles/spatial.html","id":"visualize-spatial-response","dir":"Articles","previous_headings":"","what":"Visualize spatial response","title":"Spatial modeling","text":"tinyVAST standard predict function: used compute spatial response   can also compute marginal effect cyclic confounder  Alternatively, can use predict function plot confidence intervals marginal effects:","code":"predict(out, newdata=data.frame(x=1, y=1, time=1, w=1, var=\"density\") ) #> [1] 0.3649899 # Prediction grid pred = outer( seq(1,n_x,len=51),               seq(1,n_y,len=51),               FUN=\\(x,y) predict(out,newdata=data.frame(x=x,y=y,w=1,time=1,var=\"density\")) ) image( x=seq(1,n_x,len=51), y=seq(1,n_y,len=51), z=pred, main=\"Predicted response\" ) # True value image( x=1:n_x, y=1:n_y, z=matrix(Data$z,ncol=n_y), main=\"True response\" ) # compute partial dependence plot Partial = partial( object = out,                    pred.var = \"w\",                    pred.fun = \\(object,newdata) predict(object,newdata),                    train = Data,                    approx = TRUE )  # Lattice plots as default option plotPartial( Partial ) # create new data frame newdata <- data.frame(w = seq(min(Data$w), max(Data$w), length.out = 100)) newdata = cbind( newdata, 'x'=13, 'y'=13, 'var'='n' )  # make predictions p <- predict( out, newdata=newdata, se.fit=TRUE, what=\"p_g\" )  # Format as data frame and plot p = data.frame( newdata, as.data.frame(p) ) ggplot(p, aes(x=w, y=fit,   ymin = fit - 1.96 * se.fit, ymax = fit + 1.96 * se.fit)) +   geom_line() + geom_ribbon(alpha = 0.4)"},{"path":"https://vast-lib.github.io/tinyVAST/articles/spatial_factor_analysis.html","id":"spatial-factor-analysis","dir":"Articles","previous_headings":"","what":"Spatial factor analysis","title":"Spatial factor analysis","text":"first explore ability specify two latent variables five manifest variables. start simulate two spatial latent variables, project via simulated loadings matrix, simulate Tweedie response manifest variable: can inspect simulated loadings matrix True loadings specify model expected tinyVAST: can compare true loadings (rotated optimize comparison): Rotated true loadings estimated loadings can compared estimated true loadings matrices: Rotated estimated loadings can specify model ensuring residual spatial variation also captured: can compared estimated true loadings matrices: Rotated estimated loadings full rank","code":"# Simulate settings theta_xy = 0.4 n_x = n_y = 10 n_c = 5 rho = 0.8 resid_sd = 0.5  # Simulate GMRFs R_s = exp(-theta_xy * abs(outer(1:n_x, 1:n_y, FUN=\"-\")) ) R_ss = kronecker(X=R_s, Y=R_s) delta_fs = mvtnorm::rmvnorm(n_c, sigma=R_ss )  # L_cf = matrix( rnorm(n_c^2), nrow=n_c ) L_cf[,3:5] = 0 L_cf = L_cf + resid_sd * diag(n_c)  # d_cs = L_cf %*% delta_fs dimnames(L_cf) = list( paste0(\"Var \", 1:nrow(L_cf)),                        paste0(\"Factor \", 1:ncol(L_cf)) ) knitr::kable( L_cf,               digits=2, caption=\"True loadings\") # Shape into longform data-frame and add error Data = data.frame( expand.grid(species=1:n_c, x=1:n_x, y=1:n_y),                    \"var\"=\"logn\", \"z\"=exp(as.vector(d_cs)) ) Data$n = tweedie::rtweedie( n=nrow(Data), mu=Data$z, phi=0.5, power=1.5 ) mean(Data$n==0) #> [1] 0.03  # make mesh mesh = fm_mesh_2d( Data[,c('x','y')] )  # sem = \"   f1 -> 1, l1   f1 -> 2, l2   f1 -> 3, l3   f1 -> 4, l4   f1 -> 5, l5   f2 -> 2, l6   f2 -> 3, l7   f2 -> 4, l8   f2 -> 5, l9   f1 <-> f1, NA, 1   f2 <-> f2, NA, 1   1 <-> 1, NA, 0   2 <-> 2, NA, 0   3 <-> 3, NA, 0   4 <-> 4, NA, 0   5 <-> 5, NA, 0 \"  # fit model out = tinyVAST( space_term = sem,            data = Data,            formula = n ~ 0 + factor(species),            spatial_domain = mesh,            family = tweedie(),            variables = c( \"f1\", \"f2\", 1:n_c ),            space_columns = c(\"x\",\"y\"),            variable_column = \"species\",            time_column = \"time\",            distribution_column = \"dist\",            control = tinyVASTcontrol(gmrf=\"proj\") ) out #> Call:  #> tinyVAST(formula = n ~ 0 + factor(species), data = Data, space_term = sem,  #>     family = tweedie(), space_columns = c(\"x\", \"y\"), spatial_domain = mesh,  #>     time_column = \"time\", variable_column = \"species\", variables = c(\"f1\",  #>         \"f2\", 1:n_c), distribution_column = \"dist\", control = tinyVASTcontrol(gmrf = \"proj\")) #>  #> Run time:  #> Time difference of 1.525801 secs #>  #> Family:  #> $obs #>  #> Family: tweedie  #> Link function: log  #>  #>  #>  #>  #> sdreport(.) result #>              Estimate Std. Error #> alpha_j    0.07570783 0.31850774 #> alpha_j   -0.02014888 0.39763412 #> alpha_j    0.22318277 0.21847161 #> alpha_j    0.14728087 0.27057852 #> alpha_j   -0.26514652 0.14638317 #> theta_z    0.68016356 0.11510781 #> theta_z    0.68285927 0.15773444 #> theta_z    0.31701846 0.10358197 #> theta_z    0.52123769 0.10914344 #> theta_z    0.14819781 0.09200614 #> theta_z    0.51873790 0.13709521 #> theta_z   -0.31998633 0.10049164 #> theta_z    0.23601680 0.10640963 #> theta_z   -0.21613586 0.09652980 #> log_sigma -0.52205331 0.06761637 #> log_sigma  0.21851154 0.13313019 #> log_kappa -0.26761196 0.21030826 #> Maximum gradient component: 0.002233932  #>  #> Proportion conditional deviance explained:  #> [1] 0.551999 #>  #> space_term:  #>    heads to from parameter start   Estimate  Std_Error   z_value      p_value #> 1      1  1   f1         1  <NA>  0.6801636 0.11510781  5.908926 3.443444e-09 #> 2      1  2   f1         2  <NA>  0.6828593 0.15773444  4.329170 1.496721e-05 #> 3      1  3   f1         3  <NA>  0.3170185 0.10358197  3.060556 2.209261e-03 #> 4      1  4   f1         4  <NA>  0.5212377 0.10914344  4.775713 1.790719e-06 #> 5      1  5   f1         5  <NA>  0.1481978 0.09200614  1.610738 1.072368e-01 #> 6      1  2   f2         6  <NA>  0.5187379 0.13709521  3.783778 1.544654e-04 #> 7      1  3   f2         7  <NA> -0.3199863 0.10049164 -3.184209 1.451504e-03 #> 8      1  4   f2         8  <NA>  0.2360168 0.10640963  2.218002 2.655468e-02 #> 9      1  5   f2         9  <NA> -0.2161359 0.09652980 -2.239058 2.515211e-02 #> 10     2 f1   f1         0     1  1.0000000         NA        NA           NA #> 11     2 f2   f2         0     1  1.0000000         NA        NA           NA #> 12     2  1    1         0     0  0.0000000         NA        NA           NA #> 13     2  2    2         0     0  0.0000000         NA        NA           NA #> 14     2  3    3         0     0  0.0000000         NA        NA           NA #> 15     2  4    4         0     0  0.0000000         NA        NA           NA #> 16     2  5    5         0     0  0.0000000         NA        NA           NA #>  #> Fixed terms:  #>                     Estimate Std_Error     z_value    p_value #> factor(species)1  0.07570783 0.3185077  0.23769543 0.81211733 #> factor(species)2 -0.02014888 0.3976341 -0.05067191 0.95958696 #> factor(species)3  0.22318277 0.2184716  1.02156419 0.30698721 #> factor(species)4  0.14728087 0.2705785  0.54431841 0.58622238 #> factor(species)5 -0.26514652 0.1463832 -1.81131833 0.07009159 Lrot_cf = rotate_pca( L_cf )$L_tf dimnames(Lrot_cf) = list( paste0(\"Var \", 1:nrow(Lrot_cf)),                        paste0(\"Factor \", 1:ncol(Lrot_cf)) ) knitr::kable( Lrot_cf,               digits=2, caption=\"Rotated true loadings\") # Extract and rotate estimated loadings Lhat_cf = matrix( 0, nrow=n_c, ncol=2 ) Lhat_cf[lower.tri(Lhat_cf,diag=TRUE)] = as.list(out$sdrep, what=\"Estimate\")$theta_z Lhat_cf = rotate_pca( L_tf=Lhat_cf, order=\"decreasing\" )$L_tf #> Warning in sqrt(Eigen$values): NaNs produced dimnames(Lhat_cf) = list( paste0(\"Var \", 1:nrow(Lhat_cf)),                        paste0(\"Factor \", 1:ncol(Lhat_cf)) ) knitr::kable( Lhat_cf,               digits=2, caption=\"Rotated estimated loadings\" ) # sem = \"   f1 -> 1, l1   f1 -> 2, l2   f1 -> 3, l3   f1 -> 4, l4   f1 -> 5, l5   f2 -> 2, l6   f2 -> 3, l7   f2 -> 4, l8   f2 -> 5, l9   f1 <-> f1, NA, 1   f2 <-> f2, NA, 1   1 <-> 1, sd_resid   2 <-> 2, sd_resid   3 <-> 3, sd_resid   4 <-> 4, sd_resid   5 <-> 5, sd_resid \"  # fit model out = tinyVAST( space_term = sem,            data = Data,            formula = n ~ 0 + factor(species),            spatial_domain = mesh,            family = list( \"obs\"=tweedie() ),            variables = c( \"f1\", \"f2\", 1:n_c ),            space_columns = c(\"x\",\"y\"),            variable_column = \"species\",            time_column = \"time\",            distribution_column = \"dist\",            control = tinyVASTcontrol(gmrf=\"proj\") )  # Extract and rotate estimated loadings Lhat_cf = matrix( 0, nrow=n_c, ncol=2 ) Lhat_cf[lower.tri(Lhat_cf,diag=TRUE)] = as.list(out$sdrep, what=\"Estimate\")$theta_z #> Warning in Lhat_cf[lower.tri(Lhat_cf, diag = TRUE)] = as.list(out$sdrep, : #> number of items to replace is not a multiple of replacement length Lhat_cf = rotate_pca( L_tf=Lhat_cf, order=\"decreasing\" )$L_tf #> Warning in sqrt(Eigen$values): NaNs produced dimnames(Lhat_cf) = list( paste0(\"Var \", 1:nrow(Lhat_cf)),                        paste0(\"Factor \", 1:ncol(Lhat_cf)) ) knitr::kable( Lhat_cf,               digits=2, caption=\"Rotated estimated loadings with full rank\" )"},{"path":"https://vast-lib.github.io/tinyVAST/articles/web_only/age_composition_expansion.html","id":"expanding-age-composition-data","dir":"Articles > Web_only","previous_headings":"","what":"Expanding age-composition data","title":"Age composition expansion","text":"start, load sampling data undergone first-stage expansion. arises primary sampling unit includes secondary subsampling ages, subsampled proporrtion--age primary unit expanded total abundance primary sample: Next, construct various inputs tinyVAST run model log-linked Tweedie distribution single linear predictor: model fitted, apply area-expansion epsilon bias-correction method predict abundance--age, convert proportion: Finally, can compare estimates package VAST. Estimates differ somewhat VAST used delta-gamma distribution spatio-temporal variation two linear predictors, also used different mesh.","code":"data( bering_sea_pollock_ages )  # subset to Years 2010-2023 (to speed up the example) Data = subset( bering_sea_pollock_ages, Year >= 2010 )  # Add Year-_Age interaction Data$Age = factor( paste0(\"Age_\",Data$Age) ) Data$Year_Age = interaction( Data$Year, Data$Age )  # Project data to UTM Data = st_as_sf( Data,                     coords = c('Lon','Lat'),                    crs = st_crs(4326) ) Data = st_transform( Data,                          crs = st_crs(\"+proj=utm +zone=2 +units=km\") ) # Add UTM coordinates as columns X & Y Data = cbind( st_drop_geometry(Data), st_coordinates(Data) ) # adds different variances for each age sem = \"\"  # Constant AR1 spatio-temporal term across ages # and adds different variances for each age dsem = \"   Age_1 -> Age_1, 1, lag1   Age_2 -> Age_2, 1, lag1   Age_3 -> Age_3, 1, lag1   Age_4 -> Age_4, 1, lag1   Age_5 -> Age_5, 1, lag1   Age_6 -> Age_6, 1, lag1   Age_7 -> Age_7, 1, lag1   Age_8 -> Age_8, 1, lag1   Age_9 -> Age_9, 1, lag1   Age_10 -> Age_10, 1, lag1   Age_11 -> Age_11, 1, lag1   Age_12 -> Age_12, 1, lag1   Age_13 -> Age_13, 1, lag1   Age_14 -> Age_14, 1, lag1   Age_15 -> Age_15, 1, lag1 \"  mesh = fm_mesh_2d( loc = Data[,c(\"X\",\"Y\")],                             cutoff = 50 ) control = tinyVASTcontrol( getsd = FALSE,                            profile = c(\"alpha_j\"),                              trace = 0 ) family = list(   Age_1 = tweedie(),   Age_2 = tweedie(),   Age_3 = tweedie(),   Age_4 = tweedie(),   Age_5 = tweedie(),    Age_6 = tweedie(),   Age_7 = tweedie(),   Age_8 = tweedie(),   Age_9 = tweedie(),   Age_10 = tweedie(),   Age_11 = tweedie(),   Age_12 = tweedie(),   Age_13 = tweedie(),   Age_14 = tweedie(),   Age_15 = tweedie()      )  #Data$Year = factor(Data$Year) myfit = tinyVAST(   data = Data,   formula = Abundance_per_hectare ~ 0 + Year_Age,   space_term = sem,   spacetime_term = dsem,   family = family,   space_column = c(\"X\", \"Y\"),    variable_column = \"Age\",   time_column = \"Year\",   distribution_column = \"Age\",   spatial_domain = mesh,   control = control ) # Get shapefile for survey extent data( bering_sea )  # Make extrapolation grid based on shapefile bering_sea = st_transform( bering_sea,                             st_crs(\"+proj=utm +zone=2 +units=km\") ) grid = st_make_grid( bering_sea, n=c(50,50) ) grid = st_intersection( grid, bering_sea ) grid = st_make_valid( grid ) loc_gz = st_coordinates(st_centroid( grid ))  # Get area for extrapolation grid library(units) areas = set_units(st_area(grid), \"hectares\") #  / 100^2 # Hectares  # Get abundance N_jz = expand.grid( Age=myfit$internal$variables, Year=sort(unique(Data$Year)) ) N_jz = cbind( N_jz, \"Biomass\"=NA, \"SE\"=NA ) for( j in seq_len(nrow(N_jz)) ){   if( N_jz[j,'Age']==1 ){     message( \"Integrating \", N_jz[j,'Year'], \" \", N_jz[j,'Age'], \": \", Sys.time() )   }   if( is.na(N_jz[j,'Biomass']) ){     newdata = data.frame( loc_gz, Year=N_jz[j,'Year'], Age=N_jz[j,'Age'])       newdata$Year_Age = paste( newdata$Year, newdata$Age, sep=\".\" )     # Area-expansion     index1 = integrate_output( myfit,                     area = areas,                     newdata = newdata,                     apply.epsilon = TRUE,                     bias.correct = FALSE,                     intern = TRUE )     N_jz[j,'Biomass'] = index1[3] / 1e9   } } N_ct = array( N_jz$Biomass, dim=c(length(myfit$internal$variables),length(unique(Data$Year))),               dimnames=list(myfit$internal$variables,sort(unique(Data$Year))) ) N_ct = N_ct / outer( rep(1,nrow(N_ct)), colSums(N_ct) ) # Load VAST results for same data data(bering_sea_pollock_vast) myvast = bering_sea_pollock_vast rownames(myvast) = 1:15  # Reformat tinyVAST output with same dimnames mytiny = N_ct rownames(mytiny) = 1:15  # longvast = cbind( expand.grid(dimnames(myvast)), \"p\"=as.numeric(myvast), \"method\"=\"VAST\" ) longtiny = cbind( expand.grid(dimnames(mytiny)), \"p\"=as.numeric(mytiny), \"method\"=\"tinyVAST\" ) long = rbind( longvast, longtiny )  library(ggplot2) ggplot( data=long, aes(x=Var2, y=p, col=method) ) +   facet_grid( rows=vars(Var1), scales=\"free\" ) +   geom_point( ) +   scale_y_log10()"},{"path":"https://vast-lib.github.io/tinyVAST/articles/web_only/condition.html","id":"abundance-weighted-expansion","dir":"Articles > Web_only","previous_headings":"","what":"Abundance-weighted expansion","title":"Condition and density","text":"explore output, can plot output using survey extent:","code":"# Extract shapefile region = condition_and_density$eastern_bering_sea  # make extrapolation-grid sf_grid = st_make_grid( region, cellsize=c(0.2,0.2) ) sf_grid = st_intersection( sf_grid, region ) sf_grid = st_make_valid( sf_grid ) n_g = length(sf_grid)  # grid_coords = st_coordinates( st_centroid(sf_grid) ) areas_km2 = st_area( sf_grid ) / 1e6  # Condition in  newdata = data.frame( \"Lat\" = grid_coords[,'Y'],                        \"Lon\" = grid_coords[,'X'],                       \"Year\" = 1982,                       \"Type\" = \"Condition\",                       #\"Year_Type\" = \"1982_Condition\",                       \"log_length\" = 0 )  # Average log-length across years cond_1982 = predict(fit, newdata=newdata, what=\"p_g\")  # Repeat for density newdata2 = newdata newdata2$Type = \"Biomass\" #newdata2$Year_Type = \"1982_Biomass\" dens_1982 = predict(fit, newdata=newdata2, what=\"p_g\")  # Plot on map plot_grid = st_sf( sf_grid,                      \"Condition.1982\" = cond_1982,                     \"Density.1982\" = dens_1982 )  plot( plot_grid, border=NA )"},{"path":"https://vast-lib.github.io/tinyVAST/articles/web_only/condition.html","id":"density-weighted-condition","dir":"Articles > Web_only","previous_headings":"","what":"Density-weighted condition","title":"Condition and density","text":"Finally, can calculate density-weighted condition, using local numerical density weighting term averaging across model domain. Condition units mass per allometric-length model estimating allometric weight-length relationship jointly condition. Therefore, condition units directly comparable either weight density.","code":"#  expand_data = rbind( newdata2, newdata )  # cond_tz = data.frame( \"Year\"=1998:2016, \"Est\"=NA, \"SE\"=NA ) for( yearI in seq_len(nrow(cond_tz)) ){   expand_data[,'Year'] = cond_tz[yearI,\"Year\"]   out = integrate_output( fit,                            newdata = expand_data,                           area = c(as.numeric(areas_km2),rep(0,n_g)),                           type = rep(c(0,3),each=n_g),                           weighting_index = c( rep(0,n_g), seq_along(areas_km2)-1 ),                           bias.correct = TRUE )    cond_tz[yearI,c(\"Est\",\"SE\")] = out[c(\"Estimate\",\"Std. Error\")] }  # plot time-series ggplot( cond_tz ) +   geom_line( aes(x=Year, y=Est) ) +   geom_ribbon( aes(x=Year, ymin=Est-SE, ymax=Est+SE), alpha=0.2 )"},{"path":"https://vast-lib.github.io/tinyVAST/articles/web_only/empirical_orthogonal_functions.html","id":"empirical-orthogonal-function-eof-analysis","dir":"Articles > Web_only","previous_headings":"","what":"Empirical Orthogonal Function (EOF) analysis","title":"Empirical orthogonal functions","text":"start, reformat data September Sea ice concentrations: Next, construct various inputs tinyVAST Finally, can extract, rotate, plot dominant modes variability associated spatial responses:","code":"data( sea_ice ) library(sf) library(rnaturalearth)  # project data sf_ice = st_as_sf( sea_ice, coords = c(\"lon\",\"lat\") ) st_crs(sf_ice) = \"+proj=longlat +datum=WGS84\" sf_ice = st_transform( sf_ice,                       crs=st_crs(\"+proj=laea +lat_0=90 +lon_0=-30 +units=km\") )  # sf_pole = st_point( c(0,90) ) sf_pole = st_sfc( sf_pole, crs=\"+proj=longlat +datum=WGS84\" ) sf_pole = st_transform( sf_pole, crs=st_crs(sf_ice) ) sf_pole = st_buffer( sf_pole, dist=3000 ) sf_ice = st_intersection( sf_ice, sf_pole )  Data = data.frame( st_drop_geometry(sf_ice),               st_coordinates(sf_ice),               var = \"Ice\" ) n_eof = 2 dsem = make_eof_ram( variables = \"Ice\",                      times = sort(unique(Data[,'year'])),                      n_eof = 2,                      standard_deviations = 0 ) mesh = fm_mesh_2d( Data[,c('X','Y')], cutoff=1.5 )  # fit model out = tinyVAST( spacetime_term = dsem,            space_term = \"\",            data = as.data.frame(Data),            formula = ice_concentration ~ 1,            spatial_domain = mesh,            space_column = c(\"X\",\"Y\"),            variable_column = \"var\",            time_column = \"year\",            distribution_column = \"dist\",            times = c(paste0(\"EOF_\",seq_len(n_eof)), sort(unique(Data[,'year']))),            control = tinyVASTcontrol( profile=\"alpha_j\",                                       gmrf_parameterization=\"projection\") ) #> Warning in tinyVAST(spacetime_term = dsem, space_term = \"\", data = #> as.data.frame(Data), : `spatial_domain` has over 1000 components, so the model #> may be extremely slow # Country shapefiles for plotting sf_maps = ne_countries( return=\"sf\", scale=\"medium\", continent=c(\"north america\",\"europe\",\"asia\") ) sf_maps = st_transform( sf_maps, crs=st_crs(sf_ice) ) sf_maps = st_union( sf_maps )  # Shapefile for water sf_water = st_difference( st_as_sfc(st_bbox(sf_maps)), sf_maps )  # Create extrapolation grid cellsize = 50 sf_grid = st_make_grid( sf_pole, cellsize=cellsize ) # Restrict to water grid_i = st_intersects( sf_water, sf_grid ) sf_grid = sf_grid[ unique(unlist(grid_i)) ] # Restrict to 3000 km from North Pole grid_i = st_intersects( sf_pole, sf_grid ) sf_grid = sf_grid[ unique(unlist(grid_i)) ]  # newdata = data.frame( st_coordinates(st_centroid(sf_grid)),                       var = \"Ice\" )  # Extract loadings L_tf = matrix( 0, nrow=length(unique(Data$year)), ncol=2,                dimnames=list(unique(Data$year),c(\"EOF_1\",\"EOF_2\")) ) L_tf[lower.tri(L_tf,diag=TRUE)] = out$opt$par[names(out$opt$par)==\"beta_z\"]  # Extract factor-responses EOF1_g = predict( out, cbind(newdata, year=\"EOF_1\"), what=\"pepsilon_g\" ) EOF2_g = predict( out, cbind(newdata, year=\"EOF_2\"), what=\"pepsilon_g\" ) omega_g = predict( out, cbind(newdata, year=\"EOF_2\"), what=\"pomega_g\" )  # Rotate responses and loadings rotated_results = rotate_pca( L_tf=L_tf, x_sf=cbind(EOF1_g,EOF2_g), order=\"decreasing\" ) #> Warning in sqrt(Eigen$values): NaNs produced EOF1_g = rotated_results$x_sf[,1] EOF2_g = rotated_results$x_sf[,2] L_tf = rotated_results$L_tf  # Plot on map sf_plot = st_sf( sf_grid, \"EOF1_g\"=EOF1_g, \"EOF2_g\"=EOF2_g, \"omega_g\"=omega_g ) par(mfrow=c(2,2), oma=c(2,2,0,0) ) plot( sf_plot[,'EOF1_g'], reset=FALSE, key.pos=NULL, border=NA )   plot( st_geometry(sf_maps), add=TRUE, border=NA, col=\"grey\" ) plot( sf_plot[,'EOF2_g'], reset=FALSE, key.pos=NULL, border=NA )   plot( st_geometry(sf_maps), add=TRUE, border=NA, col=\"grey\" ) plot( sf_plot[,'omega_g'], reset=FALSE, key.pos=NULL, border=NA )   plot( st_geometry(sf_maps), add=TRUE, border=NA, col=\"grey\" ) matplot( y=L_tf, x=unique(Data$year), type=\"l\",          col=viridisLite::viridis(n_eof), lwd=2, lty=\"solid\" )   legend( \"top\", ncol=n_eof, legend=paste0(\"EOF\",1:n_eof),           fill=viridisLite::viridis(n_eof) )"},{"path":"https://vast-lib.github.io/tinyVAST/articles/web_only/overview.html","id":"background-materials","dir":"Articles > Web_only","previous_headings":"","what":"Background materials:","title":"Overview of vignettes","text":"tinyVAST Model description: Describes equations notation Comparison mgcv: Shows tinyVAST smoothers (approximately) identical using package mgcv, despite replacing generalized additive model wiggliness parameter mixed-effects variance parameter (.e., replacing * Spatial modeling: Shows fit simple spatial model, including covariates, visualize model output, deviance explained, diagnostics; Spatial models Multiple data types: Shows integrate data following different distributions, case showing presence/absence, count, biomass samples red snapper; Dynamic structural equation models: Shows tinyVAST can reduced time-series model simultaneous lagged effects (e.g., vector autoregressive model)","code":""},{"path":"https://vast-lib.github.io/tinyVAST/articles/web_only/overview.html","id":"alternative-spatial-domains","dir":"Articles > Web_only","previous_headings":"","what":"Alternative spatial domains","title":"Overview of vignettes","text":"Simulatenous autoregressive process: Shows use areal spatial domain (simultaneous autoregressive SAR process) instead two-dimensional smoother; Stream network models: Shows use stream network spatial domain (.e., Ornstein-Uhlenbeck process flow-unconnected sites acyclic graph);","code":""},{"path":"https://vast-lib.github.io/tinyVAST/articles/web_only/overview.html","id":"multivariate-spatio-temporal-models","dir":"Articles > Web_only","previous_headings":"","what":"Multivariate spatio-temporal models","title":"Overview of vignettes","text":"Age composition expansion: Shows fit multivariate spatio-temporal model standardize age composition data; Condition density: Shows jointly analyze different types data combined single estimator. case, use joint analysis numerical density animal condition calculate per-capita average condition Empirical orthogonal functions: Shows fit empirical orthogonal function (EOF) analysis, .e., model spatio-temporal variation product one time-series, associated spatial response map additive penalty generalized additive model log-determinant Hessian approximated marginal likelihood) Spatial factor analysis: Shows specify spatial factors represent covariance among multiple variables, including identifiability requirement post-hoc rotation estimated loadings; Vector autoregressive spatio-temporal: Shows fit simple (two-variable) spatial version vector autoregressive model.","code":""},{"path":"https://vast-lib.github.io/tinyVAST/articles/web_only/VAST.html","id":"spatio-temporal-autoregressive-model","dir":"Articles > Web_only","previous_headings":"","what":"Spatio-temporal autoregressive model","title":"Vector autoregressive spatio-temporal models","text":"first explore ability specify first-order autoregressive spatio-temporal process: estimated values beta_z correspond simulated value rho spatial_sd. can compare true densities:  estimated densities:  scatterplot shows highly correlated:  can also use DHARMa package visualize simulation residuals:  can calculate area-weighted total abundance compare true value:  Next, compare current version VAST sdmTMB models similar runtimes","code":"# Simulate settings theta_xy = 0.4 n_x = n_y = 10 n_t = 15 rho = 0.8 spacetime_sd = 0.5 space_sd = 0.5 gamma = 0  # Simulate GMRFs R_s = exp(-theta_xy * abs(outer(1:n_x, 1:n_y, FUN=\"-\")) ) R_ss = kronecker(R_s, R_s) Vspacetime_ss = spacetime_sd^2 * R_ss  Vspace_ss = space_sd^2 * R_ss  # make spacetime AR1 over time eps_ts = mvtnorm::rmvnorm( n_t, sigma=Vspacetime_ss ) for( t in seq_len(n_t) ){   if(t>1) eps_ts[t,] = rho*eps_ts[t-1,] + eps_ts[t,]/(1 + rho^2) }  # make space term omega_s = mvtnorm::rmvnorm( 1, sigma=Vspace_ss )[1,]  # linear predictor p_ts = gamma + outer( rep(1,n_t),omega_s ) + eps_ts  # Shape into longform data-frame and add error Data = data.frame( expand.grid(time=1:n_t, x=1:n_x, y=1:n_y),                     var = \"logn\",                     mu = exp(as.vector(p_ts)) ) Data$n = tweedie::rtweedie( n=nrow(Data), mu=Data$mu, phi=0.5, power=1.5 ) mean(Data$n==0) #> [1] 0.072  # make mesh mesh = fm_mesh_2d( Data[,c('x','y')] )  # fit model mytinyVAST = tinyVAST(             space_term = \"logn <-> logn, sd_space\",            spacetime_term = \"logn -> logn, 1, rho                              logn <-> logn, 0, sd_spacetime\",            data = Data,            formula = n ~ 1,            spatial_domain = mesh,            family = tweedie() ) mytinyVAST #> Call:  #> tinyVAST(formula = n ~ 1, data = Data, space_term = \"logn <-> logn, sd_space\",  #>     spacetime_term = \"logn -> logn, 1, rho\\n                             logn <-> logn, 0, sd_spacetime\",  #>     family = tweedie(), spatial_domain = mesh) #>  #> Run time:  #> Time difference of 20.17429 secs #>  #> Family:  #> $obs #>  #> Family: tweedie  #> Link function: log  #>  #>  #>  #>  #> sdreport(.) result #>              Estimate Std. Error #> alpha_j   -0.51042312 0.20682192 #> beta_z     0.84975372 0.07526572 #> beta_z    -0.25841774 0.03730119 #> theta_z    0.44410419 0.06898295 #> log_sigma -0.64811502 0.05006806 #> log_sigma  0.01446398 0.06494080 #> log_kappa -0.15608154 0.16446880 #> Maximum gradient component: 0.005583973  #>  #> Proportion conditional deviance explained:  #> [1] 0.543224 #>  #> space_term:  #>   heads   to from parameter start  Estimate  Std_Error  z_value      p_value #> 1     2 logn logn         1  <NA> 0.4441042 0.06898295 6.437883 1.211509e-10 #>  #> spacetime_term:  #>   heads   to from parameter start lag   Estimate  Std_Error   z_value #> 1     1 logn logn         1  <NA>   1  0.8497537 0.07526572 11.290049 #> 2     2 logn logn         2  <NA>   0 -0.2584177 0.03730119 -6.927869 #>        p_value #> 1 1.469548e-29 #> 2 4.272276e-12 #>  #> Fixed terms:  #>               Estimate Std_Error   z_value    p_value #> (Intercept) -0.5104231 0.2068219 -2.467935 0.01358949 library(sf) #> Warning: package 'sf' was built under R version 4.4.2 data_wide = reshape( Data[,c('x','y','time','mu')],                      direction = \"wide\", idvar = c('x','y'), timevar = \"time\") sf_data = st_as_sf( data_wide, coords=c(\"x\",\"y\")) sf_grid = sf::st_make_grid( sf_data ) sf_plot = st_sf(sf_grid, st_drop_geometry(sf_data) ) plot(sf_plot, max.plot=n_t ) Data$mu_hat = predict(mytinyVAST) data_wide = reshape( Data[,c('x','y','time','mu_hat')],                      direction = \"wide\", idvar = c('x','y'), timevar = \"time\") sf_data = st_as_sf( data_wide, coords=c(\"x\",\"y\")) sf_plot = st_sf(sf_grid, st_drop_geometry(sf_data) ) plot(sf_plot, max.plot=n_t ) plot( x=Data$mu, y=Data$mu_hat ) # simulate new data conditional on fixed and random effects y_ir = replicate( n = 100,             expr = mytinyVAST$obj$simulate()$y_i )  # res = DHARMa::createDHARMa( simulatedResponse = y_ir,                              observedResponse = Data$n,                              fittedPredictedResponse = fitted(mytinyVAST) ) plot(res) # Predicted sample-weighted total (Est = sapply( seq_len(n_t),    FUN=\\(t) integrate_output(mytinyVAST, newdata=subset(Data,time==t)) )) #>                          [,1]      [,2]     [,3]      [,4]      [,5]      [,6] #> Estimate            69.774342 68.167115 68.24959 64.038611 58.736780 60.506542 #> Std. Error           4.733476  4.404922  4.32475  4.092695  3.880481  3.887897 #> Est. (bias.correct) 72.867322 71.288122 71.44284 67.062705 61.536991 63.391199 #> Std. (bias.correct)        NA        NA       NA        NA        NA        NA #>                          [,7]      [,8]      [,9]     [,10]     [,11]     [,12] #> Estimate            54.977480 58.463756 64.523920 74.895696 84.490757 76.981720 #> Std. Error           3.772127  3.863062  4.166782  4.702731  5.335555  5.141678 #> Est. (bias.correct) 57.610639 61.214950 67.544399 78.336996 88.253689 80.405085 #> Std. (bias.correct)        NA        NA        NA        NA        NA        NA #>                         [,13]      [,14]     [,15] #> Estimate            87.189025  96.106379 93.626461 #> Std. Error           5.514166   6.001112  6.338951 #> Est. (bias.correct) 91.106042 100.570708 98.734105 #> Std. (bias.correct)        NA         NA        NA  # True (latent) sample-weighted total (True = tapply( Data$mu, INDEX=Data$time, FUN=sum )) #>         1         2         3         4         5         6         7         8  #>  70.98033  70.14925  68.40932  68.70763  58.38332  65.95801  60.52297  55.14115  #>         9        10        11        12        13        14        15  #>  60.02083  74.91768  86.40811  77.73359  85.88998  98.33442 105.16020  # Index = data.frame( time=seq_len(n_t), t(Est), True ) Index$low = Index[,'Est...bias.correct.'] - 1.96*Index[,'Std..Error'] Index$high = Index[,'Est...bias.correct.'] + 1.96*Index[,'Std..Error']  # library(ggplot2) ggplot(Index, aes(time, Estimate)) +   geom_ribbon(aes(ymin = low,                   ymax = high),    # shadowing cnf intervals               fill = \"lightgrey\") +   geom_line( color = \"black\",             linewidth = 1) +   geom_point( aes(time, True), color = \"red\" ) #> Warning: package 'marginaleffects' was built under R version 4.4.2 settings = make_settings( purpose=\"index3\",                           n_x = n_x*n_y,                           Region = \"Other\",                           bias.correct = FALSE,                           use_anisotropy = FALSE ) settings$FieldConfig['Epsilon','Component_1'] = 0 settings$FieldConfig['Omega','Component_1'] = 0 settings$RhoConfig['Epsilon2'] = 4 settings$RhoConfig[c('Beta1','Beta2')] = 3 settings$ObsModel = c(10,2)  # Run VAST myVAST = fit_model( settings=settings,                  Lat_i = Data[,'y'],                  Lon_i = Data[,'x'],                  t_i = Data[,'time'],                  b_i = Data[,'n'],                  a_i = rep(1,nrow(Data)),                  observations_LL = cbind(Lat=Data[,'y'],Lon=Data[,'x']),                  grid_dim_km = c(100,100),                  newtonsteps = 0,                  loopnum = 1,                  control = list(eval.max = 10000, iter.max = 10000, trace = 0) ) myVAST #> fit_model(.) result #> $par #>       beta1_ft       beta2_ft     L_omega2_z   L_epsilon2_z      logkappa2  #>    -0.59988031     0.09993533     0.55005057     0.26695392    -4.68896241  #> Epsilon_rho2_f      logSigmaM  #>     0.89582684     0.05547658  #>  #> $objective #> [1] 1256.257 #>  #> $iterations #> [1] 3 #>  #> $evaluations #> function gradient  #>        7        3  #>  #> $time_for_MLE #> Time difference of 1.310401 secs #>  #> $max_gradient #> [1] 0.0007302568 #>  #> $Convergence_check #> [1] \"The model is likely not converged\" #>  #> $number_of_coefficients #>  Total  Fixed Random  #>   2183      7   2176  #>  #> $AIC #> [1] 2526.515 #>  #> $diagnostics #>                         Param starting_value     Lower         MLE     Upper #> beta1_ft             beta1_ft    -0.59987818      -Inf -0.59988031       Inf #> beta2_ft             beta2_ft     0.09993558      -Inf  0.09993533       Inf #> L_omega2_z         L_omega2_z     0.55005171      -Inf  0.55005057       Inf #> L_epsilon2_z     L_epsilon2_z     0.26695303      -Inf  0.26695392       Inf #> logkappa2           logkappa2    -4.68896169 -6.214608 -4.68896241 -3.565449 #> Epsilon_rho2_f Epsilon_rho2_f     0.89582671 -0.990000  0.89582684  0.990000 #> logSigmaM           logSigmaM     0.05547811      -Inf  0.05547658 10.000000 #>                final_gradient #> beta1_ft         7.302568e-04 #> beta2_ft         3.958251e-05 #> L_omega2_z       1.120592e-04 #> L_epsilon2_z    -1.263658e-04 #> logkappa2        9.682371e-05 #> Epsilon_rho2_f  -1.138784e-04 #> logSigmaM       -2.509090e-04 #>  #> $SD #> sdreport(.) result #>                   Estimate Std. Error #> beta1_ft       -0.59988031 0.04573745 #> beta2_ft        0.09993533 0.21591340 #> L_omega2_z      0.55005057 0.08905102 #> L_epsilon2_z    0.26695392 0.04043402 #> logkappa2      -4.68896241 0.18202530 #> Epsilon_rho2_f  0.89582684 0.06297620 #> logSigmaM       0.05547658 0.06294172 #> Maximum gradient component: 0.0007302568  #>  #> $time_for_sdreport #> Time difference of 4.173163 secs #>  #> $time_for_run #> Time difference of 22.04336 secs library(sdmTMB) mesh = make_mesh(Data, c(\"x\",\"y\"), n_knots=n_x*n_y )  start_time = Sys.time() mysdmTMB = sdmTMB(   formula = n ~ 1,   data = Data,   mesh = mesh,   spatial = \"on\",   spatiotemporal = \"ar1\",   time = \"time\",   family = tweedie() ) sdmTMBtime = Sys.time() - start_time Times = c( \"tinyVAST\" = mytinyVAST$run_time,            \"VAST\" = myVAST$total_time,            \"sdmTMB\" = sdmTMBtime ) knitr::kable( cbind(\"run times (sec.)\"=Times), digits=1)"},{"path":"https://vast-lib.github.io/tinyVAST/articles/web_only/VAST.html","id":"delta-models","dir":"Articles > Web_only","previous_headings":"","what":"Delta models","title":"Vector autoregressive spatio-temporal models","text":"can also fit data using delta model can use DHARMa package visualize simulation residuals:  can use AIC compare fit delta-model Tweedie distribution:","code":"# fit model mydelta2 = tinyVAST( data = Data,                formula = n ~ 1,                delta_options = list(                  formula = ~ 0 + factor(time),                  spacetime_term = \"logn -> logn, 1, rho\"),                family = delta_lognormal(type=\"poisson-link\"),                spatial_domain = mesh ) #> Warning in deviance_explained(out): Problem detected: deviance explained should #> be between 0 and 1  mydelta2 #> Call:  #> tinyVAST(formula = n ~ 1, data = Data, family = delta_lognormal(type = \"poisson-link\"),  #>     spatial_domain = mesh, delta_options = list(formula = ~0 +  #>         factor(time), spacetime_term = \"logn -> logn, 1, rho\")) #>  #> Run time:  #> Time difference of 0.307236 secs #>  #> Family:  #> $obs #>  #> Family: binomial lognormal  #> Link function: log log  #>  #>  #>  #>  #> sdreport(.) result #> Warning in sqrt(diag(object$cov.fixed)): NaNs produced #>                Estimate Std. Error #> alpha_j    9.673977e-01 0.03523113 #> alpha2_j  -9.722219e-01 0.13721439 #> alpha2_j  -9.890696e-01 0.13927952 #> alpha2_j  -1.000142e+00 0.13927953 #> alpha2_j  -1.021256e+00 0.13721437 #> alpha2_j  -1.250672e+00 0.13721438 #> alpha2_j  -1.163360e+00 0.13654870 #> alpha2_j  -1.396657e+00 0.13857946 #> alpha2_j  -1.232469e+00 0.14220438 #> alpha2_j  -1.120828e+00 0.13589390 #> alpha2_j  -8.562645e-01 0.13721437 #> alpha2_j  -8.935466e-01 0.13721436 #> alpha2_j  -1.194395e+00 0.13589392 #> alpha2_j  -9.129676e-01 0.13721437 #> alpha2_j  -8.283647e-01 0.13461573 #> alpha2_j  -7.688254e-01 0.13524967 #> beta2_z    1.355635e+00        NaN #> beta2_z   -8.062577e-09        NaN #> log_sigma  2.328371e-01 0.01895245 #> Warning: #> Hessian of fixed effects was not positive definite. #> Maximum gradient component: 0.01194501  #>  #> Proportion conditional deviance explained:  #> [1] -0.02549219 #> Warning in sqrt(diag(object$cov.fixed)): NaNs produced #> Warning in sqrt(diag(object$cov.fixed)): NaNs produced #> Warning in sqrt(diag(object$cov.fixed)): NaNs produced #> Warning in sqrt(diag(object$cov.fixed)): NaNs produced #> Warning in sqrt(diag(object$cov.fixed)): NaNs produced #> Warning in sqrt(diag(object$cov.fixed)): NaNs produced #> Warning in sqrt(diag(object$cov.fixed)): NaNs produced #> Warning in sqrt(diag(object$cov.fixed)): NaNs produced #> Fixed terms:  #>              Estimate  Std_Error z_value       p_value #> (Intercept) 0.9673977 0.03523113 27.4586 5.484024e-166 # simulate new data conditional on fixed and random effects y_ir = replicate( n = 100,             expr = mydelta2$obj$simulate()$y_i )  # res = DHARMa::createDHARMa( simulatedResponse = y_ir,                              observedResponse = Data$n,                              fittedPredictedResponse = fitted(mydelta2) ) plot(res) knitr::kable( c(\"Tweedie\"=AIC(mytinyVAST),\"delta-lognormal\"=AIC(mydelta2)), digits=3)"},{"path":"https://vast-lib.github.io/tinyVAST/articles/web_only/VAST.html","id":"bivariate-spatio-temporal-autoregressive-model","dir":"Articles > Web_only","previous_headings":"","what":"Bivariate spatio-temporal autoregressive model","title":"Vector autoregressive spatio-temporal models","text":"next highlight specify bivariate spatio-temporal model cross-laggged (vector autoregressive) interaction. first simulate artificial data sake demonstration: next set inputs run model: values beta_z correspond specified value interaction-matrix B can calculate area-weighted total abundance compare true value:","code":"# Simulate settings theta_xy = 0.2 n_x = n_y = 10 n_t = 20 B = rbind( c( 0.5, -0.25),            c(-0.1,  0.50) )  # Simulate GMRFs R = exp(-theta_xy * abs(outer(1:n_x, 1:n_y, FUN=\"-\")) ) d1 = mvtnorm::rmvnorm(n_t, sigma=0.2*kronecker(R,R) ) d2 = mvtnorm::rmvnorm(n_t, sigma=0.2*kronecker(R,R) ) d = abind::abind( d1, d2, along=3 )  # Project through time and add mean for( t in seq_len(n_t) ){   if(t>1) d[t,,] = t(B%*%t(d[t-1,,])) + d[t,,] }  # Shape into longform data-frame and add error Data = data.frame( expand.grid(time=1:n_t, x=1:n_x, y=1:n_y, \"var\"=c(\"d1\",\"d2\")),                    mu = exp(as.vector(d))) Data$n = tweedie::rtweedie( n=nrow(Data), mu=Data$mu, phi=0.5, power=1.5 ) # make mesh mesh = fm_mesh_2d( Data[,c('x','y')] )  # Define DSEM dsem = \"   d1 -> d1, 1, b11   d2 -> d2, 1, b22   d2 -> d1, 1, b21   d1 -> d2, 1, b12   d1 <-> d1, 0, var1   d2 <-> d2, 0, var1 \"  # fit model out = tinyVAST( spacetime_term = dsem,            data = Data,            formula = n ~ 0 + var,            spatial_domain = mesh,            family = tweedie() ) out #> Call:  #> tinyVAST(formula = n ~ 0 + var, data = Data, spacetime_term = dsem,  #>     family = tweedie(), spatial_domain = mesh) #>  #> Run time:  #> Time difference of 1.393948 mins #>  #> Family:  #> $obs #>  #> Family: tweedie  #> Link function: log  #>  #>  #>  #>  #> sdreport(.) result #>               Estimate Std. Error #> alpha_j   -0.155959190 0.10708939 #> alpha_j    0.091417001 0.10885456 #> beta_z     0.531118986 0.06997634 #> beta_z     0.554429566 0.06998695 #> beta_z    -0.142194712 0.06564120 #> beta_z    -0.098061704 0.06738895 #> beta_z     0.331305819 0.01918731 #> log_sigma -0.687222682 0.02831433 #> log_sigma -0.002508699 0.05116634 #> log_kappa -0.664200731 0.09783507 #> Maximum gradient component: 0.008334427  #>  #> Proportion conditional deviance explained:  #> [1] 0.4494309 #>  #> spacetime_term:  #>   heads to from parameter start lag   Estimate  Std_Error   z_value #> 1     1 d1   d1         1  <NA>   1  0.5311190 0.06997634  7.589980 #> 2     1 d2   d2         2  <NA>   1  0.5544296 0.06998695  7.921900 #> 3     1 d1   d2         3  <NA>   1 -0.1421947 0.06564120 -2.166242 #> 4     1 d2   d1         4  <NA>   1 -0.0980617 0.06738895 -1.455160 #> 5     2 d1   d1         5  <NA>   0  0.3313058 0.01918731 17.266927 #> 6     2 d2   d2         5  <NA>   0  0.3313058 0.01918731 17.266927 #>        p_value #> 1 3.199557e-14 #> 2 2.339088e-15 #> 3 3.029273e-02 #> 4 1.456250e-01 #> 5 8.347066e-67 #> 6 8.347066e-67 #>  #> Fixed terms:  #>         Estimate Std_Error    z_value   p_value #> vard1 -0.1559592 0.1070894 -1.4563459 0.1452970 #> vard2  0.0914170 0.1088546  0.8398086 0.4010157 # Predicted sample-weighted total Est1 = sapply( seq_len(n_t), FUN=\\(t) integrate_output(out, newdata=subset(Data,time==t & var==\"d1\")) ) Est2 = sapply( seq_len(n_t), FUN=\\(t) integrate_output(out, newdata=subset(Data,time==t & var==\"d2\")) )  # True (latent) sample-weighted total True = tapply( Data$mu, INDEX=list(\"time\"=Data$time,\"var\"=Data$var), FUN=sum )  # Index = data.frame( expand.grid(dimnames(True)), \"True\"=as.vector(True) ) Index = data.frame( Index, rbind(t(Est1), t(Est2)) ) Index$low = Index[,'Est...bias.correct.'] - 1.96*Index[,'Std..Error'] Index$high = Index[,'Est...bias.correct.'] + 1.96*Index[,'Std..Error']  # library(ggplot2) ggplot(Index, aes( time, Estimate )) +   facet_grid( rows=vars(var), scales=\"free\" ) +   geom_segment(aes(y = low,                   yend = high,                   x = time,                   xend = time) ) +   geom_point( aes(x=time, y=Estimate), color = \"black\") +   geom_point( aes(x=time, y=True), color = \"red\" )"},{"path":"https://vast-lib.github.io/tinyVAST/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"James T. Thorson. Author, maintainer. Sean C. Anderson. Author.","code":""},{"path":"https://vast-lib.github.io/tinyVAST/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Thorson JT, Ward SC, Goddard P, Rooper CN (2024). “tinyVAST: R package expressive interface specify lagged simultaneous effects multivariate spatio-temporal models.” bioRxiv, 2401.10193. doi:10.48550/arXiv.2401.10193.","code":"@Article{,   title = {tinyVAST: R package with an expressive interface to specify lagged and simultaneous effects in multivariate spatio-temporal models},   author = {James T. Thorson and Sean C. Ward and Pamela Goddard and Christopher N. Rooper},   year = {2024},   journal = {bioRxiv},   volume = {2401.10193},   doi = {10.48550/arXiv.2401.10193}, }"},{"path":"https://vast-lib.github.io/tinyVAST/header.html","id":null,"dir":"","previous_headings":"","what":"tinyVAST","title":"tinyVAST","text":"Multivariate spatio-temporal models using dynamic structural equations  tinyVAST R package fits multivariate spatio-temporal models using Gaussian Markov random fields represent nonseparable interactions among variables time. See preprint: Thorson, J. T., Anderson, S. C., Goddard, P., & Rooper, C. N. (2024). tinyVAST: R package expressive interface specify lagged simultaneous effects multivariate spatio-temporal models (arXiv:2401.10193). arXiv. http://arxiv.org/abs/2401.10193","code":""},{"path":[]},{"path":"https://vast-lib.github.io/tinyVAST/index.html","id":"tinyvast","dir":"","previous_headings":"","what":"Multivariate Spatio-Temporal Models using Dynamic Structural Equations as Expressive Interface","title":"Multivariate Spatio-Temporal Models using Dynamic Structural Equations as Expressive Interface","text":"Multivariate spatio-temporal models using dynamic structural equations tinyVAST R package fits multivariate spatio-temporal models using Gaussian Markov random fields represent nonseparable interactions among variables time. See preprint: Thorson, J. T., Anderson, S. C., Goddard, P., & Rooper, C. N. (2024). tinyVAST: R package expressive interface specify lagged simultaneous effects multivariate spatio-temporal models (arXiv:2401.10193). arXiv. http://arxiv.org/abs/2401.10193","code":""},{"path":"https://vast-lib.github.io/tinyVAST/index.html","id":"table-of-contents","dir":"","previous_headings":"","what":"Table of contents","title":"Multivariate Spatio-Temporal Models using Dynamic Structural Equations as Expressive Interface","text":"Installation Citation Related software","code":""},{"path":"https://vast-lib.github.io/tinyVAST/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Multivariate Spatio-Temporal Models using Dynamic Structural Equations as Expressive Interface","text":"tinyVAST can installed GitHub:","code":"library(devtools) install_github(\"vast-lib/tinyVAST\", dependencies = TRUE)"},{"path":"https://vast-lib.github.io/tinyVAST/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Multivariate Spatio-Temporal Models using Dynamic Structural Equations as Expressive Interface","text":"cite tinyVAST publications use: Thorson, J. T., Anderson, S. C., Goddard, P., & Rooper, C. N. (2024). tinyVAST: R package expressive interface specify lagged simultaneous effects multivariate spatio-temporal models (arXiv:2401.10193). arXiv. http://arxiv.org/abs/2401.10193","code":"citation(\"tinyVAST\")"},{"path":"https://vast-lib.github.io/tinyVAST/index.html","id":"related-software","dir":"","previous_headings":"","what":"Related software","title":"Multivariate Spatio-Temporal Models using Dynamic Structural Equations as Expressive Interface","text":"tinyVAST builds upon many packages. includes VAST R package: Thorson, J.T. 2019. Guidance decisions using Vector Autoregressive Spatio-Temporal (VAST) package stock, ecosystem, habitat climate assessments. Fisheries Research 210: 143–161. https://doi.org/10.1016/j.fishres.2018.10.013. sdmTMB R package: Anderson, S.C., E.J. Ward, P.. English, L..K. Barnett. 2022. sdmTMB: R package fast, flexible, user-friendly generalized linear mixed effects models spatial spatiotemporal random fields. bioRxiv 2022.03.24.485545; doi: https://doi.org/10.1101/2022.03.24.485545 glmmTMB R package: Brooks, M.E., Kristensen, K., van Benthem, K.J., Magnusson, ., Berg, C.W., Nielsen, ., Skaug, H.J., Maechler, M., Bolker, B.M. 2017. glmmTMB balances speed flexibility among packages zero-inflated generalized linear mixed modeling. R Journal 9(2): 378–400. https://doi.org/10.32614/rj-2017-066. INLA inlabru can fit many models sdmTMB (many ) approximate Bayesian inference framework. mgcv can fit similar SPDE-based Gaussian random field models code included Miller et al. (2019).","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/add_predictions.html","id":null,"dir":"Reference","previous_headings":"","what":"Add predictions to data-list — add_predictions","title":"Add predictions to data-list — add_predictions","text":"Given user-provided newdata, expand object tmb_data include predictions corresponding new observations","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/add_predictions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add predictions to data-list — add_predictions","text":"","code":"add_predictions(object, newdata, remove_origdata = FALSE)"},{"path":"https://vast-lib.github.io/tinyVAST/reference/add_predictions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add predictions to data-list — add_predictions","text":"object Output tinyVAST(). newdata New data-frame independent variables used predict response. remove_origdata Whether remove original-data allow faster evaluation. remove_origdata=TRUE eliminates information distribution random effects, combined epsilon bias-correction. WARNING:  feature experimental subject change.","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/bering_sea.html","id":null,"dir":"Reference","previous_headings":"","what":"Survey domain for the eastern and northern Bering Sea surveys — bering_sea","title":"Survey domain for the eastern and northern Bering Sea surveys — bering_sea","text":"Shapefile defining spatial domain eastern northern Bering Sea bottom trawl surveys.","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/bering_sea.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Survey domain for the eastern and northern Bering Sea surveys — bering_sea","text":"","code":"data(bering_sea)"},{"path":"https://vast-lib.github.io/tinyVAST/reference/bering_sea_pollock_ages.html","id":null,"dir":"Reference","previous_headings":"","what":"Survey catch-rates at age for Alaska pollock in the Eastern and Northern Bering Sea — bering_sea_pollock_ages","title":"Survey catch-rates at age for Alaska pollock in the Eastern and Northern Bering Sea — bering_sea_pollock_ages","text":"Data used demonstrate test model-based age expansion, using density= dependence corrected survey catch rates first=stage expansion bottom trawl survey ages 1-15, conducted Alaska Fisheries Science Center, including annual surveys eastern Bering Sea 1982-2019 2021-2023, well northern Bering Sea 1982/85/88/91 2010/17/18/19/21/22/23.","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/bering_sea_pollock_ages.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Survey catch-rates at age for Alaska pollock in the Eastern and Northern Bering Sea — bering_sea_pollock_ages","text":"","code":"data(bering_sea_pollock_ages)"},{"path":"https://vast-lib.github.io/tinyVAST/reference/bering_sea_pollock_vast.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimated proportion-at-age for Alaska pollock using VAST — bering_sea_pollock_vast","title":"Estimated proportion-at-age for Alaska pollock using VAST — bering_sea_pollock_vast","text":"Estimated proporrtion--age Alaska pollock using package VAST, comparison output using tinyVAST.","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/bering_sea_pollock_vast.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimated proportion-at-age for Alaska pollock using VAST — bering_sea_pollock_vast","text":"","code":"data(bering_sea_pollock_vast)"},{"path":"https://vast-lib.github.io/tinyVAST/reference/cAIC.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate conditional AIC — cAIC","title":"Calculate conditional AIC — cAIC","text":"Calculates conditional Akaike Information criterion (cAIC).","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/cAIC.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate conditional AIC — cAIC","text":"","code":"cAIC(object)"},{"path":"https://vast-lib.github.io/tinyVAST/reference/cAIC.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate conditional AIC — cAIC","text":"object Output tinyVAST().","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/cAIC.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate conditional AIC — cAIC","text":"cAIC value","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/cAIC.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate conditional AIC — cAIC","text":"cAIC designed optimize expected --sample predictive performance new data share random effects -sample (fitted) data, e.g., spatial interpolation.  sense, fast approximation optimizing model structure based k-fold cross-validation. contrast, AIC() calculates marginal Akaike Information Criterion, designed optimize expected predictive performance new data new random effects, e.g., extrapolation, inference generative parameters. cAIC EDF calculated using Eq. 6 Zheng, Cadigan, Thorson (2024). models include profiled fixed effects, profiles turned .","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/cAIC.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Calculate conditional AIC — cAIC","text":"Zheng, N., Cadigan, N., & Thorson, J. T. (2024). note numerical evaluation conditional Akaike information nonlinear mixed-effects models (arXiv:2411.14185). arXiv. doi:10.48550/arXiv.2411.14185","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/cAIC.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate conditional AIC — cAIC","text":"","code":"data( red_snapper ) red_snapper = droplevels(subset(red_snapper, Data_type==\"Biomass_KG\"))  # Define mesh mesh = fmesher::fm_mesh_2d( red_snapper[,c('Lon','Lat')],                            cutoff = 1 )  # define formula with a catchability covariate for gear formula = Response_variable ~ factor(Year) + offset(log(AreaSwept_km2))  # make variable column red_snapper$var = \"logdens\" # fit using tinyVAST fit = tinyVAST( data = red_snapper,                 formula = formula,                 sem = \"logdens <-> logdens, sd_space\",                 space_columns = c(\"Lon\",'Lat'),                 spatial_graph = mesh,                 family = tweedie(link=\"log\"),                 variable_column = \"var\",                 control = tinyVASTcontrol( getsd = FALSE,                                            profile = \"alpha_j\" ) )  cAIC(fit) #> [1] 44863.47"},{"path":"https://vast-lib.github.io/tinyVAST/reference/classify_variables.html","id":null,"dir":"Reference","previous_headings":"","what":"Classify variables path — classify_variables","title":"Classify variables path — classify_variables","text":"classify_variables copied sem:::classifyVariables","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/classify_variables.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Classify variables path — classify_variables","text":"","code":"classify_variables(model)"},{"path":"https://vast-lib.github.io/tinyVAST/reference/classify_variables.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Classify variables path — classify_variables","text":"model syntax structural equation model","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/classify_variables.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Classify variables path — classify_variables","text":"Tagged-list defining exogenous endogenous variables","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/classify_variables.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Classify variables path — classify_variables","text":"Copied package sem licence GPL (>= 2) permission John Fox","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/condition_and_density.html","id":null,"dir":"Reference","previous_headings":"","what":"Condition and density example — condition_and_density","title":"Condition and density example — condition_and_density","text":"Data used demonstrate test bivariate model morphometric condition (.e., residuals weight--length relationship) density fishes, using example provided wiki example VAST. Data doi:10.3354/meps13213","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/condition_and_density.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Condition and density example — condition_and_density","text":"","code":"data(condition_and_density)"},{"path":"https://vast-lib.github.io/tinyVAST/reference/deviance_explained.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate deviance explained — deviance_explained","title":"Calculate deviance explained — deviance_explained","text":"deviance_explained fits null model, calculates deviance relative saturated model original null model, uses calculate proportion deviance explained. implementation conditions upon maximum likelihood estimate fixed effects empirical Bayes (\"plug-\") prediction random effects.  can described \"conditional deviance explained\". state-space model estimates measurement error variance approaching zero (.e., collapses process-error-model) conditional deviance explained approaches 1.0","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/deviance_explained.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate deviance explained — deviance_explained","text":"","code":"deviance_explained(x, null_formula, null_delta_formula = ~1)"},{"path":"https://vast-lib.github.io/tinyVAST/reference/deviance_explained.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate deviance explained — deviance_explained","text":"x output \\code{tinyVAST()} null_formula formula null model.  missing, uses null_formula = response ~ 1. multivariate models, might make sense use null_formula = response ~ category null_delta_formula formula null model delta component. missing, uses null_formula = response ~ 1. multivariate models, might make sense use null_delta_formula = response ~ category","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/families.html","id":null,"dir":"Reference","previous_headings":"","what":"Additional families — Families","title":"Additional families — Families","text":"Additional families compatible tinyVAST().","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/families.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Additional families — Families","text":"","code":"delta_lognormal(link1, link2 = \"log\", type = c(\"standard\", \"poisson-link\"))  delta_gamma(link1, link2 = \"log\", type = c(\"standard\", \"poisson-link\"))"},{"path":"https://vast-lib.github.io/tinyVAST/reference/families.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Additional families — Families","text":"link1 Link first part delta/hurdle model. link2 Link second part delta/hurdle model. type Delta/hurdle family type. \"standard\" classic hurdle model. \"poisson-link\" Poisson-link delta model (Thorson 2018). link Link.","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/families.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Additional families — Families","text":"list elements common standard R family objects including family, link, linkfun, linkinv. Delta/hurdle model families also elements delta (logical) type (standard vs. Poisson-link).","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/families.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Additional families — Families","text":"Poisson-link delta families: Thorson, J.T. 2018. Three problems conventional delta-model biomass sampling data, computationally efficient alternative. Canadian Journal Fisheries Aquatic Sciences, 75(9), 1369-1382. doi:10.1139/cjfas-2017-0266","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/families.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Additional families — Families","text":"","code":"delta_lognormal() #>  #> Family: binomial lognormal  #> Link function: log log  #>  delta_gamma() #>  #> Family: binomial Gamma  #> Link function: logit log  #>"},{"path":"https://vast-lib.github.io/tinyVAST/reference/integrate_output.html","id":null,"dir":"Reference","previous_headings":"","what":"Integration for target variable — integrate_output","title":"Integration for target variable — integrate_output","text":"Calculates estimator derived quantity summing across multiple predictions. can used approximate integral estimating area-expanded abundance, abundance-weighting covariate calculate distribution shifts, /weighting one model variable another.","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/integrate_output.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Integration for target variable — integrate_output","text":"","code":"integrate_output(   object,   newdata,   area,   type = rep(1, nrow(newdata)),   weighting_index,   covariate,   getsd = TRUE,   bias.correct = TRUE,   apply.epsilon = FALSE,   intern = FALSE )"},{"path":"https://vast-lib.github.io/tinyVAST/reference/integrate_output.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Integration for target variable — integrate_output","text":"object Output tinyVAST(). newdata New data-frame independent variables used predict response, total value calculated combining across individual predictions. locations randomly drawn specified spatial domain, integrate_output applies midpoint integration approximate total area.  locations drawn sysmatically domain, integrate_output applying midpoint approximation integral. area vector values used area-weighted expansion estimated density surface row newdata length nrow(newdata). type Integer-vector indicating type expansion apply row newdata, length nrow(newdata). type=1 Area-weighting: weight predictor argument area type=2 Abundance-weighted covariate: weight covariate proportion total row newdata type=3 Abundance-weighted variable: weight predictor proportion total prior row newdata. option used weight prediction one category based predicted proportional density another category, e.g., calculate abundance-weighted condition bivariate model. type=4 Abundance-expanded variable: weight predictor density prior row newdata. option used weight prediction one category based predicted density another category, e.g., calculate abundance-expanded consumption bivariate model. type=0 Exclude weighting: give weight zero given row newdata. Including row newdata type=0 useful, e.g., calculating abundance location, eventual index uses abundance weighting term without otherwise using predicted density calculating total value. weighting_index integer-vector used indicate previous row used calculate weighted average applied given row newdata. used type=3. covariate numeric-vector used provide covariate used expansion, e.g., provide positional coordinates calculating abundance-weighted centroid respect coordinate. used type=2. getsd logical indicating whether get standard error, getsd=FALSE faster initial exploration bias.correct logical indicating bias correction applied using standard methods TMB::sdreport() apply.epsilon Apply epsilon bias correction using manual calculation rather using conventional method TMB::sdreport? See details information. intern Laplace approximation C++ side? Passed TMB::MakeADFun().","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/integrate_output.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Integration for target variable — integrate_output","text":"Analysts often want calculate value combining predicted response multiple locations, potentially multiple variables multivariate analysis. arises univariate model, e.g., calculating integral predicted density function, approximated using midpoint Monte Carlo approximation calculating linear predictors location newdata, applying inverse-link-trainsformation, calling predicted response mu_g.  Total abundance approximated multiplying mu_g area associated midpoint Monte Carlo approximation point (supplied argument area), summing across area-expanded values. complicated cases, analyst can use covariate calculate weighted average covariate midpoint location. example, covariate positional coordinates depth/elevation, type=2 measures shifts average habitat utilization respect covariate. Alternatively, analyst fitting multivariate model might weight one variable based another using weighting_index, e.g., calculate abundance-weighted average condition, predator-expanded stomach contents. practice, spatial integration multivariate model requires two passes rows newdata calculating total value.  following, write equations using C++ indexing conventions indexing starts 0, match way integrate_output expects indices supplied. Given inverse-link-transformed predictor \\( \\mu_g \\), function argument type \\( type_g \\) function argument area \\( a_g \\), function argument covariate \\( x_g \\), function argument weighting_index \\eqn{ h_g } function argument weighting_index \\eqn{ h_g } first pass calculates: $$ \\nu_g = \\mu_g a_g $$ total value first pass calculated : $$ \\nu^* = \\sum_{g=0}^{G-1} \\nu_g $$ second pass applies weighting, depends upon \\( type_g \\), potentially upon \\( x_g \\) \\( h_g \\). \\(type_g = 0\\) \\(\\phi_g = 0\\) \\(type_g = 1\\) \\(\\phi_g = \\nu_g\\) \\(type_g = 2\\) \\(\\phi_g = x_g \\frac{\\nu_g}{\\nu^*} \\) \\(type_g = 3\\) \\(\\phi_g = \\frac{\\nu_{h_g}}{\\nu^*} \\mu_g \\) \\(type_g = 4\\) \\(\\phi_g = \\nu_{h_g} \\mu_g \\) Finally, total value second pass calculated : $$ \\phi^* = \\sum_{g=0}^{G-1} \\phi_g $$ \\(\\phi^*\\) outputted integrate_output, along standard error potentially using epsilon bias-correction estimator correct skewness retransformation bias. Standard bias-correction using bias.correct=TRUE can slow, cases might faster apply.epsilon=TRUE intern=TRUE. However, option somewhat experimental, user might want confirm two options give identical results. Similarly, using bias.correct=TRUE still calculate standard-error, whereas using apply.epsilon=TRUE intern=TRUE .","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/make_dsem_ram.html","id":null,"dir":"Reference","previous_headings":"","what":"Make a RAM (Reticular Action Model) — make_dsem_ram","title":"Make a RAM (Reticular Action Model) — make_dsem_ram","text":"make_dsem_ram converts SEM arrow notation ram describing SEM parameters","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/make_dsem_ram.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make a RAM (Reticular Action Model) — make_dsem_ram","text":"","code":"make_dsem_ram(   dsem,   times,   variables,   covs = NULL,   quiet = FALSE,   remove_na = TRUE )"},{"path":"https://vast-lib.github.io/tinyVAST/reference/make_dsem_ram.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make a RAM (Reticular Action Model) — make_dsem_ram","text":"dsem dynamic structural equation model structure, passed either specifyModel specifyEquations parsed control set path coefficients variance-covariance parameters times character vector listing set times order variables character vector listing set variables covs optional: character vector one elements, element   \tgiving string variable names, separated commas. Variances covariances   \tamong variables string added model. confirmatory   \tfactor analysis models specified via cfa, covs defaults   \tfactors model, thus specifying variances covariances among factors.   \tWarning: covs=\"x1, x2\" covs=c(\"x1\", \"x2\")   \tequivalent: covs=\"x1, x2\" specifies variance x1, variance   \tx2, covariance, covs=c(\"x1\", \"x2\") specifies   \tvariance x1 variance x2 covariance. quiet Boolean indicating whether print messages terminal remove_na Boolean indicating whether remove NA values RAM (default) . remove_NA=FALSE might useful exploration diagnostics advanced users","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/make_dsem_ram.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make a RAM (Reticular Action Model) — make_dsem_ram","text":"reticular action module (RAM) describing dependencies","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/make_dsem_ram.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Make a RAM (Reticular Action Model) — make_dsem_ram","text":"RAM specification using arrow--lag notation line RAM specification make_dsem_ram consists four (unquoted) entries, separated commas: 1. Arrow specification: simple formula, form -> B , equivalently, B <- regression coefficient (.e., single-headed directional arrow); <-> variance <-> B covariance (.e., double-headed bidirectional arrow). , B variable names model. name correspond observed variable, assumed latent variable. Spaces can appear freely arrow specification, can number hyphens arrows, including zero: Thus, e.g., ->B, --> B, >B legitimate equivalent. 2. Lag (using positive values): integer specifying whether linkage simultaneous (lag=0) lagged (e.g., X -> Y, 1, XtoY indicates X time T affects Y time T+1), one-headed arrows can lagged. Using positive values indicate lags matches notational convention used package dynlm. 3. Parameter name: name regression coefficient, variance, covariance specified arrow. Assigning name two arrows results equality constraint. Specifying parameter name NA produces fixed parameter. 4. Value: start value free parameter value fixed parameter. given NA (simply omitted), model provide default starting value. Lines may end comment following #. function extends code copied package sem licence GPL (>= 2) permission John Fox. Simultaneous autoregressive process simultaneous lagged effects text specifies linkages multivariate time-series model variables \\(\\mathbf X\\) dimensions \\(T \\times C\\) \\(T\\) times \\(C\\) variables. make_dsem_ram parses text build path matrix \\(\\mathbf P\\) dimensions \\(TC \\times TC\\), \\(\\rho_{k_2,k_1}\\) represents impact \\(x_{t_1,c_1}\\) \\(x_{t_2,c_2}\\), \\(k_1=T c_1+t_1\\) \\(k_2=T c_2+t_2\\).  path matrix defines simultaneous equation $$ \\mathrm{vec}(\\mathbf X) = \\mathbf P \\mathrm{vec}(\\mathbf X) + \\mathrm{vec}(\\mathbf \\Delta)$$ \\(\\mathbf \\Delta\\) matrix exogenous errors covariance \\(\\mathbf{V = \\Gamma \\Gamma}^t\\), \\(\\mathbf \\Gamma\\) Cholesky exogenous covariance.  simultaneous autoregressive (SAR) process results \\(\\mathbf X\\) covariance: $$ \\mathrm{Cov}(\\mathbf X) = \\mathbf{(- P)}^{-1} \\mathbf{\\Gamma \\Gamma}^t \\mathbf{((- P)}^{-1})^t $$ Usefully, also easy compute inverse-covariance (precision) matrix \\(\\mathbf{Q = V}^{-1}\\): $$ \\mathbf{Q} = (\\mathbf{\\Gamma}^{-1} \\mathbf{(- P)})^t \\mathbf{\\Gamma}^{-1} \\mathbf{(- P)} $$ Example: univariate first-order autoregressive model simultaneous autoregressive (SAR) process across variables times allows user specify simultaneous effects (effects among variables within year \\(T\\)) lagged effects (effects among variables among years \\(T\\)). one example, consider univariate first-order autoregressive process \\(T=4\\). independent errors.  specified passing  dsem = X -> X, 1, rho; X <-> X, 0, sigma  make_dsem_ram. parsed RAM: Rows RAM heads=1 interpreted construct path matrix \\(\\mathbf P\\):   rows heads=2 interpreted construct Cholesky exogenous covariance \\(\\mathbf \\Gamma\\):   two estimated parameters \\(\\mathbf \\beta = (\\rho, \\sigma) \\). results covariance:   Similarly, arrow--lag notation can used specify SAR representing conventional structural equation model (SEM), cross-lagged (.k.. vector autoregressive) models (VAR), dynamic factor analysis (DFA), many time-series models.","code":"\\deqn{ \\mathbf P = \\begin{bmatrix}      0 & 0 & 0 & 0 \\      \\rho & 0 & 0 & 0 \\      0 & \\rho & 0 & 0 \\      0 & 0 & \\rho & 0\\      \\end{bmatrix} } \\deqn{ \\mathbf \\Gamma = \\begin{bmatrix}      \\sigma & 0 & 0 & 0 \\      0 & \\sigma & 0 & 0 \\      0 & 0 & \\sigma & 0 \\      0 & 0 & 0 & \\sigma\\      \\end{bmatrix} } \\deqn{ \\mathrm{Cov}(\\mathbf X) = \\sigma^2 \\begin{bmatrix}      1 & \\rho^1 & \\rho^2 & \\rho^3 \\      \\rho^1 & 1 & \\rho^1 & \\rho^2 \\      \\rho^2 & \\rho^1 & 1 & \\rho^1 \\      \\rho^3 & \\rho^2 & \\rho^1 & 1\\      \\end{bmatrix} }"},{"path":"https://vast-lib.github.io/tinyVAST/reference/make_dsem_ram.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Make a RAM (Reticular Action Model) — make_dsem_ram","text":"","code":"# Univariate AR1 dsem = \"   X -> X, 1, rho   X <-> X, 0, sigma \" make_dsem_ram( dsem=dsem, variables=\"X\", times=1:4 ) #> $model #>      path      lag name    start parameter first second direction #> [1,] \"X -> X\"  \"1\" \"rho\"   NA    \"1\"       \"X\"   \"X\"    \"1\"       #> [2,] \"X <-> X\" \"0\" \"sigma\" NA    \"2\"       \"X\"   \"X\"    \"2\"       #>  #> $ram #>   heads to from parameter start #> 1     1  2    1         1  <NA> #> 2     1  3    2         1  <NA> #> 3     1  4    3         1  <NA> #> 5     2  1    1         2  <NA> #> 6     2  2    2         2  <NA> #> 7     2  3    3         2  <NA> #> 8     2  4    4         2  <NA> #>  #> attr(,\"class\") #> [1] \"dsem_ram\"  # Univariate AR2 dsem = \"   X -> X, 1, rho1   X -> X, 2, rho2   X <-> X, 0, sigma \" make_dsem_ram( dsem=dsem, variables=\"X\", times=1:4 ) #> $model #>      path      lag name    start parameter first second direction #> [1,] \"X -> X\"  \"1\" \"rho1\"  NA    \"1\"       \"X\"   \"X\"    \"1\"       #> [2,] \"X -> X\"  \"2\" \"rho2\"  NA    \"2\"       \"X\"   \"X\"    \"1\"       #> [3,] \"X <-> X\" \"0\" \"sigma\" NA    \"3\"       \"X\"   \"X\"    \"2\"       #>  #> $ram #>    heads to from parameter start #> 1      1  2    1         1  <NA> #> 2      1  3    2         1  <NA> #> 3      1  4    3         1  <NA> #> 5      1  3    1         2  <NA> #> 6      1  4    2         2  <NA> #> 9      2  1    1         3  <NA> #> 10     2  2    2         3  <NA> #> 11     2  3    3         3  <NA> #> 12     2  4    4         3  <NA> #>  #> attr(,\"class\") #> [1] \"dsem_ram\"  # Bivariate VAR dsem = \"   X -> X, 1, XtoX   X -> Y, 1, XtoY   Y -> X, 1, YtoX   Y -> Y, 1, YtoY   X <-> X, 0, sdX   Y <-> Y, 0, sdY \" make_dsem_ram( dsem=dsem, variables=c(\"X\",\"Y\"), times=1:4 ) #> $model #>      path      lag name   start parameter first second direction #> [1,] \"X -> X\"  \"1\" \"XtoX\" NA    \"1\"       \"X\"   \"X\"    \"1\"       #> [2,] \"X -> Y\"  \"1\" \"XtoY\" NA    \"2\"       \"X\"   \"Y\"    \"1\"       #> [3,] \"Y -> X\"  \"1\" \"YtoX\" NA    \"3\"       \"Y\"   \"X\"    \"1\"       #> [4,] \"Y -> Y\"  \"1\" \"YtoY\" NA    \"4\"       \"Y\"   \"Y\"    \"1\"       #> [5,] \"X <-> X\" \"0\" \"sdX\"  NA    \"5\"       \"X\"   \"X\"    \"2\"       #> [6,] \"Y <-> Y\" \"0\" \"sdY\"  NA    \"6\"       \"Y\"   \"Y\"    \"2\"       #>  #> $ram #>    heads to from parameter start #> 1      1  2    1         1  <NA> #> 2      1  3    2         1  <NA> #> 3      1  4    3         1  <NA> #> 5      1  6    1         2  <NA> #> 6      1  7    2         2  <NA> #> 7      1  8    3         2  <NA> #> 9      1  2    5         3  <NA> #> 10     1  3    6         3  <NA> #> 11     1  4    7         3  <NA> #> 13     1  6    5         4  <NA> #> 14     1  7    6         4  <NA> #> 15     1  8    7         4  <NA> #> 17     2  1    1         5  <NA> #> 18     2  2    2         5  <NA> #> 19     2  3    3         5  <NA> #> 20     2  4    4         5  <NA> #> 21     2  5    5         6  <NA> #> 22     2  6    6         6  <NA> #> 23     2  7    7         6  <NA> #> 24     2  8    8         6  <NA> #>  #> attr(,\"class\") #> [1] \"dsem_ram\"  # Dynamic factor analysis with one factor and two manifest variables # (specifies a random-walk for the factor, and miniscule residual SD) dsem = \"   factor -> X, 0, loadings1   factor -> Y, 0, loadings2   factor -> factor, 1, NA, 1   X <-> X, 0, NA, 0           # No additional variance   Y <-> Y, 0, NA, 0           # No additional variance \" make_dsem_ram( dsem=dsem, variables=c(\"X\",\"Y\",\"factor\"), times=1:4 ) #> NOTE: adding 1 variances to the model #> $model #>                                              parameter first    second   #> [1,] \"factor -> X\"       \"0\" \"loadings1\" NA  \"1\"       \"factor\" \"X\"      #> [2,] \"factor -> Y\"       \"0\" \"loadings2\" NA  \"2\"       \"factor\" \"Y\"      #> [3,] \"factor -> factor\"  \"1\" NA          \"1\" \"0\"       \"factor\" \"factor\" #> [4,] \"X <-> X\"           \"0\" NA          \"0\" \"0\"       \"X\"      \"X\"      #> [5,] \"Y <-> Y\"           \"0\" NA          \"0\" \"0\"       \"Y\"      \"Y\"      #> [6,] \"factor <-> factor\" \"0\" \"V[factor]\" NA  \"3\"       \"factor\" \"factor\" #>      direction #> [1,] \"1\"       #> [2,] \"1\"       #> [3,] \"1\"       #> [4,] \"2\"       #> [5,] \"2\"       #> [6,] \"2\"       #>  #> $ram #>    heads to from parameter start #> 1      1  1    9         1  <NA> #> 2      1  2   10         1  <NA> #> 3      1  3   11         1  <NA> #> 4      1  4   12         1  <NA> #> 5      1  5    9         2  <NA> #> 6      1  6   10         2  <NA> #> 7      1  7   11         2  <NA> #> 8      1  8   12         2  <NA> #> 9      1 10    9         0     1 #> 10     1 11   10         0     1 #> 11     1 12   11         0     1 #> 13     2  1    1         0     0 #> 14     2  2    2         0     0 #> 15     2  3    3         0     0 #> 16     2  4    4         0     0 #> 17     2  5    5         0     0 #> 18     2  6    6         0     0 #> 19     2  7    7         0     0 #> 20     2  8    8         0     0 #> 21     2  9    9         3  <NA> #> 22     2 10   10         3  <NA> #> 23     2 11   11         3  <NA> #> 24     2 12   12         3  <NA> #>  #> attr(,\"class\") #> [1] \"dsem_ram\"  # ARIMA(1,1,0) dsem = \"   factor -> factor, 1, rho1 # AR1 component   X -> X, 1, NA, 1          # Integrated component   factor -> X, 0, NA, 1   X <-> X, 0, NA, 0         # No additional variance \" make_dsem_ram( dsem=dsem, variables=c(\"X\",\"factor\"), times=1:4 ) #> NOTE: adding 1 variances to the model #> $model #>                                              parameter first    second   #> [1,] \"factor -> factor\"  \"1\" \"rho1\"      NA  \"1\"       \"factor\" \"factor\" #> [2,] \"X -> X\"            \"1\" NA          \"1\" \"0\"       \"X\"      \"X\"      #> [3,] \"factor -> X\"       \"0\" NA          \"1\" \"0\"       \"factor\" \"X\"      #> [4,] \"X <-> X\"           \"0\" NA          \"0\" \"0\"       \"X\"      \"X\"      #> [5,] \"factor <-> factor\" \"0\" \"V[factor]\" NA  \"2\"       \"factor\" \"factor\" #>      direction #> [1,] \"1\"       #> [2,] \"1\"       #> [3,] \"1\"       #> [4,] \"2\"       #> [5,] \"2\"       #>  #> $ram #>    heads to from parameter start #> 1      1  6    5         1  <NA> #> 2      1  7    6         1  <NA> #> 3      1  8    7         1  <NA> #> 5      1  2    1         0     1 #> 6      1  3    2         0     1 #> 7      1  4    3         0     1 #> 9      1  1    5         0     1 #> 10     1  2    6         0     1 #> 11     1  3    7         0     1 #> 12     1  4    8         0     1 #> 13     2  1    1         0     0 #> 14     2  2    2         0     0 #> 15     2  3    3         0     0 #> 16     2  4    4         0     0 #> 17     2  5    5         2  <NA> #> 18     2  6    6         2  <NA> #> 19     2  7    7         2  <NA> #> 20     2  8    8         2  <NA> #>  #> attr(,\"class\") #> [1] \"dsem_ram\"  # ARIMA(0,0,1) dsem = \"   factor -> X, 0, NA, 1   factor -> X, 1, rho1     # MA1 component   X <-> X, 0, NA, 0        # No additional variance \" make_dsem_ram( dsem=dsem, variables=c(\"X\",\"factor\"), times=1:4 ) #> NOTE: adding 1 variances to the model #> $model #>                                              parameter first    second   #> [1,] \"factor -> X\"       \"0\" NA          \"1\" \"0\"       \"factor\" \"X\"      #> [2,] \"factor -> X\"       \"1\" \"rho1\"      NA  \"1\"       \"factor\" \"X\"      #> [3,] \"X <-> X\"           \"0\" NA          \"0\" \"0\"       \"X\"      \"X\"      #> [4,] \"factor <-> factor\" \"0\" \"V[factor]\" NA  \"2\"       \"factor\" \"factor\" #>      direction #> [1,] \"1\"       #> [2,] \"1\"       #> [3,] \"2\"       #> [4,] \"2\"       #>  #> $ram #>    heads to from parameter start #> 1      1  1    5         0     1 #> 2      1  2    6         0     1 #> 3      1  3    7         0     1 #> 4      1  4    8         0     1 #> 5      1  2    5         1  <NA> #> 6      1  3    6         1  <NA> #> 7      1  4    7         1  <NA> #> 9      2  1    1         0     0 #> 10     2  2    2         0     0 #> 11     2  3    3         0     0 #> 12     2  4    4         0     0 #> 13     2  5    5         2  <NA> #> 14     2  6    6         2  <NA> #> 15     2  7    7         2  <NA> #> 16     2  8    8         2  <NA> #>  #> attr(,\"class\") #> [1] \"dsem_ram\""},{"path":"https://vast-lib.github.io/tinyVAST/reference/make_eof_ram.html","id":null,"dir":"Reference","previous_headings":"","what":"Make a RAM (Reticular Action Model) — make_eof_ram","title":"Make a RAM (Reticular Action Model) — make_eof_ram","text":"make_eof_ram converts SEM arrow notation ram describing SEM parameters","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/make_eof_ram.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make a RAM (Reticular Action Model) — make_eof_ram","text":"","code":"make_eof_ram(   times,   variables,   n_eof,   remove_na = TRUE,   standard_deviations = \"unequal\" )"},{"path":"https://vast-lib.github.io/tinyVAST/reference/make_eof_ram.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make a RAM (Reticular Action Model) — make_eof_ram","text":"times character vector listing set times order variables character vector listing set variables n_eof Number EOF modes variability estimate remove_na Boolean indicating whether remove NA values RAM (default) . remove_NA=FALSE might useful exploration diagnostics advanced users standard_deviations One \"equal\", \"unequal\", numeric vector indicating fixed values.","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/make_eof_ram.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make a RAM (Reticular Action Model) — make_eof_ram","text":"reticular action module (RAM) describing dependencies","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/make_eof_ram.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Make a RAM (Reticular Action Model) — make_eof_ram","text":"","code":"# Two EOFs for two variables make_eof_ram( times = 2010:2020, variables = c(\"pollock\",\"cod\"), n_eof=2 ) #> $model #>      to  from parameter #> 1  2010 EOF_1         1 #> 2  2011 EOF_1         2 #> 3  2012 EOF_1         3 #> 4  2013 EOF_1         4 #> 5  2014 EOF_1         5 #> 6  2015 EOF_1         6 #> 7  2016 EOF_1         7 #> 8  2017 EOF_1         8 #> 9  2018 EOF_1         9 #> 10 2019 EOF_1        10 #> 11 2020 EOF_1        11 #> 12 2010 EOF_2        NA #> 13 2011 EOF_2        12 #> 14 2012 EOF_2        13 #> 15 2013 EOF_2        14 #> 16 2014 EOF_2        15 #> 17 2015 EOF_2        16 #> 18 2016 EOF_2        17 #> 19 2017 EOF_2        18 #> 20 2018 EOF_2        19 #> 21 2019 EOF_2        20 #> 22 2020 EOF_2        21 #>  #> $ram #>        heads to from parameter start #>   [1,]     1  3    1         1  0.01 #>   [2,]     1  4    1         2  0.01 #>   [3,]     1  5    1         3  0.01 #>   [4,]     1  6    1         4  0.01 #>   [5,]     1  7    1         5  0.01 #>   [6,]     1  8    1         6  0.01 #>   [7,]     1  9    1         7  0.01 #>   [8,]     1 10    1         8  0.01 #>   [9,]     1 11    1         9  0.01 #>  [10,]     1 12    1        10  0.01 #>  [11,]     1 13    1        11  0.01 #>  [12,]     1 16    1         1  0.01 #>  [13,]     1 17    1         2  0.01 #>  [14,]     1 18    1         3  0.01 #>  [15,]     1 19    1         4  0.01 #>  [16,]     1 20    1         5  0.01 #>  [17,]     1 21    1         6  0.01 #>  [18,]     1 22    1         7  0.01 #>  [19,]     1 23    1         8  0.01 #>  [20,]     1 24    1         9  0.01 #>  [21,]     1 25    1        10  0.01 #>  [22,]     1 26    1        11  0.01 #>  [23,]     1  4    2        12  0.01 #>  [24,]     1  5    2        13  0.01 #>  [25,]     1  6    2        14  0.01 #>  [26,]     1  7    2        15  0.01 #>  [27,]     1  8    2        16  0.01 #>  [28,]     1  9    2        17  0.01 #>  [29,]     1 10    2        18  0.01 #>  [30,]     1 11    2        19  0.01 #>  [31,]     1 12    2        20  0.01 #>  [32,]     1 13    2        21  0.01 #>  [33,]     1 17    2        12  0.01 #>  [34,]     1 18    2        13  0.01 #>  [35,]     1 19    2        14  0.01 #>  [36,]     1 20    2        15  0.01 #>  [37,]     1 21    2        16  0.01 #>  [38,]     1 22    2        17  0.01 #>  [39,]     1 23    2        18  0.01 #>  [40,]     1 24    2        19  0.01 #>  [41,]     1 25    2        20  0.01 #>  [42,]     1 26    2        21  0.01 #>  [43,]     1  3   14         1  0.01 #>  [44,]     1  4   14         2  0.01 #>  [45,]     1  5   14         3  0.01 #>  [46,]     1  6   14         4  0.01 #>  [47,]     1  7   14         5  0.01 #>  [48,]     1  8   14         6  0.01 #>  [49,]     1  9   14         7  0.01 #>  [50,]     1 10   14         8  0.01 #>  [51,]     1 11   14         9  0.01 #>  [52,]     1 12   14        10  0.01 #>  [53,]     1 13   14        11  0.01 #>  [54,]     1 16   14         1  0.01 #>  [55,]     1 17   14         2  0.01 #>  [56,]     1 18   14         3  0.01 #>  [57,]     1 19   14         4  0.01 #>  [58,]     1 20   14         5  0.01 #>  [59,]     1 21   14         6  0.01 #>  [60,]     1 22   14         7  0.01 #>  [61,]     1 23   14         8  0.01 #>  [62,]     1 24   14         9  0.01 #>  [63,]     1 25   14        10  0.01 #>  [64,]     1 26   14        11  0.01 #>  [65,]     1  4   15        12  0.01 #>  [66,]     1  5   15        13  0.01 #>  [67,]     1  6   15        14  0.01 #>  [68,]     1  7   15        15  0.01 #>  [69,]     1  8   15        16  0.01 #>  [70,]     1  9   15        17  0.01 #>  [71,]     1 10   15        18  0.01 #>  [72,]     1 11   15        19  0.01 #>  [73,]     1 12   15        20  0.01 #>  [74,]     1 13   15        21  0.01 #>  [75,]     1 17   15        12  0.01 #>  [76,]     1 18   15        13  0.01 #>  [77,]     1 19   15        14  0.01 #>  [78,]     1 20   15        15  0.01 #>  [79,]     1 21   15        16  0.01 #>  [80,]     1 22   15        17  0.01 #>  [81,]     1 23   15        18  0.01 #>  [82,]     1 24   15        19  0.01 #>  [83,]     1 25   15        20  0.01 #>  [84,]     1 26   15        21  0.01 #>  [85,]     2  1    1         0  1.00 #>  [86,]     2  2    2         0  1.00 #>  [87,]     2  3    3        22    NA #>  [88,]     2  4    4        22    NA #>  [89,]     2  5    5        22    NA #>  [90,]     2  6    6        22    NA #>  [91,]     2  7    7        22    NA #>  [92,]     2  8    8        22    NA #>  [93,]     2  9    9        22    NA #>  [94,]     2 10   10        22    NA #>  [95,]     2 11   11        22    NA #>  [96,]     2 12   12        22    NA #>  [97,]     2 13   13        22    NA #>  [98,]     2 14   14         0  1.00 #>  [99,]     2 15   15         0  1.00 #> [100,]     2 16   16        23    NA #> [101,]     2 17   17        23    NA #> [102,]     2 18   18        23    NA #> [103,]     2 19   19        23    NA #> [104,]     2 20   20        23    NA #> [105,]     2 21   21        23    NA #> [106,]     2 22   22        23    NA #> [107,]     2 23   23        23    NA #> [108,]     2 24   24        23    NA #> [109,]     2 25   25        23    NA #> [110,]     2 26   26        23    NA #>  #> $variances #>        to    from parameter #> 1   EOF_1   EOF_1         0 #> 2   EOF_2   EOF_2         0 #> 3 pollock pollock        22 #> 4     cod     cod        23 #>  #> $standard_deviations #> [1] \"unequal\" #>  #> attr(,\"class\") #> [1] \"eof_ram\""},{"path":"https://vast-lib.github.io/tinyVAST/reference/make_sem_ram.html","id":null,"dir":"Reference","previous_headings":"","what":"Make a RAM (Reticular Action Model) from a SEM (structural equation model) — make_sem_ram","title":"Make a RAM (Reticular Action Model) from a SEM (structural equation model) — make_sem_ram","text":"make_sem_ram converts SEM arrow notation ram describing SEM parameters","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/make_sem_ram.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make a RAM (Reticular Action Model) from a SEM (structural equation model) — make_sem_ram","text":"","code":"make_sem_ram(sem, variables, quiet = FALSE, covs = variables)"},{"path":"https://vast-lib.github.io/tinyVAST/reference/make_sem_ram.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make a RAM (Reticular Action Model) from a SEM (structural equation model) — make_sem_ram","text":"sem structural equation model structure, passed either specifyModel specifyEquations parsed control set path coefficients variance-covariance parameters variables character vector listing set variables quiet FALSE, default, number input lines reported     message printed suggesting specifyEquations cfa used. covs optional: character vector one elements, element   \tgiving string variable names, separated commas. Variances covariances   \tamong variables string added model. confirmatory   \tfactor analysis models specified via cfa, covs defaults   \tfactors model, thus specifying variances covariances among factors.   \tWarning: covs=\"x1, x2\" covs=c(\"x1\", \"x2\")   \tequivalent: covs=\"x1, x2\" specifies variance x1, variance   \tx2, covariance, covs=c(\"x1\", \"x2\") specifies   \tvariance x1 variance x2 covariance.","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/make_sem_ram.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make a RAM (Reticular Action Model) from a SEM (structural equation model) — make_sem_ram","text":"S3-class \"sem_ram\" containing: model Output specifyEquations specifyModel defines paths parameters ram reticular action module (RAM) describing dependencies","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/parse_path.html","id":null,"dir":"Reference","previous_headings":"","what":"Parse path — parse_path","title":"Parse path — parse_path","text":"parse_path copied sem::parse.path","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/parse_path.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parse path — parse_path","text":"","code":"parse_path(path)"},{"path":"https://vast-lib.github.io/tinyVAST/reference/parse_path.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parse path — parse_path","text":"path character string indicating one-headed two-headed path structural equation model","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/parse_path.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parse path — parse_path","text":"Tagged-list defining variables direction specified path coefficient","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/parse_path.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Parse path — parse_path","text":"Copied package sem licence GPL (>= 2) permission John Fox","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/predict.tinyVAST.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict using vector autoregressive spatio-temporal model — predict.tinyVAST","title":"Predict using vector autoregressive spatio-temporal model — predict.tinyVAST","text":"Predicts values given new covariates using tinyVAST model","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/predict.tinyVAST.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict using vector autoregressive spatio-temporal model — predict.tinyVAST","text":"","code":"# S3 method for class 'tinyVAST' predict(   object,   newdata,   remove_origdata = FALSE,   what = c(\"mu_g\", \"p_g\", \"palpha_g\", \"pgamma_g\", \"pepsilon_g\", \"pomega_g\", \"pdelta_g\",     \"pxi_g\", \"p2_g\", \"palpha2_g\", \"pgamma2_g\", \"pepsilon2_g\", \"pomega2_g\", \"pdelta2_g\",     \"pxi2_g\"),   se.fit = FALSE,   ... )"},{"path":"https://vast-lib.github.io/tinyVAST/reference/predict.tinyVAST.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict using vector autoregressive spatio-temporal model — predict.tinyVAST","text":"object Output tinyVAST(). newdata New data-frame independent variables used predict response. remove_origdata Whether eliminate original data TMB object, thereby speeding TMB object construction.  However, also eliminates information random-effect variance, appropriate requesting predictive standard errors epsilon bias-correction. REPORTed object output, mu_g inverse-linked transformed predictor including linear components, p_g first linear predictor, palpha_g first predictor fixed covariates formula, pgamma_g first predictor random covariates formula (e.g., splines), pomega_g first predictor spatial variation, pepsilon_g first predictor spatio-temporal variation, pxi_g first predictor spatially varying coefficients, p2_g second linear predictor, palpha2_g second predictor fixed covariates formula, pgamma2_g second predictor random covariates formula (e.g., splines), pomega2_g second predictor spatial variation, pepsilon2_g second predictor spatio-temporal variation, pxi2_g second predictor spatially varying coefficients. se.fit Calculate standard errors? ... used.","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/red_snapper.html","id":null,"dir":"Reference","previous_headings":"","what":"Presence/absence, count, and biomass data for red snapper — red_snapper","title":"Presence/absence, count, and biomass data for red snapper — red_snapper","text":"Data used demonstrate test analysis using multiple data types","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/red_snapper.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Presence/absence, count, and biomass data for red snapper — red_snapper","text":"","code":"data(red_snapper)"},{"path":"https://vast-lib.github.io/tinyVAST/reference/red_snapper_shapefile.html","id":null,"dir":"Reference","previous_headings":"","what":"Shapefile for red snapper analysis — red_snapper_shapefile","title":"Shapefile for red snapper analysis — red_snapper_shapefile","text":"Spatial extent used red snapper analysis, derived Chap-7 doi:10.1201/9781003410294","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/red_snapper_shapefile.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Shapefile for red snapper analysis — red_snapper_shapefile","text":"","code":"data(red_snapper_shapefile)"},{"path":"https://vast-lib.github.io/tinyVAST/reference/reexports.html","id":null,"dir":"Reference","previous_headings":"","what":"Objects exported from other packages — reexports","title":"Objects exported from other packages — reexports","text":"objects imported packages. Follow links see documentation. sdmTMB lognormal, nbinom1, nbinom2, tweedie","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/reload_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Reload a previously fitted model — reload_model","title":"Reload a previously fitted model — reload_model","text":"reload_model allows user save fitted model, reload new R terminal, relink DLLs functions expected.","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/reload_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reload a previously fitted model — reload_model","text":"","code":"reload_model(x, check_gradient = TRUE)"},{"path":"https://vast-lib.github.io/tinyVAST/reference/reload_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reload a previously fitted model — reload_model","text":"x Output tinyVAST, potentially DLLs linked check_gradient Whether check gradients reloaded model","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/reload_model.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reload a previously fitted model — reload_model","text":"Output tinyVAST DLLs relinked","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/reload_model.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Reload a previously fitted model — reload_model","text":"","code":"if (FALSE) { # \\dontrun{ # Run model fit = tinyVAST( ... ) saveRDS( object=fit, file=\"path_and_name.rds\" )  # Reload and relink fit_new = readRDS( file=\"path_and_name.rds\" ) fit_new = reload_model( x = fit_new ) } # }"},{"path":"https://vast-lib.github.io/tinyVAST/reference/residuals.tinyVAST.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate deviance or response residuals for tinyVAST — residuals.tinyVAST","title":"Calculate deviance or response residuals for tinyVAST — residuals.tinyVAST","text":"Calculate residuals","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/residuals.tinyVAST.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate deviance or response residuals for tinyVAST — residuals.tinyVAST","text":"","code":"# S3 method for class 'tinyVAST' residuals(object, type = c(\"deviance\", \"response\"), ...)"},{"path":"https://vast-lib.github.io/tinyVAST/reference/residuals.tinyVAST.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate deviance or response residuals for tinyVAST — residuals.tinyVAST","text":"object Output tinyVAST() type type residuals compute (option \"deviance\" \"response\" now) ... Note used","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/rmvnorm_prec.html","id":null,"dir":"Reference","previous_headings":"","what":"Multivariate Normal Random Deviates using Sparse Precision — rmvnorm_prec","title":"Multivariate Normal Random Deviates using Sparse Precision — rmvnorm_prec","text":"function provides random number generator multivariate normal distribution mean equal mean sparse precision matrix Q.","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/rmvnorm_prec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Multivariate Normal Random Deviates using Sparse Precision — rmvnorm_prec","text":"","code":"rmvnorm_prec(Q, n = 1, mean = rep(0, nrow(Q)))"},{"path":"https://vast-lib.github.io/tinyVAST/reference/rmvnorm_prec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Multivariate Normal Random Deviates using Sparse Precision — rmvnorm_prec","text":"Q sparse precision (inverse-covariance) matrix. n number observations. mean mean vector.","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/rmvnorm_prec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Multivariate Normal Random Deviates using Sparse Precision — rmvnorm_prec","text":"matrix dimension length(mean) n, containing realized draws specified mean precision","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/rotate_pca.html","id":null,"dir":"Reference","previous_headings":"","what":"Rotate factors to match Principal-Components Analysis — rotate_pca","title":"Rotate factors to match Principal-Components Analysis — rotate_pca","text":"Rotate lower-triangle loadings matrix order factors largest smallest variance.","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/rotate_pca.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rotate factors to match Principal-Components Analysis — rotate_pca","text":"","code":"rotate_pca(   L_tf,   x_sf = matrix(0, nrow = 0, ncol = ncol(L_tf)),   order = c(\"none\", \"increasing\", \"decreasing\") )"},{"path":"https://vast-lib.github.io/tinyVAST/reference/rotate_pca.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rotate factors to match Principal-Components Analysis — rotate_pca","text":"L_tf Loadings matrix dimension \\(T \\times F\\). x_sf Spatial response dimensions \\(S \\times F\\). order Options resolving label-switching via reflecting factor achieve given order across dimension \\(T\\).","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/rotate_pca.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rotate factors to match Principal-Components Analysis — rotate_pca","text":"List containing rotated loadings L_tf, inverse-rotated response matrix x_sf, rotation H","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/salmon_returns.html","id":null,"dir":"Reference","previous_headings":"","what":"North Pacific salmon returns — salmon_returns","title":"North Pacific salmon returns — salmon_returns","text":"Data used demonstrate test multivariate second-order autoregressive models using simultaneous autoregressive (SAR) process across regions. Data doi:10.1002/mcf2.10023","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/salmon_returns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"North Pacific salmon returns — salmon_returns","text":"","code":"data(salmon_returns)"},{"path":"https://vast-lib.github.io/tinyVAST/reference/sample_variable.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample from predictive distribution of a variable — sample_variable","title":"Sample from predictive distribution of a variable — sample_variable","text":"sample_variable samples joint distribution random fixed effects approximate predictive distribution variable Using sample_fixed=TRUE (default) sample_variable propagates variance fixed random effects, using sample_fixed=FALSE . Sampling fixed effects sometimes cause numerical - overflow (.e., output values NA) cases variance parameters estimated imprecisely.  cases, multivariate normal approximation used poor representation tail probabilities, results samples implausibly high (negative) variances, associated random effects implausibly high magnitude.","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/sample_variable.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sample from predictive distribution of a variable — sample_variable","text":"","code":"sample_variable(   x,   variable_name = \"mu_i\",   n_samples = 100,   sample_fixed = TRUE,   seed = 123456 )"},{"path":"https://vast-lib.github.io/tinyVAST/reference/sample_variable.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sample from predictive distribution of a variable — sample_variable","text":"x output \\code{tinyVAST()} variable_name name variable available report using Obj$report() parameters using Obj$env$parList() n_samples number samples joint predictive distribution fixed random effects.  Default 100, slow. sample_fixed whether sample fixed random effects, sample_fixed=TRUE default, just sample random effects, sample_fixed=FALSE seed integer used set random-number seed sampling variables, passed set.seed(.)","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/sample_variable.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sample from predictive distribution of a variable — sample_variable","text":"","code":"if (FALSE) { # \\dontrun{ # Run model using selected inputs, but also with getJointPrecision=TRUE fit = tinyVAST( ...,     control = tinyVASTcontrol(getJointPrecision=TRUE) )  # Run sample_variable sample = sample_variable( x = fit,                           variable_name = \"mu_i\" ) } # }"},{"path":"https://vast-lib.github.io/tinyVAST/reference/sea_ice.html","id":null,"dir":"Reference","previous_headings":"","what":"Arctic September sea ice concentrations — sea_ice","title":"Arctic September sea ice concentrations — sea_ice","text":"Data used demonstrate test empirical orthogonal function generalized linear latent variable model (EOF-GLLVM)","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/sea_ice.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Arctic September sea ice concentrations — sea_ice","text":"","code":"data(sea_ice)"},{"path":"https://vast-lib.github.io/tinyVAST/reference/sfnetwork_evaluator.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct projection matrix for stream network — sfnetwork_evaluator","title":"Construct projection matrix for stream network — sfnetwork_evaluator","text":"Make sparse matrix project stream-network nodes user-supplied points","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/sfnetwork_evaluator.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct projection matrix for stream network — sfnetwork_evaluator","text":"","code":"sfnetwork_evaluator(stream, loc, tolerance = 0.01)"},{"path":"https://vast-lib.github.io/tinyVAST/reference/sfnetwork_evaluator.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct projection matrix for stream network — sfnetwork_evaluator","text":"stream sfnetworks object representing stream network loc sf object representing points projected tolerance error-check tolerance","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/sfnetwork_mesh.html","id":null,"dir":"Reference","previous_headings":"","what":"Make mesh for stream network — sfnetwork_mesh","title":"Make mesh for stream network — sfnetwork_mesh","text":"Make mesh stream network","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/sfnetwork_mesh.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make mesh for stream network — sfnetwork_mesh","text":"","code":"sfnetwork_mesh(stream)"},{"path":"https://vast-lib.github.io/tinyVAST/reference/sfnetwork_mesh.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make mesh for stream network — sfnetwork_mesh","text":"stream sfnetworks object representing stream network","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/simulate_sfnetwork.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate GMRF for stream network — simulate_sfnetwork","title":"Simulate GMRF for stream network — simulate_sfnetwork","text":"Simulate GMRF stream network","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/simulate_sfnetwork.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate GMRF for stream network — simulate_sfnetwork","text":"","code":"simulate_sfnetwork(sfnetwork_mesh, theta, n = 1, what = c(\"samples\", \"Q\"))"},{"path":"https://vast-lib.github.io/tinyVAST/reference/simulate_sfnetwork.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate GMRF for stream network — simulate_sfnetwork","text":"sfnetwork_mesh Output sfnetwork_mesh theta Decorrelation rate n number simulated GMRFs Whether return simulated GMRF precision matrix","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/summary.tinyVAST.html","id":null,"dir":"Reference","previous_headings":"","what":"summarize tinyVAST — summary.tinyVAST","title":"summarize tinyVAST — summary.tinyVAST","text":"summarize parameters fitted tinyVAST","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/summary.tinyVAST.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"summarize tinyVAST — summary.tinyVAST","text":"","code":"# S3 method for class 'tinyVAST' summary(   object,   what = c(\"space_term\", \"time_term\", \"spacetime_term\", \"fixed\"),   ... )"},{"path":"https://vast-lib.github.io/tinyVAST/reference/summary.tinyVAST.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"summarize tinyVAST — summary.tinyVAST","text":"object Output tinyVAST() component summarize, whether space_term, spacetime_term, fixed fixed effects included GAM formula ... used","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/summary.tinyVAST.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"summarize tinyVAST — summary.tinyVAST","text":"tinyVAST includes three components: Space-variable interaction separable Gaussian Markov random field (GMRF) constructed structural equation model (SEM) spatial variable Space-variable-time interaction separable GMRF constructed dynamic SEM (nonseparable time-variable interaction) spatial variable Additive variation generalized additive model (GAM), representing exogenous covariates summarized interpreted differently, summary.tinyVAST facilitates . Regarding DSEM componennt, tinyVAST includes \"arrow lag\" notation, specifies set path coefficients exogenous variance parameters estimated. Function tinyVAST estimates maximum likelihood value coefficients parameters maximizing log-marginal likelihood. However, many users want associate individual parameters standard errors path coefficients specified using \"arrow lag\" notation. task complicated models path coefficients variance parameters specified share single value priori, assigned name NA hence assumed fixed value priori (coefficients parameters assigned value standard error). summary function therefore compiles MLE coefficients (including duplicating values path coefficients assigned value) standard error estimates, outputs table associates user-supplied path parameter names. also outputs z-score p-value arising two-sided Wald test (.e. comparing estimate divided standard error standard normal distribution).","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/tinyVAST.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit vector autoregressive spatio-temporal model — tinyVAST","title":"Fit vector autoregressive spatio-temporal model — tinyVAST","text":"Fits vector autoregressive spatio-temporal (VAST) model using minimal feature-set widely used interface.","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/tinyVAST.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit vector autoregressive spatio-temporal model — tinyVAST","text":"","code":"tinyVAST(   formula,   data,   time_term = NULL,   space_term = NULL,   spacetime_term = NULL,   family = gaussian(),   space_columns = c(\"x\", \"y\"),   spatial_domain = NULL,   time_column = \"time\",   times = NULL,   variable_column = \"var\",   variables = NULL,   distribution_column = \"dist\",   delta_options = list(formula = ~1),   spatial_varying = NULL,   weights = NULL,   control = tinyVASTcontrol(),   ... )"},{"path":"https://vast-lib.github.io/tinyVAST/reference/tinyVAST.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit vector autoregressive spatio-temporal model — tinyVAST","text":"formula Formula response left-hand-side predictors right-hand-side, parsed mgcv hence allowing s(.) splines offset(.) offset. data Data-frame predictor, response, offset variables.  Also includes variables specify space, time, variables, distribution samples, identified arguments variable_column, time_column, space_columns, distribution_column. time_term Specification time-series structural equation model structure constructing time-variable interaction defines time-varying intercept variable (.e., applies uniformly across space). time_term=NULL disables space-variable interaction; see make_dsem_ram() notation. space_term Specification structural equation model structure constructing space-variable interaction. space_term=NULL disables space-variable interaction; see make_sem_ram() notation. spacetime_term Specification time-series structural equation model structure including lagged simultaneous effects constructing time-variable interaction, combined separable process spatial correlation form space-time-variable interaction (.e., interaction occurs locally site). spacetime_term=NULL disables space-variable interaction; see make_dsem_ram()  make_eof_ram(). family function returning class family, including gaussian(), lognormal(), tweedie(),  binomial(),  Gamma(), poisson(), nbinom1(), nbinom2(). Alternatively, can named list functions, names match levels data$distribution_column allow different families row data. Delta model families possible, see Families delta-model options, space_columns string character vector indicates column(s) data indicating location sample. spatial_domain igraph object, space_columns string levels matching names vertices object. spatial_domain fmesher sfnetwork object, space_columns character vector indicating columns data coordinates sample. spatial_domain Object represents spatial relationships, either using fmesher::fm_mesh_2d() apply SPDE method, igraph::make_empty_graph() independent time-series, igraph::make_graph() apply simultaneous autoregressive (SAR) process, sfnetwork_mesh() stream networks, NULL specify single site.  using igraph graph must vertex names V(graph)$name match levels data[,'space_columns'] time_column character string indicating column data listing time-interval sample, set times argument times. times integer vector listing set times order. times=NULL, filled vector integers minimum maximum value data$time. variable_column character string indicating column data listing variable sample, set times argument variables. variables character vector listing set variables. variables=NULL, filled unique values data$variable_columns. distribution_column character string indicating column data listing distribution sample, set names argument family. variables=NULL, filled unique values data$variables. delta_options named list slots formula, space_term, spacetime_term. specify options second linear predictor delta model, used (estimable) delta family used samples. spatial_varying formula specifying spatially varying coefficients. weights numeric vector representing optional likelihood weights data likelihood. Weights sum one internally modified. Thee weights argument needs vector name variable data frame. control Output tinyVASTcontrol(), used define user settings. ... used.","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/tinyVAST.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fit vector autoregressive spatio-temporal model — tinyVAST","text":"tinyVAST includes four basic inputs specify model structure: formula specifies covariates splines Generalized Additive Model; space_term specifies interactions among variables time, constructing space-variable interaction. spacetime_term specifies interactions among variables time, constructing space-time-variable interaction. spatial_domain specifies spatial correlations default spacetime_term=NULL space_term=NULL turns multivariate temporal indexing, spatial_domain ignored, model collapses generalized additive model using gam.  specify univariate spatial model, user must specify spatial_domain either space_term=\"\" spacetime_term=\"\", latter two parsed include single exogenous variance single variable","code":""},{"path":[]},{"path":"https://vast-lib.github.io/tinyVAST/reference/tinyVAST.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit vector autoregressive spatio-temporal model — tinyVAST","text":"","code":"# Simulate a seperable two-dimensional AR1 spatial process n_x = n_y = 25 n_w = 10 R_xx = exp(-0.4 * abs(outer(1:n_x, 1:n_x, FUN=\"-\")) ) R_yy = exp(-0.4 * abs(outer(1:n_y, 1:n_y, FUN=\"-\")) ) z = mvtnorm::rmvnorm(1, sigma=kronecker(R_xx,R_yy) )  # Simulate nuissance parameter z from oscillatory (day-night) process w = sample(1:n_w, replace=TRUE, size=length(z)) Data = data.frame( expand.grid(x=1:n_x, y=1:n_y), w=w, z=as.vector(z) + cos(w/n_w*2*pi)) Data$n = Data$z + rnorm(nrow(Data), sd=1)  # Add columns for multivariate and/or temporal dimensions Data$var = \"n\"  # make SPDE mesh for spatial term mesh = fmesher::fm_mesh_2d( Data[,c('x','y')], n=100 )  # fit model with cyclic confounder as GAM term out = tinyVAST( data = Data,                 formula = n ~ s(w),                 spatial_domain = mesh,                 space_term = \"n <-> n, sd_n\" )"},{"path":"https://vast-lib.github.io/tinyVAST/reference/tinyVASTcontrol.html","id":null,"dir":"Reference","previous_headings":"","what":"Control parameters for tinyVAST — tinyVASTcontrol","title":"Control parameters for tinyVAST — tinyVASTcontrol","text":"Control parameters tinyVAST","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/tinyVASTcontrol.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Control parameters for tinyVAST — tinyVASTcontrol","text":"","code":"tinyVASTcontrol(   nlminb_loops = 1,   newton_loops = 0,   eval.max = 1000,   iter.max = 1000,   getsd = TRUE,   silent = getOption(\"tinyVAST.silent\", TRUE),   trace = getOption(\"tinyVAST.trace\", 0),   verbose = getOption(\"tinyVAST.verbose\", FALSE),   profile = c(),   tmb_par = NULL,   gmrf_parameterization = c(\"separable\", \"projection\"),   reml = FALSE,   getJointPrecision = FALSE,   calculate_deviance_explained = TRUE,   run_model = TRUE )"},{"path":"https://vast-lib.github.io/tinyVAST/reference/tinyVASTcontrol.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Control parameters for tinyVAST — tinyVASTcontrol","text":"nlminb_loops Integer number times call stats::nlminb(). newton_loops Integer number Newton steps running stats::nlminb(). eval.max Maximum number evaluations objective function allowed. Passed control stats::nlminb(). iter.max Maximum number iterations allowed. Passed control stats::nlminb(). getsd Boolean indicating whether call TMB::sdreport() silent Disable terminal output inner optimizer? trace Parameter values printed every trace iteration outer optimizer. Passed control stats::nlminb(). verbose Output additional messages model steps fitting? profile Parameters profile likelihood (subset appended random Laplace approximation disabled). tmb_par list parameters starting values, shape identical tinyVAST(...)$internal$parlist gmrf_parameterization Parameterization use Gaussian Markov random field, default separable constructs full-rank separable precision matrix, alternative projection constructs full-rank IID precision variables time, projects using inverse-cholesky precision, projection allows rank-deficient covariance. reml Logical: use REML (restricted maximum likelihood) estimation rather maximum likelihood? Internally, adds fixed effects list random effects integrate . getJointPrecision whether get joint precision matrix.  Passed sdreport. calculate_deviance_explained whether calculate proportion deviance explained.  See deviance_explained() run_model whether run model export TMB objects prior compilation (useful debugging)","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/vcov.tinyVAST.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract Variance-Covariance Matrix — vcov.tinyVAST","title":"Extract Variance-Covariance Matrix — vcov.tinyVAST","text":"extract covariance fixed effects, fixed random effects.","code":""},{"path":"https://vast-lib.github.io/tinyVAST/reference/vcov.tinyVAST.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract Variance-Covariance Matrix — vcov.tinyVAST","text":"","code":"# S3 method for class 'tinyVAST' vcov(object, which = c(\"fixed\", \"random\", \"both\"), ...)"},{"path":"https://vast-lib.github.io/tinyVAST/reference/vcov.tinyVAST.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract Variance-Covariance Matrix — vcov.tinyVAST","text":"object output tinyVAST() whether extract covariance among fixed effects, random effects, ... ignored, method compatibility","code":""},{"path":"https://vast-lib.github.io/tinyVAST/news/index.html","id":"tinyvast-100","dir":"Changelog","previous_headings":"","what":"tinyVAST 1.0.0","title":"tinyVAST 1.0.0","text":"Adding nbinom1 nbinom2 families Simplify argument names, changing sem space_term, dsem spacetime_term spatial_graph spatial_domain, eliminating delta_ names arguments delta_options Add time_term allow time-variable interaction (e.g., AR1 intercepts) Adding overview model-description vignettes","code":""},{"path":"https://vast-lib.github.io/tinyVAST/news/index.html","id":"tinyvast-071","dir":"Changelog","previous_headings":"","what":"tinyVAST 0.7.1","title":"tinyVAST 0.7.1","text":"Fixed bug (wrong output) using predict(fit, =\"mu_g\") Poisson-linked delta model Fixed bug (cryptic error message) using integrate_output Add cAIC (disabling EDF calculation now)","code":""},{"path":"https://vast-lib.github.io/tinyVAST/news/index.html","id":"tinyvast-070","dir":"Changelog","previous_headings":"","what":"tinyVAST 0.7.0","title":"tinyVAST 0.7.0","text":"Adding option spatially-varying-coefficient (SVC) models Add error-check data factor extra levels, conflicted logic adding origdata levels newdata calling predict, hence caused uniformative error previously","code":""},{"path":"https://vast-lib.github.io/tinyVAST/news/index.html","id":"tinyvast-060","dir":"Changelog","previous_headings":"","what":"tinyVAST 0.6.0","title":"tinyVAST 0.6.0","text":"Change integrate_output interface splitting W_gz V_gz four vectors area, type, covariate, weighting_index simplify documentations improve naming Fix bug cloglog logit links previously implemented use predict integrate_output","code":""},{"path":"https://vast-lib.github.io/tinyVAST/news/index.html","id":"tinyvast-050","dir":"Changelog","previous_headings":"","what":"tinyVAST 0.5.0","title":"tinyVAST 0.5.0","text":"Adding vignette showing fit multiple data types SDM Adding deviance_explained calculating default","code":""},{"path":"https://vast-lib.github.io/tinyVAST/news/index.html","id":"tinyvast-040","dir":"Changelog","previous_headings":"","what":"tinyVAST 0.4.0","title":"tinyVAST 0.4.0","text":"Adding code simulation residuals, examples vignettes","code":""},{"path":"https://vast-lib.github.io/tinyVAST/news/index.html","id":"tinyvast-030","dir":"Changelog","previous_headings":"","what":"tinyVAST 0.3.0","title":"tinyVAST 0.3.0","text":"Adding sdmTMB dependency, importing family options Adding vignette joint analysis condition density","code":""},{"path":"https://vast-lib.github.io/tinyVAST/news/index.html","id":"tinyvast-020","dir":"Changelog","previous_headings":"","what":"tinyVAST 0.2.0","title":"tinyVAST 0.2.0","text":"Add option specify covariance SEM DSEM notation","code":""},{"path":"https://vast-lib.github.io/tinyVAST/news/index.html","id":"tinyvast-010","dir":"Changelog","previous_headings":"","what":"tinyVAST 0.1.0","title":"tinyVAST 0.1.0","text":"Initial public alpha release","code":""}]
